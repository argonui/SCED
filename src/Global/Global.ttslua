require("Global/ChaosTokenMessages")
require("Global/TableSetupData")
require("core/Constants")
require("Global/i18n")
require("Global/i18nData")
local BlessCurseManagerApi        = require("chaosbag/BlessCurseManagerApi")
local ColorLib                    = require("util/ColorLib")
local CoroutineLib                = require("util/CoroutineLib")
local DeckLib                     = require("util/DeckLib")
local GUIDReferenceApi            = require("core/GUIDReferenceApi")
local MathLib                     = require("util/MathLib")
local MythosAreaApi               = require("mythos/MythosAreaApi")
local NavigationOverlayApi        = require("core/NavigationOverlayApi")
local PlayAreaApi                 = require("playarea/PlayAreaApi")
local PlayermatApi                = require("playermat/PlayermatApi")
local SearchLib                   = require("util/SearchLib")
local SoundCubeApi                = require("core/SoundCubeApi")
local TableLib                    = require("util/TableLib")
local TokenArrangerApi            = require("tokens/TokenArrangerApi")
local TokenChecker                = require("tokens/TokenChecker")
local TokenSpawnTrackerApi        = require("tokens/TokenSpawnTrackerApi")
local VictoryDisplayApi           = require("mythos/VictoryDisplayApi")
local Zones                       = require("playermat/Zones")

---------------------------------------------------------
-- general setup
---------------------------------------------------------

-- wait ids for various functions
local waitIds                     = {}
local dynamicTokensPerCard        = {}

local chaosTokens                 = {}
local chaosTokensLastMatGUID      = nil
local namesToIds

-- chaos token stat tracking
local tokenDrawingStats           = {}
local lastDrawnTokens             = {}

local bagSearchers                = {}
local lastZoneEnterObject         = nil

-- online functionality related variables
local library, requestObj, modMeta, searchFilter, authorFilter
local downloadPending             = {}
local acknowledgedUpgradeVersions = {}
local authorList                  = {}
local contentToShow               = "campaign"
local currentListItem             = 1
local TAB_IDS                     = {
  DW_tab1 = "campaign",
  DW_tab2 = "scenario",
  DW_tab3 = "fanmade-campaign",
  DW_tab4 = "fanmade-scenario",
  DW_tab5 = "fanmade-playercards"
}

-- optionPanel data (intentionally not local!)
optionPanel                       = {}
local sentOptionPanelMessage      = {}
local DROPDOWN_DATA               = {
  tableSetup = {
    "Classic (4P)",
    "Classic (2P)",
    "Upright (4P)",
    "Upright (3P)",
    "Sides (4P)",
    "True Solo (1P)",
    "Rotated (2P)"
  },
  tokenArrangerOdds = {
    "No Odds",
    "Basic",
    "Cumulative",
    "Full"
  },
  useResourceCounters = {
    "enabled",
    "custom",
    "disabled"
  }
}

-- defines the area for the "regular" mythos area
local MYTHOS_AREA_DATA            = {
  upperLeft  = { x = 5.09, z = 17.45 },
  lowerRight = { x = -7.71, z = -17.45 },
  center     = Vector(-1.31, 1.45, 0),
  rotation   = Vector(0, 270, 0)
}

-- this mapping of object names to index names is really important!
local GUID_INDEX_MAP              = {
  ["Clues"]           = "ClickableClueCounter",
  ["Clue Counter"]    = "ClueCounter",
  ["Damage"]          = "DamageCounter",
  ["Horror"]          = "HorrorCounter",
  ["Resources"]       = "ResourceCounter",
  ["Clue tokens"]     = "ClueTokenBag",
  ["Damage tokens"]   = "DamageTokenBag",
  ["Doom tokens"]     = "DoomTokenBag",
  ["Dynamic tokens"]  = "DynamicTokenBag",
  ["Horror tokens"]   = "HorrorTokenBag",
  ["Resource tokens"] = "ResourceTokenBag",
  ["Token Remover"]   = "TokenRemover"
}

-- track player-specific visibilities
local actionTrackerVisibility     = {}
local blurseVisibility            = {}
local handVisibility              = {}

-- track cards' tokens
local cardTokens                  = {}
local cardSettings                = {}

---------------------------------------------------------
-- data for tokens
---------------------------------------------------------

TokenManager                      = {}
local tokenOffsets                = {}

-- Table of data extracted from the token source bag, keyed by the Memo on each token which
-- should match the token type keys ("resource", "clue", etc)
local tokenTemplates

-- state IDs for the multi-stated resource tokens
local RESOURCE_STATES             = {
  ["resource"] = 1,
  ["ammo"]     = 2,
  ["bounty"]   = 3,
  ["charge"]   = 4,
  ["evidence"] = 5,
  ["secret"]   = 6,
  ["supply"]   = 7,
  ["offering"] = 8
}

---------------------------------------------------------
-- general code
---------------------------------------------------------

-- saving state of optionPanel to restore later
function onSave()
  local chaosTokensGUID = {}
  for _, obj in ipairs(chaosTokens) do
    if obj ~= nil then
      table.insert(chaosTokensGUID, obj.getGUID())
    end
  end

  return JSON.encode({
    acknowledgedUpgradeVersions = acknowledgedUpgradeVersions,
    actionTrackerVisibility     = actionTrackerVisibility,
    blurseVisibility            = blurseVisibility,
    chaosTokensLastMatGUID      = chaosTokensLastMatGUID,
    chaosTokensGUID             = chaosTokensGUID,
    handVisibility              = handVisibility,
    optionPanel                 = optionPanel
  })
end

function onLoad(savedData)
  if savedData and savedData ~= "" then
    local loadedData            = JSON.decode(savedData)
    acknowledgedUpgradeVersions = loadedData.acknowledgedUpgradeVersions
    actionTrackerVisibility     = loadedData.actionTrackerVisibility
    blurseVisibility            = loadedData.blurseVisibility
    chaosTokensLastMatGUID      = loadedData.chaosTokensLastMatGUID
    handVisibility              = loadedData.handVisibility
    optionPanel                 = loadedData.optionPanel

    -- restore saved state for drawn chaos tokens
    for _, guid in ipairs(loadedData.chaosTokensGUID or {}) do
      table.insert(chaosTokens, getObjectFromGUID(guid))
    end

    updateOptionPanelState()
  end

  -- call this for each existing object since TTS doesn't do it
  for _, obj in ipairs(getObjects()) do
    onObjectSpawn(obj)
  end

  -- potentially remove the tour if the player's preset contains that option
  maybeRemoveTourStarter()

  getModVersion()
  updateHandVisibility()
  TokenManager.initialize()

  -- these things update the Global XML and thus need to happen with delays
  Wait.time(updateBlurseVisibility, getXmlDelay())
  Wait.time(createActionTrackerUI, getXmlDelay())
  Wait.time(createChaosTokenSplashXml, getXmlDelay())
  Wait.time(NavigationOverlayApi.createXmlButtons, getXmlDelay())
  Wait.time(NavigationOverlayApi.updateVisibility, getXmlDelay())
  Wait.time(PlayAreaApi.updatePlayAreaGallery, getXmlDelay()) -- also selects the first item after 0.1s
  Wait.time(i18n.updateGlobalUiLanguage, getXmlDelay())
  Wait.time(initializeLibrary, getXmlDelay())                 -- also simulates a click on the first item after 0.1s
  Wait.time(function() printToAll("XML UI initialized.", "Green") end, getXmlDelay())

  -- add a button and context menu to the chaos token stat tracker
  local statTracker = GUIDReferenceApi.getObjectByOwnerAndType("Mythos", "StatTracker")
  if statTracker then
    statTracker.UI.setXmlTable({
      {
        tag = "Button",
        attributes = {
          onClick  = "Global/handleStatTrackerClick",
          position = "0 0 -11",
          width    = "135",
          height   = "135",
          color    = "#00000000"
        }
      }
    })
    statTracker.addContextMenuItem("Print my stats",
      function(playerColor) handleStatTrackerClick(Player[playerColor], "-3") end)
  end

  -- load specific option panel state for debugging / developing
  if LOAD_DEBUG_OPTION_PANEL then
    Wait.time(function() loadOptionPanelState(DEBUG_OPTION_PANEL_STATE) end, 2)
  end

  namesToIds = createChaosTokenNameLookupTable()
end

-- provides a random seed (from 1 to 999) to be used by "linked" objects like the action tokens
function getRandomSeed()
  return math.random(999)
end

function getXmlDelay()
  xmlDelay = (xmlDelay or 0) + 0.2
  return xmlDelay
end

-- Event hook for any object search. When chaos tokens are manipulated while the chaos bag
-- container is being searched, a TTS bug can cause tokens to duplicate or vanish. We lock the
-- chaos bag during search operations to avoid this.
function onObjectSearchStart(object, playerColor)
  local chaosBag = findChaosBag()
  if object == chaosBag then
    bagSearchers[playerColor] = true
  end
end

-- Event hook for any object search. When chaos tokens are manipulated while the chaos bag
-- container is being searched, a TTS bug can cause tokens to duplicate or vanish. We lock the
-- chaos bag during search operations to avoid this.
function onObjectSearchEnd(object, playerColor)
  local chaosBag = findChaosBag()
  if object == chaosBag then
    bagSearchers[playerColor] = nil
  end
  Player[playerColor].clearSelectedObjects()
end

function tryObjectEnterContainer(container, object)
  if object == nil or container == nil then return true end

  -- stop mini cards from forming decks
  if object.hasTag("Minicard") and container.hasTag("Minicard") then
    return false
  elseif object.type == "Card" and object.getName() ~= "Atlach-Nacha" then
    handleTokenDetaching({ card = object })
  elseif object.memo == "clueDoom" and container.memo == "clueDoom" then
    local flip1 = MathLib.roundAngleToMultiple(object.getRotation().z, 180)
    local flip2 = MathLib.roundAngleToMultiple(container.getRotation().z, 180)
    return flip1 == flip2
  end

  -- Pass object enter container events to the PlayArea to clear vector lines from dragged cards.
  -- This requires the try method as cards won't exist any more after they enter a deck.
  PlayAreaApi.tryObjectEnterContainer(container, object)
  return true
end

function onObjectEnterContainer(container, object)
  maybeUpdateClueDoomStackCount(container)
end

function onObjectLeaveContainer(container, object)
  maybeUpdateClueDoomStackCount(container, object)
end

function maybeAddDecalToChaosToken(object)
  if not TokenChecker.isChaosToken(object) then return end

  local decalData = {
    {
      name     = "RedCross",
      url      = "https://steamusercontent-a.akamaihd.net/ugc/16527220566318339270/4533B90A1CDA9AC23D480DC0F520E1FC24DC087E/",
      position = { 0, -0.02, 0 },
      rotation = { 270, 0, 0 },
      scale    = { 2.25, 2.25, 1 }
    }
  }

  object.setDecals(decalData)
end

-- moves an object to the new position of the mythos area
function maybeMoveObjectToMythosArea(object)
  -- only continue for interactable objects
  if object.interactable == false then return end

  -- tag for objects that should be in the old mythos area after its moved
  if object.hasTag("StayInMythos") then return end

  -- check if mythos area is moved
  local setupName = optionPanel["tableSetup"]
  local tableSetupData = TABLE_SETUP_DATA[setupName]
  local transformData = tableSetupData.transforms["MythosArea"]
  if not transformData then return end

  local objectPosition = object.getPosition()
  local objectRotation = object.getRotation()

  -- check if object is in "regular" mythos area
  if not inArea(objectPosition, MYTHOS_AREA_DATA) then return end

  -- calculate new position and rotation and move object
  local positionDiff = transformData.position - MYTHOS_AREA_DATA.center
  local rotationDiff = transformData.rotation - MYTHOS_AREA_DATA.rotation
  local originOffset = objectPosition - MYTHOS_AREA_DATA.center
  local originRotate = originOffset:rotateOver('y', rotationDiff.y)

  object.setPosition(MYTHOS_AREA_DATA.center + originRotate + positionDiff)
  object.setRotation(objectRotation + rotationDiff)
end

function maybeUpdateClueDoomStackCount(container, object)
  -- only continue for clues / doom tokens
  if object ~= nil and object.memo ~= "clueDoom" then return end
  if container.memo ~= "clueDoom" then return end

  local count = container.getQuantity()

  -- only continue for actual stacks in the playarea
  local isInPlayArea = false
  for _, zone in ipairs(container.getZones()) do
    if zone.getName() == "PlayAreaZone" then
      isInPlayArea = true
      break
    end
  end

  if isInPlayArea == false or count <= 1 then
    container.UI.setXmlTable({ {} })
    return
  end

  -- display clue/doom count via XML
  local size = 750
  local xmlTable = {
    {
      -- clue text
      tag = "Text",
      attributes = {
        font      = "font_teutonic-arkham",
        fontSize  = size * ((count < 10) and 0.8 or 0.6),
        fontStyle = "Bold",
        width     = size,
        height    = size,
        color     = "#003300",
        text      = count,
        position  = "0 0 -" .. (count * 10 + 1),
        rotation  = "0 0 180",
        scale     = "0.35 0.35 1"
      }
    },
    {
      -- doom text
      tag = "Text",
      attributes = {
        font      = "font_teutonic-arkham",
        fontSize  = size * ((count < 10) and 0.8 or 0.6),
        fontStyle = "Bold",
        width     = size,
        height    = size,
        color     = "#EEEEBBBB",
        text      = count,
        position  = "0 0 1",
        rotation  = "0 180 180",
        scale     = "0.35 0.35 1"
      }
    }
  }

  container.UI.setXmlTable(xmlTable)

  -- fix a TTS bug with token stack alt previews
  container.alt_view_angle = Vector(180, 0, 0)
end

-- TTS event for objects that enter zones
function onObjectEnterZone(zone, object)
  if lastZoneEnterObject == object then return end
  lastZoneEnterObject = object
  Wait.frames(function() lastZoneEnterObject = nil end, 3)

  -- detect the "token discard zones" beneath the hand zones
  local zoneName = zone.getName()
  if zoneName == "TokenDiscardZone" then
    if object.type == "Card" then
      local attachments = object.getAttachments()
      if not attachments then return end

      local matcolor = PlayermatApi.getMatColorByPosition(object.getPosition())
      local trash    = GUIDReferenceApi.getObjectByOwnerAndType(matcolor, "Trash")

      for i = #attachments, 1, -1 do
        local deepObj = attachments[i]
        if not TokenChecker.isChaosTokenName(deepObj["nickname"]) and deepObj["memo"] ~= nil then
          trash.putObject(object.removeAttachment(deepObj["index"]))
        end
      end
    elseif object.type == "Tile" and not TokenChecker.isChaosToken(object) and object.getMemo() and
        not object.getLock() and object.interactable == true and not object.isSmoothMoving() then
      local matcolor = PlayermatApi.getMatColorByPosition(object.getPosition())
      local trash    = GUIDReferenceApi.getObjectByOwnerAndType(matcolor, "Trash")
      trash.putObject(object)
    end
  elseif zoneName == "PlayAreaZone" then
    maybeUpdateClueDoomStackCount(object)
  elseif zone.type == "Hand" and object.type == "Card" then
    -- make sure the card is face-up
    if object.is_face_down then
      object.flip()
    end

    -- maybe reset data about sealed tokens (if that function exists)
    if object.hasTag("CardThatSeals") then
      callFunctionIfItExists(object, "resetSealedTokens")
    end

    -- maybe disable card helpers
    if object.hasTag("CardWithHelper") then
      callFunctionIfItExists(object, "setHelperState", false)
    end

    applyHidingToCard(object, zone.getValue())
  end
end

-- TTS event for objects that leave zones
function onObjectLeaveZone(zone, object)
  -- end here if one of the objects doesn't exist
  if zone.isDestroyed() or object.isDestroyed() then return end

  -- make sure that the object really left and isn't still in a hand zone
  for _, objZone in ipairs(object.getZones()) do
    if objZone.isDestroyed() or objZone.type == "Hand" then return end
  end

  -- make object visible
  object.setHiddenFrom({})
end

-- handle card drawing via number typing for multihanded gameplay
-- (and additionally allow Norman Withers to draw multiple cards via number)
function onObjectNumberTyped(hoveredObject, playerColor, number)
  -- adds cards to appropriate hand for Attachment Helper
  if hoveredObject.getName() == "Attachment Helper" then
    local matColor = PlayermatApi.getMatColorByPosition(hoveredObject.getPosition())
    local handColor = PlayermatApi.getPlayerColor(matColor)
    hoveredObject.deal(number, handColor)
    return true
  end

  -- only continue for decks or cards
  if hoveredObject.type ~= "Deck" and hoveredObject.type ~= "Card" then return end

  -- check if this is a card with states (and then change state instead of drawing it)
  local states = hoveredObject.getStates()
  if states ~= nil and #states > 0 then
    local stateId = hoveredObject.getStateId()
    if stateId ~= number and (#states + 1) >= number then
      hoveredObject.setState(number)
      return true
    end
  end

  -- check whether the hovered object is part of a players draw objects
  for matColor, _ in pairs(GUIDReferenceApi.getObjectsByType("Playermat")) do
    local deckAreaObjects = PlayermatApi.getDeckAreaObjects(matColor)
    if deckAreaObjects.topCard == hoveredObject or deckAreaObjects.draw == hoveredObject then
      PlayermatApi.updateMessageColor(matColor, playerColor)
      PlayermatApi.drawCardsWithReshuffle(matColor, number)
      return true
    end
  end
end

function onPlayerAction(player, action, targets)
  if action == Player.Action.Delete then
    if player.admin then
      for _, target in ipairs(targets) do
        maybeUpdateActionTrackerTokens(target, 5)
      end
    else
      -- disable delete action (only applies to promoted players) and discard objects instead
      for _, target in ipairs(targets) do
        local matColor = PlayermatApi.getMatColorByPosition(target.getPosition())
        local trash = GUIDReferenceApi.getObjectByOwnerAndType(matColor, "Trash")

        maybeUpdateActionTrackerTokens(target, 20)

        trash.putObject(target)
      end
      return false
    end
  elseif action == Player.Action.PickUp then
    -- attach tokens to each card -> might need to add a limit if performance is an issue
    for _, target in ipairs(targets) do
      if target.type == "Card" and not target.hasTag("Minicard") then
        handleTokenAttaching({ player = player, card = target })
      end
    end
  end
end

function onPlayerConnect(player)
  -- fix wrong camera for clients
  if not player.host then
    player.lookAt({
      position = Vector(-22.26, -2.5, 5.26),
      pitch    = 64.34,
      yaw      = 90,
      distance = 104
    })
  end
end

function onPlayerChangeColor()
  Wait.frames(function()
    -- updates the displayed names in the action tracker
    for matColor, _ in pairs(GUIDReferenceApi.getObjectsByType("Playermat")) do
      updateActionTrackerName(matColor)
    end
  end, 1)
end

function onObjectRotate(obj, _, flip, _, _, oldFlip)
  if flip == oldFlip then return end

  if obj.hasTag("Minicard") then
    for matColor, _ in pairs(GUIDReferenceApi.getObjectsByType("Playermat")) do
      Wait.frames(function() updateActionTrackerName(matColor) end, 75)
    end
  elseif TokenChecker.isChaosToken(obj) then
    if #chaosTokens == 0 then return end

    for _, token in pairs(chaosTokens) do
      if token == obj then
        local matColor = PlayermatApi.getMatColorByPosition(obj.getPosition())
        local tokenName = obj.getName()
        if flip == 180 then
          trackChaosToken(tokenName, matColor, true)
        else
          trackChaosToken(tokenName, matColor, false)
        end
      end
    end
  else
    maybeUpdateActionTrackerTokens(obj, 75)
  end
end

function onObjectSpawn(obj)
  if obj.hasTag("NotInteractable") then
    obj.interactable = false
  end

  if obj.hasTag("DoomCounter_ignore") then
    obj.highlightOn({ 0.67, 0.11, 0 })
  end

  if obj.hasTag("Temporary") then
    obj.highlightOn({ 0, 0.7843, 0.7843 })
  end

  if obj.hasTag("Reloadable") then
    obj.addContextMenuItem("Redownload this", function(playerColor)
      local md = JSON.decode(obj.getGMNotes()) or {}
      placeholder_download({ filename = md.filename, player = Player[playerColor], replace = obj.getGUID() })
    end)
  end

  if obj.hasTag("i18n_XML") then
    Wait.time(function() i18n.updateObjectUiLanguage(obj) end, 1)
  end

  maybeAddDecalToChaosToken(obj)
  maybeMoveObjectToMythosArea(obj)
  maybeUpdateClueDoomStackCount(obj)
  maybeUpdateActionTrackerTokens(obj, 5)
end

function onObjectDrop(playerColor, obj)
  if obj.hasTag("Investigator") then
    updateActionTrackerRows()
    updateActionTrackerWidth()
  elseif obj.hasTag("Minicard") then
    -- sync the mini card with an investigator below
    for _, card in ipairs(SearchLib.belowPosition(obj.getPosition(), "isCard")) do
      local md = JSON.decode(card.getGMNotes()) or {}
      if md.type == "Investigator" and (md.id or md.TtsZoopGuid) then
        local miniMd = JSON.decode(obj.getGMNotes()) or {}
        miniMd.type = "Minicard"
        miniMd.id = getMiniId(md.id or md.TtsZoopGuid)
        obj.setGMNotes(JSON.encode_pretty(miniMd))
        printToColor("Updated minicard ID to match investigator", playerColor, "Green")
      end
    end
  elseif obj.getMemo() == "dynamic" then
    -- handle dynamic tokens being dropped
    local searchResult = SearchLib.belowPosition(obj.getPosition(), "isCard")
    if #searchResult == 0 then return end

    -- track dynamic tokens per card
    local card = searchResult[1]
    local cardGuid = card.getGUID()
    dynamicTokensPerCard[card] = dynamicTokensPerCard[card] or {}
    table.insert(dynamicTokensPerCard[card], obj)

    -- make sure it can't be dropped again
    obj.interactable = false

    if waitIds["addToken" .. cardGuid] then
      Wait.stop(waitIds["addToken" .. cardGuid])
    end

    -- spawn matching tokens after a delay
    waitIds["addToken" .. cardGuid] = Wait.time(function()
      if card ~= nil then
        local result = TokenManager.addUseToCard({
          card = card,
          useType = "resource",
          additionalCount = #dynamicTokensPerCard[card]
        })
        for _, token in ipairs(dynamicTokensPerCard[card]) do
          if token ~= nil then
            if result == true then
              token.destruct()
            else
              obj.interactable = true
            end
          end
        end
      end
      dynamicTokensPerCard[card] = nil
      waitIds["addToken" .. cardGuid] = nil
    end, 0.3)
  else
    maybeUpdateActionTrackerTokens(obj, 20)
  end
end

function onObjectPickUp(_, obj)
  stopTokenTransformUpdating(obj)

  if obj.hasTag("UniversalToken") then
    local owner = GUIDReferenceApi.getOwnerOfObject(obj)
    if owner == "Mythos" then return end
    Wait.condition(
      function() updateActionTrackerTokens(owner, 1) end,
      function() return obj.resting end
    )
  end
end

function maybeUpdateActionTrackerTokens(obj, delayFrames)
  if obj == nil or obj.isDestroyed() or not obj.hasTag("UniversalToken") then return end
  local owner = GUIDReferenceApi.getOwnerOfObject(obj)
  if owner == "Mythos" then return end
  updateActionTrackerTokens(owner, delayFrames)
end

---------------------------------------------------------
-- chaos token drawing
---------------------------------------------------------

-- checks mythos area for chaos bag (also called by a lot of objects!)
function findChaosBag()
  local mythosArea = GUIDReferenceApi.getObjectByOwnerAndType("Mythos", "MythosArea")
  if mythosArea then
    for _, obj in ipairs(SearchLib.onObject(mythosArea)) do
      if obj.getName() == "Chaos Bag" or obj.getDescription() == "Chaos Bag" then
        obj.addTag("CleanUpHelper_ignore")
        return obj
      end
    end
  end

  -- error handling: chaos bag not found
  printToAll("Chaos bag couldn't be found.", "Red")
end

-- returns all chaos tokens to the bag
function returnChaosTokens()
  local chaosBag = findChaosBag()
  for _, token in pairs(chaosTokens) do
    if token ~= nil then
      token.memo = nil
      token.destroyAttachments()
      chaosBag.putObject(token)
    end
  end
  chaosTokens = {}
  isTokenXMLActive = false
  tokenSplash()
end

-- returns a single chaos token to the bag and calls respective functions
function returnChaosTokenToBag(params)
  local name = params.token.getName()
  local chaosBag = findChaosBag()
  params.token.memo = nil
  params.token.destroyAttachments()
  chaosBag.putObject(params.token)
  TokenArrangerApi.layout()
  if name == "Bless" or name == "Curse" then
    BlessCurseManagerApi.releasedToken(name, params.token.getGUID(), params.fromBag)
  end
end

-- returns the index of a token in the chaosTokens table
function getTokenIndex(token)
  for i, obj in ipairs(chaosTokens) do
    if obj == token then
      return i
    end
  end
end

-- starts a redraw effect and displays buttons for a choice if needed
function removeTokenFromPlay(params)
  removeTokenData = params

  if isTokenXMLActive == true then
    broadcastToAll("Clear already active buttons first, then try again", "Red")
    return
  end

  if #chaosTokens == 0 then
    broadcastToAll("No tokens found in play area", "Red")
    return
  end

  local functionName
  local tokenLabel
  if removeTokenData.type == "redraw" then
    functionName = "returnAndRedraw"
    tokenLabel = "Redraw"
  else
    functionName = "returnAndSeal"
    tokenLabel = "Seal"
  end

  -- nil handling
  removeTokenData.validTokens = removeTokenData.validTokens or {}
  removeTokenData.invalidTokens = removeTokenData.invalidTokens or {}

  -- determine if only some tokens are able to be returned to the bag
  local matchingTokensInPlay = {}
  local matchingCanceledTokens = {}
  for _, token in ipairs(chaosTokens) do
    local tokenName
    if token.memo ~= nil then
      tokenName = token.memo
    else
      tokenName = getReadableTokenName(token.getName())
    end

    -- allow valid tokens or not invalid tokens, also allow any token if both lists empty
    if (removeTokenData.validTokens[tokenName] ~= nil and TableLib.isEmpty(removeTokenData.invalidTokens)) or
        (TableLib.isEmpty(removeTokenData.validTokens) and not removeTokenData.invalidTokens[tokenName]) or
        (TableLib.isEmpty(removeTokenData.validTokens) and TableLib.isEmpty(removeTokenData.invalidTokens)) then
      table.insert(matchingTokensInPlay, token)
      if MathLib.roundAngleToMultiple(token.getRotation().z, 90) == 180 then
        table.insert(matchingCanceledTokens, token)
      end
    end
  end

  -- proceed according to number of matching tokens
  if #matchingTokensInPlay == 0 then
    broadcastToAll("No eligible token found in play area", "Red")
  elseif #matchingTokensInPlay == #matchingCanceledTokens then
    broadcastToAll("All matching tokens are already cancelled / ignored and thus not available for this effect.", "Red")
  elseif #matchingTokensInPlay == 1 then
    _G[functionName](_, matchingTokensInPlay[1].getGUID())
  else
    createTokenLabel(matchingTokensInPlay, functionName, tokenLabel)
  end
end

function createTokenLabel(matchingTokensInPlay, onClick, label)
  -- draw XML to allow choosing the token to return to bag
  isTokenXMLActive = true
  for _, token in ipairs(matchingTokensInPlay) do
    token.UI.setXmlTable({
      {
        tag = "VerticalLayout",
        attributes = {
          height = 275,
          width = 275,
          padding = "0 0 20 25",
          scale = "0.4 0.4 1",
          rotation = "0 0 180",
          position = "0 0 -15",
          color = "rgba(0,0,0,0.7)",
          onClick = "Global/" .. onClick .. "(" .. token.getGUID() .. ")",
        },
        children = {
          {
            tag = "Text",
            attributes = {
              fontSize = "100",
              font = "font_teutonic-arkham",
              color = "#ffffff",
              text = label
            }
          },
          {
            tag = "Text",
            attributes = {
              fontSize = "125",
              font = "font_arkhamicons",
              color = "#ffffff",
              text = "u"
            }
          }
        }
      }
    })
  end
end

-- returns a chaos token to the chaos bag and redraws another
function returnAndRedraw(_, tokenGUID)
  local returnedToken = getObjectFromGUID(tokenGUID)
  local tokenName = returnedToken.getName()
  local indexOfReturnedToken = getTokenIndex(returnedToken)
  local matColor = PlayermatApi.getMatColorByPosition(returnedToken.getPosition())
  local mat = GUIDReferenceApi.getObjectByOwnerAndType(matColor, "Playermat")

  local takeParameters = {
    position = returnedToken.getPosition(),
    rotation = returnedToken.getRotation()
  }

  if #chaosTokens > indexOfReturnedToken then
    takeParameters.rotation = takeParameters.rotation + Vector(0, 0, -8)
  end

  -- perform the actual token replacing
  trackChaosToken(tokenName, mat.getMemo(), true)
  local params = { token = returnedToken, fromBag = true }
  returnChaosTokenToBag(params)

  -- remove XML from tokens in play
  isTokenXMLActive = false
  for _, token in ipairs(chaosTokens) do
    token.UI.setXml("")
  end

  chaosTokens[indexOfReturnedToken] = drawChaosToken({
    mat            = mat,
    drawAdditional = true,
    tokenType      = removeTokenData.drawSpecificToken, -- currently only used for Nkosi Mabati
    takeParameters = takeParameters
  })

  -- remove these tokens from the bag
  if removeTokenData.returnToPool then
    -- let the bless/curse manager handle these
    if tokenName == "Bless" or tokenName == "Curse" then
      BlessCurseManagerApi.removeToken(tokenName)
    else
      removeChaosToken(namesToIds[tokenName])
    end
  end

  removeTokenData = {}
  -- return a reference to the freshly drawn token
  return chaosTokens[indexOfReturnedToken]
end

-- returns a chaos token to the chaos bag and seals it
function returnAndSeal(_, tokenGUID)
  local returnedToken = getObjectFromGUID(tokenGUID)
  local tokenName = returnedToken.getName()
  local indexOfReturnedToken = getTokenIndex(returnedToken)

  local params = { token = returnedToken, fromBag = true }
  returnChaosTokenToBag(params)
  table.remove(chaosTokens, indexOfReturnedToken)
  -- shift existing tokens to fill the gap, compute new position based on list length
  if #chaosTokens > 0 then
    local matColor = PlayermatApi.getMatColorByPosition(chaosTokens[1].getPosition())
    mat = GUIDReferenceApi.getObjectByOwnerAndType(matColor, "Playermat")
    for i = 1, #chaosTokens do
      local yPos = chaosTokens[i].getPosition() -- avoids slight visual hitch
      chaosTokens[i].setPositionSmooth(getChaosTokenPosition(mat, i - 1):setAt("y", yPos.y))
    end
  end

  -- remove XML from tokens in play
  isTokenXMLActive = false
  for _, token in ipairs(chaosTokens) do
    token.UI.setXml("")
  end

  -- tell the original card/object to seal the token
  local triggeringCard = getObjectFromGUID(removeTokenData.triggeringCardGUID)
  triggeringCard.call("sealTokenWrapper", { tokenName = tokenName, playerColor = removeTokenData.playerColor })
  removeTokenData = {}
end

-- helper function to determine the position of a chaos token on a playermat
function getChaosTokenPosition(mat, number)
  local tokenOffset = Vector(-1.55 + 0.17 * number, 0.25, -0.58)
  return mat.positionToWorld(tokenOffset)
end

-- Checks to see if the chaos bag can be manipulated. If a player is searching the bag when tokens
-- are drawn or replaced a TTS bug can cause those tokens to vanish. Any functions which change the
-- contents of the bag should check this method before doing so.
-- This method will broadcast a message to all players if the bag is being searched.
---@return boolean: True if the bag is manipulated, false if it should be blocked.
function canTouchChaosTokens()
  for _, searching in pairs(bagSearchers) do
    if searching then
      broadcastToAll("Someone is searching the chaos bag, can't touch the tokens.", "Red")
      return false
    end
  end
  return true
end

-- converts the human readable name to the empty name that the bag uses
function getChaosTokenName(tokenName)
  if tokenName == "Custom Token" then
    tokenName = ""
  end
  return tokenName
end

-- converts the empty name to the human readable name
function getReadableTokenName(tokenName)
  if tokenName == "" then
    tokenName = "Custom Token"
  end
  return tokenName
end

-- called by playermats (by the "Draw chaos token" button)
function drawChaosToken(params)
  if not canTouchChaosTokens() then return end

  if type(params.mat) == "string" then
    params.mat = GUIDReferenceApi.getObjectByOwnerAndType(params.mat, "Playermat")
  end

  local matGUID = params.mat.getGUID()

  -- return token(s) on other playermat first
  if chaosTokensLastMatGUID ~= nil and chaosTokensLastMatGUID ~= matGUID and #chaosTokens ~= 0 then
    returnChaosTokens()
    chaosTokensLastMatGUID = nil
    return
  end

  chaosTokensLastMatGUID = matGUID

  -- left-click while tokens are already drawn
  if not params.drawAdditional and #chaosTokens ~= 0 then
    returnChaosTokens()
    return
  end

  -- draw an additional chaos token
  local chaosBag = findChaosBag()
  if #chaosBag.getObjects() == 0 then return end
  chaosBag.shuffle()

  -- slightly rotate subsequent chaos tokens
  local tokenRotZ = 0
  if #chaosTokens > 0 then
    tokenRotZ = 354.5
  end

  local takeParameters = params.takeParameters or {}
  takeParameters.position = takeParameters.position or getChaosTokenPosition(params.mat, #chaosTokens)
  takeParameters.rotation = takeParameters.rotation or params.mat.getRotation():setAt("z", tokenRotZ)

  local token
  if params.guidToBeResolved then
    -- resolve a sealed token from a card
    token = getObjectFromGUID(params.guidToBeResolved)
    token.setPositionSmooth(takeParameters.position)
    TokenArrangerApi.layout()

    local tokenName = token.getName()
    if tokenName == "Bless" or tokenName == "Curse" then
      BlessCurseManagerApi.releasedToken(tokenName, token.getGUID())
    end
  else
    -- take a token from the bag, either specified or random
    if params.tokenType then
      for i, lookedForToken in ipairs(chaosBag.getObjects()) do
        if lookedForToken.nickname == params.tokenType then
          takeParameters.index = i - 1
        end
      end
    end
    token = chaosBag.takeObject(takeParameters)
  end

  -- get data for token description
  local name = token.getName()

  if name == "Bless" or name == "Curse" then
    local isLuckyPennyEnabled = params.mat.getVar("luckyPennyEnabled")
    if isLuckyPennyEnabled then
      token.UI.setXmlTable({
        {
          tag = "Panel",
          attributes = {
            height   = 275,
            width    = 275,
            scale    = "0.4 0.4 1",
            rotation = "0 0 180",
            position = "0 0 -15",
            color    = "rgba(0,0,0,0.7)"
          },
          children = {
            {
              tag = "Text",
              attributes = {
                font     = "font_arkhamicons",
                onClick  = "Global/luckyPenny(" .. token.getGUID() .. ")",
                text     = "zy",
                color    = "White",
                fontSize = "125"
              }
            }
          }
        }
      })
    end
  end

  local tokenData = MythosAreaApi.returnTokenData().tokenData or {}
  local specificData = tokenData[name] or {}
  token.setDescription(specificData.description or "")

  local matColor = params.mat.getMemo()
  trackChaosToken(name, matColor)

  if waitIds["startTokenSplash"] then
    Wait.stop(waitIds["startTokenSplash"])
  end
  waitIds["startTokenSplash"] = Wait.frames(function() tokenSplash(matColor) end, 5)

  if not params.takeParameters then
    table.insert(chaosTokens, token)
  end
  return token
end

-- splash drawn chaos token(s)
---@param matColor? string Color of the mat that is drawing (nil to hide the splash screen)
function tokenSplash(matColor)
  if matColor == nil then
    -- Check if it is already hidden
    local active = UI.getAttribute("CTS_main", "active")
    if active == false or active == "false" or active == "False" then return end
  else
    -- Work out the visibility from the settings
    local visibility = getTokenSplashVisibility(matColor)
    if visibility == "" then return end
    UI.setAttribute("CTS_main", "visibility", visibility)
  end

  local initialDelay = 0.5
  local fadeTime     = 1
  local screenTime   = 1

  if waitIds["hideChaosSplash"] then
    Wait.stop(waitIds["hideChaosSplash"])
    waitIds["hideChaosSplash"] = nil
  end

  if waitIds["showChaosSplash"] then
    Wait.stop(waitIds["showChaosSplash"])
    waitIds["showChaosSplash"] = nil
  end

  if waitIds["updateChaosSplash"] then
    Wait.stop(waitIds["updateChaosSplash"])
    waitIds["updateChaosSplash"] = nil
  end

  -- keep current state when hiding
  stopXmlFade(matColor == nil)

  -- quick fade-out
  if matColor == nil then
    waitIds["hideChaosSplash"] = Wait.time(function()
      fadeXml({ id = "CTS_main", direction = "out", time = fadeTime / 3 })
    end, 0.02)
    return
  end

  -- get the last 5 (or less) tokens
  local tokenNames = {}
  local tokenReferences = {}
  for i = #chaosTokens, 1, -1 do
    local token = chaosTokens[i]
    if token ~= nil then
      table.insert(tokenNames, token.getName())
      table.insert(tokenReferences, token)

      -- stop if there are already 5 tokens found
      if #tokenNames == 5 then break end
    end
  end

  UI.setAttribute("CTS_main", "active", false)
  UI.setAttribute("CTS_modifier", "active", false)
  UI.setAttribute("CTS_description", "active", false)

  -- calculate container width
  local elementWidth   = 200
  local elementSpacing = 20
  local containerWidth = elementWidth * #tokenNames + elementSpacing * (#tokenNames - 1)
  UI.setAttribute("CTS_image_container", "width", containerWidth)

  local leftEdgePositionX = -containerWidth / 2

  -- update the XML
  waitIds["updateChaosSplash"] = Wait.frames(function()
    for i = 1, 5 do
      local tokenName          = tokenNames[i]
      local tokenReference     = tokenReferences[i]

      local imageAttributes    = { active = false }
      local crossAttributes    = { active = false }
      local modifierAttributes = { active = false, text = "" }

      -- reset color if there is just one token
      if #tokenNames == 1 then
        imageAttributes.color = "#FFFFFFFF"
        crossAttributes.color = "#FFFFFFFF"
      end

      -- update visible tokens (special handling for custom tokens)
      if tokenName then
        if namesToIds[tokenName] then
          imageAttributes.image = "token-" .. namesToIds[tokenName]
        else
          imageAttributes.image = tokenReference.getCustomObject().image
        end

        imageAttributes.active    = true
        crossAttributes.active    = tokenReference.is_face_down
        modifierAttributes.active = true

        -- determine if modifier should be shown (only for symbol tokens)
        if tonumber(tokenName) == nil then
          local modifier = TokenArrangerApi.getCurrentModifier(tokenName) or TokenArrangerApi.getCurrentModifier("")
          if modifier and math.abs(modifier) < 100 then
            local modifierText = "( "
            if modifier > 0 then
              modifierText = modifierText .. "+"
            end
            modifierText                = modifierText .. modifier .. " )"
            modifierAttributes.text     = modifierText

            -- make sure the color is reset too
            modifierAttributes.color    = "#FFFFFFFF"

            -- calculate position
            local currentElementLeftX   = leftEdgePositionX + ((i - 1) * (elementWidth + elementSpacing))

            -- add half of the element's width for the center position
            modifierAttributes.position = currentElementLeftX + (elementWidth / 2) .. " 420 0"
          end
        end
      end

      -- apply changes
      UI.setAttributes("CTS_image" .. i, imageAttributes)
      UI.setAttributes("CTS_image_cross" .. i, crossAttributes)
      UI.setAttributes("CTS_modifier" .. i, modifierAttributes)
    end

    -- determine if scenario card reference data should be shown
    local descriptionAttributes = { active = false, text = "" }
    local tokenData = MythosAreaApi.returnTokenData()
    if tokenData then
      if tokenData.tokenData[tokenNames[1]] then
        local tokenDescription = tokenData.tokenData[tokenNames[1]].description
        if tokenDescription then
          screenTime                     = 1.5 -- more time due to text

          -- update the attributes
          descriptionAttributes.active   = true
          descriptionAttributes.text     = tokenDescription
          descriptionAttributes.position = (elementWidth - containerWidth) / 2 .. " 130 0"

          -- make sure the color is reset too
          descriptionAttributes.color    = "#FFFFFFFF"
        end
      end
    end

    UI.setAttributes("CTS_description", descriptionAttributes)

    -- fade it in after changes have been applied
    waitIds["showChaosSplash"] = Wait.time(function()
      fadeXml({ id = "CTS_main", direction = "in", time = fadeTime })
    end, initialDelay)

    -- fade it out after a delay
    waitIds["hideChaosSplash"] = Wait.time(function()
      fadeXml({ id = "CTS_main", direction = "out", time = fadeTime })
    end, initialDelay + fadeTime + screenTime)
  end, 5)
end

-- Works out who needs to see the token splash screen
function getTokenSplashVisibility(drawingMatColor)
  local viewers = {}

  for matColor, _ in pairs(GUIDReferenceApi.getObjectsByType("Playermat")) do
    local playerColor = PlayermatApi.getPlayerColor(matColor)
    local personalSetting = PlayermatApi.getTokenSplashOption(matColor)

    if personalSetting == "Global" then
      viewers[playerColor] = optionPanel["showTokenSplash"]
    elseif personalSetting == "Enabled" then
      viewers[playerColor] = true
    elseif personalSetting == "Disabled" then
      viewers[playerColor] = false
    elseif personalSetting == "Own Tokens" then
      viewers[playerColor] = (drawingMatColor == matColor)
    elseif personalSetting == "Others' Tokens" then
      viewers[playerColor] = (drawingMatColor ~= matColor)
    end
  end

  viewers["Black"] = optionPanel["showTokenSplash"]
  viewers["Grey"]  = optionPanel["showTokenSplash"]

  return table.concat(TableLib.getKeys(viewers, true), "|")
end

function luckyPenny(_, tokenGUID)
  local blurseToken = getObjectFromGUID(tokenGUID)

  local coinFlip = math.random(2)
  if coinFlip == 1 then
    blurseToken.memo = "Bless"
  else
    blurseToken.memo = "Curse"
  end

  local pos = blurseToken.getPosition() + Vector(1.35, 0.1, 0)
  local id = blurseToken.memo:lower()
  local url = ID_URL_MAP[id].url or ""

  if url ~= "" then
    spawnObject({
      type              = 'Custom_Tile',
      position          = pos,
      scale             = { 0.5, 1.0, 0.5 },
      rotation          = Vector(0, 270, 0),
      callback_function = function(obj)
        blurseToken.UI.setXml("")
        blurseToken.addAttachment(obj)
      end
    }).setCustomObject({
      type      = 2,
      image     = url,
      thickness = 0.1
    })
  end
end

---------------------------------------------------------
-- chaos token stat tracker
---------------------------------------------------------

function trackChaosToken(tokenName, matColor, subtract)
  -- increase stats by 1 (or decrease if token is returned)
  local modifier     = (subtract and -1 or 1)
  local readableName = getReadableTokenName(tokenName)

  -- track stats for "Overall" and per matColor
  for _, key in ipairs({ "Overall", matColor }) do
    -- initialize table
    tokenDrawingStats[key]               = tokenDrawingStats[key] or {}

    -- initialize per-player table for last drawn
    lastDrawnTokens[key]                 = lastDrawnTokens[key] or {}

    -- update stats
    tokenDrawingStats[key][readableName] = (tokenDrawingStats[key][readableName] or 0) + modifier
  end

  -- update any chaos token counters
  for _, obj in ipairs(getObjectsWithTag("ChaosTokenCounter")) do
    obj.call("maybeUpdateCounter", { tokenName = tokenName, matColor = matColor, modifier = modifier })
  end

  -- add to list of last drawn tokens (if not subtracting)
  if not subtract then
    table.insert(lastDrawnTokens["Overall"], { tokenName = tokenName, matColor = matColor })

    -- insert last drawn to per-player table
    table.insert(lastDrawnTokens[matColor], { tokenName = tokenName, matColor = matColor })

    if #lastDrawnTokens["Overall"] > 5 then
      table.remove(lastDrawnTokens["Overall"], 1)
    end

    -- last 5 check for per-player
    if #lastDrawnTokens[matColor] > 5 then
      table.remove(lastDrawnTokens[matColor], 1)
    end
  end
end

-- Left-click: print stats, Right-click: reset stats
function handleStatTrackerClick(player, clickType, _)
  if clickType == "-2" then
    -- right-clicked
    resetChaosTokenStatTracker(player)
    return
  end

  local mostAutoFails, mostElderSigns = "Nobody", "Nobody"
  local maxAutoFails, maxElderSigns   = 0, 0
  local foundAnyStats                 = false

  for matColor, personalStats in pairs(tokenDrawingStats) do
    -- skip if middle-clicked and not the color of the clicking player
    if clickType ~= "-3" or matColor == PlayermatApi.getMatColor(player.color) then
      local playerColor, playerName

      if matColor == "Overall" then
        playerColor = "White"
        playerName  = "Overall"
      else
        playerColor = PlayermatApi.getPlayerColor(matColor) or matColor
        playerName  = Player[playerColor] and Player[playerColor].steam_name or playerColor

        -- track auto-fails / elder signs
        if (personalStats["Auto-fail"] or 0) > maxAutoFails then
          mostAutoFails = playerColor
          maxAutoFails  = personalStats["Auto-fail"]
        end

        if (personalStats["Elder Sign"] or 0) > maxElderSigns then
          mostElderSigns = playerColor
          maxElderSigns  = personalStats["Elder Sign"]
        end
      end

      -- get the total count of drawn tokens for the player
      local totalCount = 0
      for _, value in pairs(personalStats) do
        totalCount = totalCount + value
      end

      -- only print the personal stats if any tokens were drawn
      if totalCount > 0 then
        foundAnyStats = true
        printToAll("------------------------------")
        printToAll(playerName .. " Stats", playerColor)

        -- print stats in order of the "ID_URL_MAP"
        for _, subtable in pairs(ID_URL_MAP) do
          local tokenName = subtable.name
          local value = personalStats[tokenName]
          if value and value ~= 0 then
            printToAll(tokenName .. ': ' .. tostring(value))
          end
        end

        -- also print stats for custom tokens
        local customTokenName = getReadableTokenName("")
        local customTokenCount = personalStats[customTokenName]
        if customTokenCount and customTokenCount ~= 0 then
          printToAll(customTokenName .. ': ' .. tostring(customTokenCount))
        end

        printToAll('Total: ' .. tostring(totalCount))

        -- also print last five personal chaos tokens
        printLastFiveChaosTokens(matColor)
      end
    end
  end

  -- detect if any player drew tokens
  if foundAnyStats then
    -- end here if middle-clicked
    if clickType == "-3" then return end

    printToAll("------------------------------")

    -- maybe print history for last 5 token draws
    printLastFiveChaosTokens("Overall")

    -- print the player with the most auto-fails / elder signs
    if mostAutoFails == mostElderSigns then
      outputRandomMessage(mostAutoFails, DUAL_MESSAGES, { r = 200 / 255, g = 100 / 255, b = 255 / 255 })
    else
      outputRandomMessage(mostAutoFails, AUTO_FAIL_MESSAGES, { r = 215 / 255, g = 30 / 255, b = 60 / 255 })
      outputRandomMessage(mostElderSigns, ELDER_SIGN_MESSAGES, { r = 30 / 255, g = 185 / 255, b = 215 / 255 })
    end
  else
    printToAll("No tokens have been drawn yet.", "Yellow")
  end
end

-- helper function to print last five chaos tokens
function printLastFiveChaosTokens(key)
  if lastDrawnTokens[key] and #lastDrawnTokens[key] > 0 then
    local tokenStr = ""
    for _, data in ipairs(lastDrawnTokens[key]) do
      local handColor = PlayermatApi.getPlayerColor(data.matColor) or data.matColor
      local tokenName = data.tokenName
      if handColor ~= nil then
        tokenName = "[" .. Color.fromString(handColor):toHex() .. "]" .. tokenName .. "[-]"
      end
      tokenStr = tokenStr .. tokenName .. ", "
    end

    -- remove last delimiter
    tokenStr = string.sub(tokenStr, 1, -3)
    printToAll("Last 5 (old to new): " .. tokenStr)
  end
end

function outputRandomMessage(playerColor, list, msgColor)
  if playerColor == "Nobody" then return end
  local playerName = getColoredName(playerColor)
  printToAll(list[math.random(#list)]:gsub("<Name>", playerName):gsub("<Day>", os.date("%A")), msgColor)
end

-- resets the count for each token to 0
function resetChaosTokenStatTracker(player)
  player.showConfirmDialog("Are you sure you want to reset the Chaos Token stats?",
    function()
      printToAll("Chaos Token stat tracker has been reset.")
      lastDrawnTokens = { ["Overall"] = {} }
      tokenDrawingStats = { ["Overall"] = {} }
    end
  )
end

---------------------------------------------------------
-- Chaos Bag / Token Manipulation
---------------------------------------------------------

function createChaosTokenNameLookupTable()
  local reversedTable = {}
  for k, v in pairs(ID_URL_MAP) do
    reversedTable[v.name] = k
  end
  return reversedTable
end

-- returns the currently drawn chaos tokens
---@api ChaosBagApi
function getChaosTokensinPlay()
  return chaosTokens
end

-- returns a table of chaos token ids in the current chaos bag
---@api ChaosBag / ChaosBagApi
function getChaosBagState()
  local tokens = {}
  local chaosBag = findChaosBag()

  for _, v in ipairs(chaosBag.getObjects()) do
    local id = namesToIds[v.name]
    if id then
      table.insert(tokens, id)
    else
      printToAll(v.name .. " token not recognized. Will not be recorded.", "Yellow")
    end
  end

  return tokens
end

-- respawns the chaos bag with a new state of tokens
---@param tokenList table List of chaos token ids
---@api ChaosBag / ChaosBagApi
function setChaosBagState(tokenList)
  if not canTouchChaosTokens() then return end

  local chaosBag                = findChaosBag()
  local chaosBagData            = chaosBag.getData()
  local reserve                 = GUIDReferenceApi.getObjectByOwnerAndType("Mythos", "ChaosBagReserve")
  local tokenCache              = {}
  chaosBagData.ContainedObjects = {}

  -- create a temporary copy of the data for each chaos token
  for _, objData in ipairs(reserve.getData().ContainedObjects) do
    tokenCache[objData.Nickname] = objData
  end

  -- iterate over tokenlist and insert specified tokens into new table
  for _, tokenId in ipairs(tokenList) do
    local tokenName = ID_URL_MAP[tokenId].name
    table.insert(chaosBagData.ContainedObjects, tokenCache[tokenName])
  end

  -- respawn chaos bag with changes
  chaosBag.destruct()
  spawnObjectData({ data = chaosBagData })

  -- remove tokens that are still in play
  for _, token in pairs(chaosTokens) do
    if token ~= nil then token.destruct() end
  end
  chaosTokens = {}
  chaosTokensLastMatGUID = nil

  -- reset bless / curse manager
  BlessCurseManagerApi.removeTakenTokensAndReset()

  printToAll("Chaos Bag set to chosen difficulty.", "Green")
end

-- spawns the specified chaos token and puts it into the chaos bag
---@param id string ID of the chaos token
function spawnChaosToken(id)
  if not canTouchChaosTokens() then return end

  local chaosBag = findChaosBag()
  if not chaosBag then return end

  id = id:lower()
  local idData = ID_URL_MAP[id]

  if idData then
    local chaosBagPosition = chaosBag.getPosition()
    local chaosBagRotation = chaosBag.getRotation()

    -- lock chaos bag so it doesn't move
    chaosBag.setLock(true)

    local tokenData = {
      ColorDiffuse     = { b = 1, g = 1, r = 1 },
      CustomImage      = {
        CustomTile = { Stretch = true, Thickness = 0.1, Type = 2 },
        ImageURL   = ID_URL_MAP[id].url
      },
      Hands            = false,
      HideWhenFaceDown = false,
      Name             = "Custom_Tile",
      Nickname         = ID_URL_MAP[id].name,
      Transform        = {
        posX   = chaosBagPosition.x,
        posY   = chaosBagPosition.y + 0.4, -- spawn directly inside chaos bag
        posZ   = chaosBagPosition.z,
        rotX   = 0,
        rotY   = chaosBagRotation.y,
        rotZ   = 0,
        scaleX = 0.81,
        scaleY = 1,
        scaleZ = 0.81
      }
    }
    return spawnObjectData({
      data = tokenData,
      callback_function = function()
        chaosBag.setLock(false)
        TokenArrangerApi.layout()
      end
    })
  end
end

-- removes the specified chaos token from the chaos bag
---@param id string ID of the chaos token
function removeChaosToken(id)
  if not canTouchChaosTokens() then return end

  local tokens = {}
  local chaosBag = findChaosBag()
  local name = ID_URL_MAP[id].name

  for _, v in ipairs(chaosBag.getObjects()) do
    if v.name == name then table.insert(tokens, v.guid) end
  end

  -- error handling: no matching token found
  if #tokens == 0 then
    printToAll("No " .. name .. " tokens in the chaos bag.", "Yellow")
    return
  end

  chaosBag.takeObject({
    guid = tokens[1],
    smooth = false,
    callback_function = function(obj)
      obj.destruct()
      TokenArrangerApi.layout()
    end
  })
  printToAll("Removing " .. name .. " token (in bag: " .. #tokens - 1 .. ")", "White")
end

-- returns all sealed tokens on cards to the chaos bag
function releaseAllSealedTokens(params)
  for _, obj in ipairs(getObjectsWithTag("CardThatSeals")) do
    obj.call("releaseAllTokensWrapper", params)
  end
end

---------------------------------------------------------
-- Content Importing and XML functions
---------------------------------------------------------

-- callback function for the search field in the download menu
function onSearchValueSubmit(_, value)
  -- this event seems to be called 5x at once, so we use this flag to just execute it once
  if ignoreSubmit then return end
  ignoreSubmit = true

  -- store input value in global var
  if value == "" then
    searchFilter = nil
  else
    searchFilter = value
  end

  -- update XML so that the settings persists
  UI.setAttribute("DW_searchField", "text", value)

  -- turn off flag after 0.1s
  Wait.time(function() ignoreSubmit = false end, 0.1)

  -- update list (including new filter setting)
  updateDownloadItemList(true)
end

-- callback function for the "author" dropdown in the download menu
function onAuthorFilterChanged(_, selectedIndex)
  selectedIndex = tonumber(selectedIndex)

  -- store input value in global var
  if selectedIndex == 0 then
    authorFilter = nil
  else
    authorFilter = authorList[selectedIndex]
  end

  -- update XML so that the settings persists
  UI.setAttribute("DW_authorDropdown", "value", selectedIndex)

  -- update list (including new filter setting)
  updateDownloadItemList(true)
end

-- forwards the requested content type to the update function and sets highlight to clicked tab
---@param tabId string Id of the clicked tab
function onClick_tab(_, _, tabId)
  for listId, listContent in pairs(TAB_IDS) do
    if listId == tabId then
      UI.setClass(listId, 'downloadTab activeTab')
      contentToShow = listContent
    else
      UI.setClass(listId, 'downloadTab')
    end
  end
  currentListItem = 1

  -- reset filters
  authorFilter, searchFilter = nil, nil
  UI.setAttribute("DW_searchField", "text", "")
  UI.setAttribute("DW_authorDropdown", "value", 0)

  updateDownloadItemList()
end

-- click function for the items in the download window
-- updates backgroundcolor for row panel and fontcolor for list item
function onClick_select(_, _, identificationKey)
  UI.setAttribute("panel" .. currentListItem, "color", "clear")
  UI.setAttribute(contentToShow .. "_" .. currentListItem, "color", "white")

  -- parses the identification key (contentToShow_currentListItem)
  if identificationKey then
    contentToShow = nil
    currentListItem = nil
    for str in string.gmatch(identificationKey, "([^_]+)") do
      if not contentToShow then
        -- grab the first part to know the content type
        contentToShow = str
      else
        -- get the index
        currentListItem = tonumber(str)
        break
      end
    end
  end

  UI.setAttribute("panel" .. currentListItem, "color", "grey")
  UI.setAttribute(contentToShow .. "_" .. currentListItem, "color", "black")
  updatePreviewWindow()
end

-- click function for the "Custom URL" button in the playarea image gallery
function onClick_customUrl(player)
  changeWindowVisibilityForColor(player.color, "playareaGallery")
  Wait.time(function()
    player.showInputDialog("Enter a custom URL for the playarea image", "", function(newURL)
      PlayAreaApi.updateSurface(newURL)
    end)
  end, 0.15)
end

-- click function for the download button in the preview window
function onClick_download(player)
  local params = library[contentToShow][currentListItem]
  params.player = player
  placeholder_download(params)
end

-- the download button on the placeholder objects calls this to directly initiate a download
---@param params table contains url and guid of replacement object
function placeholder_download(params)
  function downloadCoroutine()
    -- show progress bar
    UI.setAttribute("download_progress", "active", true)

    -- update progress bar
    while requestObj do
      UI.setAttribute("download_progress", "percentage", requestObj.download_progress * 100)
      CoroutineLib.yieldFrames()
    end
    UI.setAttribute("download_progress", "percentage", 100)

    -- wait 30 frames
    CoroutineLib.yieldFrames(30)

    -- hide progress bar
    UI.setAttribute("download_progress", "active", false)

    -- hide download window
    if params.player then
      changeWindowVisibilityForColor(params.player.color, "downloadWindow", false)
    end
  end

  local url = SOURCE_REPO .. params.filename .. ".json"
  requestObj = WebRequest.get(url, function(request) contentDownloadCallback(request, params) end)

  CoroutineLib.start(downloadCoroutine)
end

-- spawns a bag that contains every object from the library
function onClick_downloadAll(player)
  broadcastToAll("Download initiated - this will take a few minutes!")

  -- hide download window
  changeWindowVisibilityForColor(player.color, "downloadWindow", false)

  CoroutineLib.start(coroutineDownloadAll)
end

function coroutineDownloadAll()
  local JSON = [[
    {
      "Name": "Bag",
      "Transform": {
        "posX": {{POSX}},
        "posY": 2,
        "posZ": -95,
        "rotX": 0,
        "rotY": 270,
        "rotZ": 0,
        "scaleX": 1,
        "scaleY": 1,
        "scaleZ": 1
      },
      "Nickname": "{{NICKNAME}}",
      "Bag": {
        "Order": 0
      },
      "ContainedObjects": [
  ]]

  local posx = -45
  local downloadedItems = 0
  local skippedItems = 0

  -- loop through the library to add content
  for contentType, objectList in pairs(library) do
    broadcastToAll("Downloading " .. contentType .. "...")
    local contained = ""
    for _, params in ipairs(objectList) do
      local request = WebRequest.get(SOURCE_REPO .. params.filename .. ".json", function() end)
      local start = os.time()
      while true do
        if request.is_done then
          contained = contained .. request.text .. ","
          downloadedItems = downloadedItems + 1
          break
          -- time-out if item can't be loaded in 5s
        elseif request.is_error or (os.time() - start) > 5 then
          skippedItems = skippedItems + 1
          break
        end
        CoroutineLib.yieldFrames()
      end
    end
    local JSONCopy = JSON
    JSONCopy = JSONCopy .. contained .. "]}"
    JSONCopy = JSONCopy:gsub("{{POSX}}", posx)
    JSONCopy = JSONCopy:gsub("{{NICKNAME}}", contentType)
    spawnObjectJSON({ json = JSONCopy })
    posx = posx + 3
  end

  broadcastToAll(downloadedItems .. " objects downloaded.", "Green")
  broadcastToAll(skippedItems .. " objects had a time-out / error.", "Orange")
end

-- spawns a placeholder box for the selected object
function onClick_spawnPlaceholder(player)
  -- get object references
  local item = library[contentToShow][currentListItem]
  local dummy = GUIDReferenceApi.getObjectByOwnerAndType("Mythos", "PlaceholderBoxDummy")

  -- error handling
  if not item.boxsize or item.boxsize == "" or not item.boxart or item.boxart == "" then
    print("Error loading object.")
    return
  end

  -- get data for placeholder
  local spawnPos = { -39.5, 2, -87 }

  local meshTable = {
    big   = "https://steamusercontent-a.akamaihd.net/ugc/62583916778515295/AFB8F257CE1E4973F4C06160A2E156C147AEE1E3/",
    small = "https://steamusercontent-a.akamaihd.net/ugc/62583916778515333/9F0BE0C211BE3BD1725B4B855F5D3C9C0D020394/",
    wide  = "https://steamusercontent-a.akamaihd.net/ugc/2278324073260846176/33EFCAF30567F8756F665BE5A2A6502E9C61C7F7/"
  }

  local scaleTable = {
    big   = { 1.00, 0.14, 1.00 },
    small = { 2.21, 0.46, 2.42 },
    wide  = { 2.00, 0.11, 1.69 }
  }

  local placeholder = spawnObject({
    type     = "Custom_Model",
    position = spawnPos,
    rotation = Vector(0, 270, 0),
    scale    = scaleTable[item.boxsize],
  })

  placeholder.setCustomObject({
    mesh     = meshTable[item.boxsize],
    diffuse  = item.boxart,
    material = 3
  })

  placeholder.setColorTint({ 1, 1, 1, 71 / 255 })
  placeholder.setName(item.name)
  placeholder.setDescription("by " .. (item.author or "Unknown"))
  placeholder.setGMNotes(JSON.encode({ filename = item.filename }))
  placeholder.setLuaScript(dummy.getLuaScript())

  if player.color ~= "Grey" then
    player.pingTable(spawnPos)
  end

  -- hide download window
  changeWindowVisibilityForColor(player.color, "downloadWindow", false)
end

function onClick_toggleOptionPanel(player, clickType)
  if clickType == "-1" then
    -- regular behaviour for left-click
    local newState = changeWindowVisibilityForColor(player.color, "optionPanel")

    -- show/hide secondary windows
    if newState == true then
      changeWindowVisibilityForColor(player.color, "blessCurseManager", false)
      changeWindowVisibilityForColor(player.color, "actionTracker", false)
      changeWindowVisibilityForColor(player.color, "navPanelFull", false)
      changeWindowVisibilityForColor(player.color, "navPanelPlay", false)

      if not sentOptionPanelMessage[player.color] then
        printToColor("Right-click the Option Panel button to show presets.", player.color)
        sentOptionPanelMessage[player.color] = true
      end
    else
      if blurseVisibility[player.color] then
        changeWindowVisibilityForColor(player.color, "blessCurseManager", blurseVisibility[player.color])
      end
      if actionTrackerVisibility[player.color] then
        changeWindowVisibilityForColor(player.color, "actionTracker", actionTrackerVisibility[player.color])
      end
      NavigationOverlayApi.updateVisibility()
    end
  elseif clickType == "-2" then
    -- right-click: show option presets
    local presetNames = {}
    for name, _ in pairs(OPTION_PRESETS) do
      table.insert(presetNames, name)
    end

    player.showOptionsDialog("Choose an option preset", presetNames, 1,
      function(presetName)
        loadOptionPanelState(OPTION_PRESETS[presetName], true)
        printToAll("Loaded option preset: " .. presetName .. " (check console for details)", "Green")
      end)
  elseif clickType == "-3" then
    -- middle-click: directly load mods for your name
    local steamName = string.gsub(player.steam_name, "%s+", "") -- strip spaces from steam_name
    local options = OPTION_PRESETS[steamName]
    if options then
      loadOptionPanelState(options, true)
      printToAll("Loaded " .. player.steam_name .. "'s preferred options (check console for details).", "Green")
    else
      printToAll("Didn't find " .. player.steam_name .. "'s preferred options.", "Yellow")
    end
  end
end

-- toggles the visibility of the respective UI
---@param player tts__Player Player that triggered this
---@param windowId string Name of the UI to toggle
function onClick_toggleUi(player, windowId)
  -- let the Navigation Overlay handle the toggling of its visibility modes
  if windowId == "Navigation Overlay" then
    NavigationOverlayApi.cycleVisibility(player.color)
    changeWindowVisibilityForColor(player.color, "optionPanel", false)
    return
  end

  -- hide the playAreaGallery / downloadWindow if visible
  if windowId == "downloadWindow" then
    changeWindowVisibilityForColor(player.color, "playAreaGallery", false)
  elseif windowId == "playAreaGallery" then
    changeWindowVisibilityForColor(player.color, "downloadWindow", false)
  elseif windowId == "blessCurseManager" then
    -- store the state of the Bless/Curse Manager UI to restore it onLoad()
    blurseVisibility[player.color] = changeWindowVisibilityForColor(player.color, "blessCurseManager")

    changeWindowVisibilityForColor(player.color, "optionPanel", false)
    return
  elseif windowId == "actionTracker" then
    -- store the state of the Action Tracker UI to restore it onLoad()
    local visibility = changeWindowVisibilityForColor(player.color, "actionTracker")
    actionTrackerVisibility[player.color] = visibility
    printToColor("Action Tracker " .. (visibility and "enabled." or "disabled."), player.color)

    if visibility then
      if #PlayermatApi.getUsedMatColors() == 0 then
        printToColor("No player mats in use - place an investigator.", player.color)
      end
    end

    changeWindowVisibilityForColor(player.color, "optionPanel", false)
    return
  end

  changeWindowVisibilityForColor(player.color, windowId)
end

-- wrapper for the real function to unpack arguments
function changeWindowVisibilityForColorWrapper(params)
  changeWindowVisibilityForColor(params.color, params.windowId, params.overrideState, params.owner)
end

-- toggles the visibility of the specific window for the specified color
---@param color string Player color to toggle the visibility for
---@param windowId string ID of the XML element
---@param overrideState? boolean Forcefully sets the new visibility
---@param owner? tts__Object Object that owns the XML (or nil if Global)
---@return boolean visible Returns the new state of the visibility
function changeWindowVisibilityForColor(color, windowId, overrideState, owner)
  local targetUi = UI
  if owner then
    targetUi = owner.UI
  end

  -- current state
  local colorString = targetUi.getAttribute(windowId, "visibility") or ""

  -- parse the visibility string
  local visible = false
  local viewers = {}
  for str in string.gmatch(colorString, "%a+") do
    table.insert(viewers, str)
    if str == color then
      visible = true
    end
  end

  -- add / remove the color as viewer
  if visible == true then
    removeValueFromTable(viewers, color)
  elseif visible == false then
    table.insert(viewers, color)
  end
  visible = not visible

  -- resolve override
  if overrideState == true and visible == false then
    table.insert(viewers, color)
    visible = true
  elseif overrideState == false and visible == true then
    removeValueFromTable(viewers, color)
    visible = false
  end

  -- construct new string
  local newColorString = ""
  for _, viewer in ipairs(viewers) do
    newColorString = newColorString .. viewer .. "|"
  end

  -- remove last delimiter
  newColorString = newColorString:sub(1, -2)

  -- update the visibility of the XML
  targetUi.setAttribute(windowId, "visibility", newColorString)
  targetUi.setAttribute(windowId, "active", newColorString ~= "")

  return visible
end

-- Stops the currently ongoing fadeout
function stopXmlFade(keepCurrent)
  keepCurrentFade = keepCurrent
  stopFade = true
end

-- Custom fade function for XML elements
---@param params table Table with the following parameters:
--- id string ID of the XML element
--- direction "in" | "out" The direction of the fade
--- owner? tts__Object Object that owns the XML (or nil if Global)
--- time? number Time in seconds for the fade (defaults to 2)
function fadeXml(params)
  stopFade = nil -- A global value to allow stopping the animation

  local targetUi = params.owner and params.owner.UI or UI
  local xmlElement = getXmlTableElementById(targetUi.getXmlTable(), params.id)
  if not xmlElement then return end

  local elementsToFade = getAllChildElements(xmlElement)
  local initialStates = {}

  --- A list of all UI attributes that will be looked for and modified
  local FADEABLE_COLOR_ATTRIBUTES = { "color", "colors", "textColor", "outline" }

  -- Store the initial state of each element's color properties
  for _, element in ipairs(elementsToFade) do
    if element.attributes and element.attributes.id then
      local elementId = element.attributes.id

      -- Special handling for image/text elements without a color attribute
      if (element.tag == "Image" or element.tag == "Text") and not element.attributes.color then
        element.attributes.color = "#FFFFFFFF" -- Default to opaque white
      end

      -- Loop through the list of possible color attributes
      for _, property in ipairs(FADEABLE_COLOR_ATTRIBUTES) do
        local originalColorStr = element.attributes[property]
        if originalColorStr then
          local colorToParse = originalColorStr
          local colorSuffix = nil

          -- Check for the "|" separator
          local splitIndex = originalColorStr:find("|")
          if splitIndex then
            colorToParse = originalColorStr:sub(1, splitIndex - 1)
            colorSuffix = originalColorStr:sub(splitIndex)
          end

          -- A color attribute was found, so parse the first part
          local initialColor
          if colorToParse:sub(1, 1) == "#" then
            initialColor = ColorLib.hexToColor(colorToParse)
          else
            initialColor = Color.fromString(colorToParse)
          end

          if initialColor then
            initialStates[elementId] = initialStates[elementId] or {}

            table.insert(initialStates[elementId], {
              property = property,
              color    = initialColor,
              suffix   = colorSuffix -- Store the suffix (will be nil if none)
            })
          end
        end
      end
    end
  end

  -- Set the initial state before the animation begins
  if params.direction == "in" then
    -- For fading in, make the element active but fully transparent first
    targetUi.setAttribute(params.id, "active", true)
    for elementId, properties in pairs(initialStates) do
      for _, state in ipairs(properties) do
        local transparentColor = state.color:copy()
        transparentColor:setAt("a", 0)

        local colorStr = ColorLib.colorToHex(transparentColor) .. (state.suffix or "")
        targetUi.setAttribute(elementId, state.property, colorStr)
      end
    end
  end

  -- Start the animation coroutine
  CoroutineLib.start(function()
    local time = params.time or 2
    local timeStep = 0.015
    local timeElapsed = 0

    while timeElapsed < time do
      -- Early exit condition
      if stopFade then
        stopFade = nil

        if keepCurrentFade then
          keepCurrentFade = nil
          return
        end
        break
      end

      local progress = timeElapsed / time
      -- Fading in: alpha goes from 0 to 1. Fading out: alpha goes from 1 to 0.
      local currentAlphaFactor = (params.direction == "in") and progress or (1 - progress)

      for elementId, properties in pairs(initialStates) do
        -- Loop through each color property found for that ID
        for _, state in ipairs(properties) do
          local newColor = state.color:copy()
          newColor:setAt("a", newColor.a * currentAlphaFactor)

          -- Re-append suffix if it existed
          local newColorStr = ColorLib.colorToHex(newColor) .. (state.suffix or "")
          targetUi.setAttribute(elementId, state.property, newColorStr)
        end
      end

      CoroutineLib.yieldSeconds(timeStep)
      timeElapsed = timeElapsed + timeStep
    end

    -- Set the final state after the animation
    if params.direction == "out" then
      targetUi.setAttribute(params.id, "active", false)
    end

    -- Restore original colors to ensure final state and reset for next use
    for elementId, properties in pairs(initialStates) do
      for _, state in ipairs(properties) do
        local originalColorStr = ColorLib.colorToHex(state.color) .. (state.suffix or "")
        targetUi.setAttribute(elementId, state.property, originalColorStr)
      end
    end
  end)
end

-- updates the contents of the preview for items in the download window
function updatePreviewWindow()
  local item = library[contentToShow][currentListItem]
  local tempImage =
  "https://steamusercontent-a.akamaihd.net/ugc/2115061845788345842/2CD6ABC551555CCF58F9D0DDB7620197BA398B06/"

  -- set default image if not defined
  if item.boxsize == nil or item.boxsize == "" or item.boxart == nil or item.boxart == "" then
    item.boxsize = "big"
    item.boxart =
    "https://steamusercontent-a.akamaihd.net/ugc/762723517667628371/18438B0A0045038A7099648AA3346DFCAA267C66/"
  end

  UI.setValue("previewTitle", fallback(item.name, "- Name not found -"))
  UI.setValue("previewAuthor", "by " .. fallback(item.author, "- Author not found -"))
  UI.setValue("previewDescription", fallback(item.description, "- Description not found -"))

  if item.scenariocount and item.scenariocount ~= "" then
    UI.setValue("previewScenarioCount", "Scenarios: " .. item.scenariocount)
  else
    UI.setValue("previewScenarioCount", "")
  end

  -- update mask according to size (hardcoded values to align image in mask)
  local maskData = {}
  if item.boxsize == "big" then
    maskData = {
      image    = "box-cover-mask-big",
      width    = "870",
      height   = "435",
      offsetXY = "154 60"
    }
  elseif item.boxsize == "small" then
    maskData = {
      image    = "box-cover-mask-small",
      width    = "792",
      height   = "594",
      offsetXY = "135 13"
    }
  elseif item.boxsize == "wide" then
    maskData = {
      image    = "box-cover-mask-wide",
      width    = "756",
      height   = "630",
      offsetXY = "-190 -70"
    }
  end

  -- loading empty image as placeholder until real image is loaded
  UI.setAttribute("previewArtImage", "image", tempImage)

  -- insert the image itself
  UI.setAttribute("previewArtImage", "image", item.boxart)
  UI.setAttributes("previewArtMask", maskData)
end

function fallback(text, default)
  return (text and text ~= "") and text or default
end

function downloadCustomCycle(cycleId)
  if downloadPending[cycleId] then return end

  -- look for correct content
  for contentType, contentData in pairs(library) do
    for _, itemData in ipairs(contentData) do
      if itemData.cycle_code == cycleId then
        downloadPending[cycleId] = true
        local url = SOURCE_REPO .. itemData.filename .. ".json"
        requestObj = WebRequest.get(url, function(request)
          contentDownloadCallback(request, itemData, true)
          Wait.time(function() downloadPending[cycleId] = false end, 1)
        end)
        return true
      end
    end
  end
  print("Requested content couldn't be found in library.")
  return false
end

-- formats the json response from the webrequest into a key-value lua table
function formatLibrary(jsonResponse)
  library = {}

  for _, item in ipairs(jsonResponse["content"]) do
    local contentType = item["type"]

    -- add "fanmade" for unofficial content
    if item["author"] ~= "Fantasy Flight Games" then
      contentType = "fanmade-" .. contentType
    end

    -- initialize subtable
    if library[contentType] == nil then
      library[contentType] = {}
    end
    table.insert(library[contentType], item)
  end
end

-- updates the window content to the requested content
---@param skipAuthorUpdate? boolean If true, skips the update for the author dropdown
function updateDownloadItemList(skipAuthorUpdate)
  if not library then return end

  -- addition of list items according to library file
  local globalXml = Global.UI.getXmlTable() or {}
  local contentList = getXmlTableElementById(globalXml, 'contentList')

  -- reset the list of authors unless skipping
  if not skipAuthorUpdate then
    authorList = {}
  end

  contentList.children = {}
  for i, v in ipairs(library[contentToShow]) do
    -- if there's a filter, apply it (both for name and author)
    if (searchFilter == nil or string.contains(string.lower(v.name), searchFilter)) and
        (authorFilter == nil or v.author == authorFilter) then
      -- start collecting authors unless skipping
      if not skipAuthorUpdate then
        table.insert(authorList, v.author)
      end

      table.insert(contentList.children,
        {
          tag = "Panel",
          attributes = { id = "panel" .. i },
          children = {
            tag = 'Text',
            value = v.name,
            attributes = {
              id = contentToShow .. "_" .. i,
              onClick = 'onClick_select',
              alignment = 'MiddleLeft'
            }
          }
        })
    end
  end

  contentList.attributes.height = #contentList.children * 27

  -- populate the author dropdown with options unless skipping
  if not skipAuthorUpdate then
    authorList = TableLib.removeDuplicates(authorList)
    table.sort(authorList)

    local authorDropdown = getXmlTableElementById(globalXml, 'DW_authorDropdown')
    authorDropdown.children = { { tag = "Option", value = i18n.getStrById("DW_all_authors") } }
    for _, author in ipairs(authorList) do
      table.insert(authorDropdown.children, { tag = "Option", value = author })
    end
  end

  updateGlobalXml(globalXml)

  -- select the first item
  Wait.time(onClick_select, 0.2)
end

function getVisibilityStringFromTable(vTable)
  local vString = ""
  for playerColor, state in pairs(vTable) do
    if state then
      vString = vString .. playerColor .. "|"
    end
  end

  if vString ~= "" then
    vString = vString:sub(1, -2)
  end

  return vString
end

function createActionTrackerUI()
  -- make list of currently used mat colors
  local usedMatColors = PlayermatApi.getUsedMatColors()
  local isUsed = {}
  for _, matColor in ipairs(usedMatColors) do
    isUsed[matColor] = true
  end

  local visibilityString = getVisibilityStringFromTable(actionTrackerVisibility)

  local actionTrackerXml = {
    tag = "TableLayout",
    attributes = {
      id                                   = "actionTracker",
      color                                = "black",
      visibility                           = visibilityString,
      active                               = visibilityString ~= "",
      height                               = 30 * #usedMatColors,
      width                                = "300",
      offsetXY                             = "-2 396",
      columnWidths                         = "0 150",
      padding                              = "4 4 4 4",
      cellSpacing                          = "5",
      allowDragging                        = true,
      returnToOriginalPositionWhenReleased = false,
      rectAlignment                        = "LowerRight",
      raycastTarget                        = true,
      outlineSize                          = "2 2",
      outline                              = "#303030"
    },
    children = {}
  }

  -- Loop through playermats and create rows in the Action Tracker
  for _, matColor in ipairs(MAT_COLORS) do
    local cellColors = getActionTrackerCellColors(matColor)
    local playerColor = PlayermatApi.getPlayerColor(matColor) or matColor
    local playerRow = {
      tag = "Row",
      attributes = { id = "playerRow" .. matColor, active = isUsed[matColor] or false },
      children = {
        {
          tag = "Cell",
          children = {
            {
              tag = "Text",
              attributes = {
                id    = "playerName" .. matColor,
                color = playerColor,
                text  = getDisplayName(matColor)
              }
            }
          }
        },
        {
          tag = "Cell",
          children = {
            {
              tag = "HorizontalLayout",
              attributes = { spacing = 4 },
              children = {
                { tag = "Panel", attributes = { id = "playerAction1" .. matColor, color = cellColors[1] } },
                { tag = "Panel", attributes = { id = "playerAction2" .. matColor, color = cellColors[2] } },
                { tag = "Panel", attributes = { id = "playerAction3" .. matColor, color = cellColors[3] } },
                { tag = "Panel", attributes = { id = "playerAction4" .. matColor, color = cellColors[4] } },
                { tag = "Panel", attributes = { id = "playerAction5" .. matColor, color = cellColors[5] } }
              }
            }
          }
        }
      }
    }

    table.insert(actionTrackerXml.children, playerRow)
  end

  local xml = Global.UI.getXmlTable() or {}
  table.insert(xml, actionTrackerXml)
  updateGlobalXml(xml)
  Wait.frames(updateActionTrackerWidth, 3)
end

-- updates the layout of the action tracker
function updateActionTrackerRows()
  local usedMatColors = PlayermatApi.getUsedMatColors()
  local isUsed = {}
  for _, matColor in ipairs(usedMatColors) do
    isUsed[matColor] = true
  end

  UI.setAttribute("actionTracker", "height", 30 * #usedMatColors)
  for _, matColor in ipairs(MAT_COLORS) do
    UI.setAttribute("playerRow" .. matColor, "active", isUsed[matColor] or false)
  end
end

-- updates the color of the actions based on the playermats actions tokens
function updateActionTrackerTokens(matColor, delayFrames)
  if waitIds["actionTrackerTokens" .. matColor] then
    Wait.stop(waitIds["actionTrackerTokens" .. matColor])
    waitIds["actionTrackerTokens" .. matColor] = nil
  end
  waitIds["actionTrackerTokens" .. matColor] = Wait.frames(function()
    local cellColors = getActionTrackerCellColors(matColor)

    for i, cellColor in ipairs(cellColors) do
      UI.setAttribute("playerAction" .. i .. matColor, "color", cellColor)
    end

    Wait.frames(updateActionTrackerWidth, 3)

    waitIds["actionTrackerTokens" .. matColor] = nil
  end, delayFrames or 50)
end

function getActionTrackerCellColors(matColor)
  local actionCount = determineActionCount(matColor)
  local cellColors = {}

  for i = 1, 5 do
    if i <= actionCount.total then
      if actionCount.order[i] == true then
        table.insert(cellColors, "#C89B3C") -- gold for accessibility
      else
        table.insert(cellColors, "grey")
      end
    else
      table.insert(cellColors, "black")
    end
  end

  return cellColors
end

-- updates the displayed names in the action tracker
function updateActionTrackerName(matColor)
  local textColor = "grey"
  local fontStyle = "Italic"

  if isMiniReady(matColor) then
    textColor = PlayermatApi.getPlayerColor(matColor)
    fontStyle = "Normal"
  end

  UI.setAttributes("playerName" .. matColor, {
    color     = textColor,
    fontStyle = fontStyle,
    text      = getDisplayName(matColor)
  })
  updateActionTrackerRows()
end

function updateActionTrackerWidth()
  local columnCount = countActionTrackerColumns()

  -- show / hide actions
  for i = 1, 5 do
    for _, matColor in ipairs(MAT_COLORS) do
      UI.setAttribute("playerAction" .. i .. matColor, "active", i <= columnCount)
    end
  end

  UI.setAttribute("actionTracker", "columnWidths", "0 " .. columnCount * 25)
  UI.setAttribute("actionTracker", "width", 300 - (5 - columnCount) * 25)
end

function countActionTrackerColumns()
  -- check for the first column from the right that needs to be visible
  for i = 5, 1, -1 do
    for _, matColor in ipairs(MAT_COLORS) do
      local isRowActive = convertStringToBoolean(UI.getAttribute("playerRow" .. matColor, "active"))
      if isRowActive then
        local cellColor = UI.getAttribute("playerAction" .. i .. matColor, "color")
        if cellColor ~= "black" then return i end
      end
    end
  end
  return 1
end

function isMiniReady(matColor)
  local investigatorData = PlayermatApi.getActiveInvestigatorData(matColor)
  if not investigatorData then return false end

  local playAreaZone = GUIDReferenceApi.getObjectByOwnerAndType("Mythos", "PlayAreaZone")
  for _, obj in ipairs(playAreaZone.getObjects()) do
    if obj.hasTag("Minicard") and not obj.is_face_down then
      local md = JSON.decode(obj.getGMNotes()) or {}
      if md.id == investigatorData.miniId then return true end
    end
  end
  return false
end

function determineActionCount(matColor)
  local actionCount = {
    available = 0,
    used      = 0,
    total     = 0,
    order     = {}
  }

  local playermat   = GUIDReferenceApi.getObjectByOwnerAndType(matColor, "Playermat")
  if not playermat then return actionCount end

  local localPos       = Vector(-1.2, 0.1, -0.28)
  local pos            = PlayermatApi.transformLocalPosition(localPos, matColor):setAt("y", 3)
  local rot            = PlayermatApi.returnRotation(matColor)
  local size           = Vector(5, 6, 0.1)
  local searchResult   = SearchLib.inArea(pos, rot, size, "isUniversalToken")

  actionCount.total    = #searchResult

  -- sort tokens from left to right
  local tokenPositions = {}
  for _, obj in ipairs(searchResult) do
    tokenPositions[obj] = playermat.positionToLocal(obj.getPosition())
  end

  table.sort(searchResult, function(a, b) return tokenPositions[a].x > tokenPositions[b].x end)

  for _, obj in ipairs(searchResult) do
    if obj.is_face_down then
      actionCount.used = actionCount.used + 1
    else
      actionCount.available = actionCount.available + 1
    end
    table.insert(actionCount.order, not obj.is_face_down)
  end

  return actionCount
end

-- returns the display name (steam name or investigator)
function getDisplayName(matColor)
  local playerColor = PlayermatApi.getPlayerColor(matColor)

  -- if the mat was removed or something wierd happened, just return the matColor
  if not playerColor then return matColor end

  -- return steam name if there's a seated player
  if Player[playerColor] and Player[playerColor].steam_name then
    return Player[playerColor].steam_name
  end

  -- return investigator name if possible
  local investigatorName = PlayermatApi.getInvestigatorName(matColor)
  if investigatorName ~= "" then
    return investigatorName
  end

  -- default to playerColor
  return playerColor
end

function createChaosTokenSplashXml()
  local CROSS_URL =
  "https://steamusercontent-a.akamaihd.net/ugc/16527220566318339270/4533B90A1CDA9AC23D480DC0F520E1FC24DC087E/"

  -- create defaults for text elements
  local defaultsXml = {
    tag = "Defaults",
    children = {
      {
        tag = "Text",
        attributes = {
          class       = "CTS",
          scale       = "0.4 0.4 1",
          font        = "font_teutonic-arkham",
          alignment   = "MiddleCenter",
          outline     = "black",
          outlineSize = "3 -3"
        }
      },
      {
        tag = "Text",
        attributes = {
          class              = "modifier",
          fontSize           = 150,
          horizontalOverflow = "Overflow",
          height             = 150,
          width              = 1000,
          position           = "0 420 0",
          ignoreLayout       = true,
          active             = false
        }
      }
    }
  }

  -- create the main panel that holds the splash screen elements
  local mainPanelXml = {
    tag        = "Panel",
    attributes = { id = "CTS_main", active = "false" },
    children   = {}
  }

  for i = 1, 5 do
    table.insert(mainPanelXml.children, {
      tag        = "Text",
      attributes = { id = "CTS_modifier" .. i, class = "CTS modifier" }
    })
  end

  -- image container for the chaos tokens (and crosses)
  local imageContainerXml = {
    tag = "HorizontalLayout",
    attributes = {
      id             = "CTS_image_container",
      height         = 200,
      spacing        = 20,
      position       = "0 275 0",
      childAlignment = "MiddleCenter",
      ignoreLayout   = true
    },
    children = {}
  }

  -- add the images and crosses
  for i = 1, 5 do
    table.insert(imageContainerXml.children, {
      tag = "Image",
      attributes = {
        id             = "CTS_image" .. i,
        preferredWidth = 200,
        active         = false
      },
      children = {
        {
          tag = "Image",
          attributes = {
            id     = "CTS_image_cross" .. i,
            image  = CROSS_URL,
            active = false
          }
        }
      }
    })
  end
  table.insert(mainPanelXml.children, imageContainerXml)

  -- final text to show the chaos token description
  local descriptionXml = {
    tag = "Text",
    attributes = {
      id                   = "CTS_description",
      class                = "CTS",
      height               = 1250,
      width                = 1250,
      position             = "0 130 0",
      ignoreLayout         = true,
      resizeTextForBestFit = true,
      resizeTextMinSize    = 85,
      horizontalOverflow   = "Wrap",
      verticalOverflow     = "Overflow"
    }
  }
  table.insert(mainPanelXml.children, descriptionXml)

  local xml = Global.UI.getXmlTable() or {}
  table.insert(xml, defaultsXml)
  table.insert(xml, mainPanelXml)
  updateGlobalXml(xml)
end

-- this helper function updates the global XML while preserving the visibility of windows
function updateGlobalXml(newXml)
  -- preserve visibility settings for these elements
  local windowIdList = {
    "blessCurseManager",
    "downloadWindow",
    "optionPanel",
    "playAreaGallery"
  }

  -- get current state and update newXml
  for _, windowId in ipairs(windowIdList) do
    local element = getXmlTableElementById(newXml, windowId)
    if element and element.attributes then
      element.attributes.active = UI.getAttribute(windowId, "active")
      element.attributes.visibility = UI.getAttribute(windowId, "visibility")
    end
  end

  UI.setXmlTable(newXml)
end

-- called after the webrequest of downloading an item
-- deletes the placeholder and spawns the downloaded item
function contentDownloadCallback(request, params, addToAdditionalCards)
  requestObj = nil

  -- error handling
  if request.is_error or request.response_code ~= 200 then
    print('Error: ' .. request.error)
    return
  end

  -- initiate content spawning
  local spawnTable = { json = request.text }
  if params.replace then
    local replacedObject = getObjectFromGUID(params.replace)
    if replacedObject then
      spawnTable.position = replacedObject.getPosition()
      spawnTable.rotation = replacedObject.getRotation()
      spawnTable.scale    = replacedObject.getScale()
      destroyObject(replacedObject)
    end
  end

  if addToAdditionalCards then
    local additionalCardsBag = GUIDReferenceApi.getObjectByOwnerAndType("Mythos", "AdditionalPlayerCardsBag")
    spawnTable.position = additionalCardsBag.getPosition() + Vector(0, 2, 0)
    spawnTable.rotation = additionalCardsBag.getRotation()
  end

  -- if position is undefined, get empty position
  if not spawnTable.position then
    local pos = getValidSpawnPosition()
    if not pos then
      broadcastToAll("Please make sure there's space in the upper middle of the table and try again.", "Red")
      return
    end

    spawnTable.position = pos
    spawnTable.rotation = Vector(0, 270, 0)
  end

  spawnTable["callback_function"] = function(obj)
    Wait.time(function()
      -- if spawned from menu, move the camera and/or ping the table
      if params.name then
        -- move camera
        if params.player then
          params.player.lookAt({
            position = obj.getPosition(),
            pitch    = 65,
            yaw      = 90,
            distance = 65
          })
        end

        -- ping object
        local pingPlayer = params.player or Player.getPlayers()[1]
        if pingPlayer.color ~= "Grey" then
          pingPlayer.pingTable(obj.getPosition())
        end
      end

      -- add memo to identify custom content with the AllCardsBag
      if params.cycle_code then
        obj.setMemo(params.cycle_code)
      end

      -- add gmnotes for "reloading"
      local md = JSON.decode(obj.getGMNotes()) or {}
      md.filename = params.filename
      obj.setGMNotes(JSON.encode(md))
      obj.addTag("Reloadable")

      -- trigger event
      onObjectSpawn(obj)
    end, 0.1)
  end

  if not pcall(function() spawnObjectJSON(spawnTable) end) then
    print('Error loading ' .. params.filename)
  end
end

-- gets the first empty position to spawn a custom content object safely
function getValidSpawnPosition()
  local potentialSpawnPositionX = { 63, 48, 33 }
  local potentialSpawnPositionY = 1.5
  local potentialSpawnPositionZ = { 32, 16, 0, -16, -32 }

  for _, posX in ipairs(potentialSpawnPositionX) do
    for _, posZ in ipairs(potentialSpawnPositionZ) do
      local pos = Vector(posX, potentialSpawnPositionY, posZ)
      if checkPositionForContentSpawn(pos) then
        return pos
      end
    end
  end
  return nil
end

-- checks whether something is in the specified position
-- first hit is the table surface, additional hits means something is there
---@return boolean: True if empty
function checkPositionForContentSpawn(checkPos)
  local searchResult = SearchLib.atPosition(checkPos, "isInteractable")
  return #searchResult == 0
end

-- initalizes the library
function initializeLibrary()
  WebRequest.get(SOURCE_REPO .. 'library.json', libraryDownloadCallback)
end

-- downloading of the library file
function libraryDownloadCallback(request)
  if request.is_error or request.response_code ~= 200 then
    print('error: ' .. request.error)
    return
  end

  local jsonResponse = nil
  if pcall(function() jsonResponse = JSON.decode(request.text) end) then
    formatLibrary(jsonResponse)
    updateDownloadItemList()
  else
    print('error parsing downloaded library')
  end
end

-- loops through an XML table and returns the specified object
---@param ui table XmlTable (get this via getXmlTable)
---@param id string Id of the object to return
function getXmlTableElementById(ui, id)
  for _, obj in ipairs(ui) do
    if obj.attributes and obj.attributes.id and obj.attributes.id == id then return obj end
    if obj.children then
      local result = getXmlTableElementById(obj.children, id)
      if result then return result end
    end
  end
  return nil
end

-- Recursively collects an element and all its children into a flat list
---@param xmlElement table The starting XML element table
---@param elementList? table An optional table to add elements to
---@return table: A flat list of the element and all its children
function getAllChildElements(xmlElement, elementList)
  elementList = elementList or {}
  if xmlElement == nil then return elementList end

  table.insert(elementList, xmlElement)

  if xmlElement.children then
    for _, child in ipairs(xmlElement.children) do
      getAllChildElements(child, elementList)
    end
  end

  return elementList
end

---------------------------------------------------------
-- Option Panel related functionality
---------------------------------------------------------

-- changes the UI state and the internal variable for the togglebuttons
function onClick_toggleOption(_, _, id)
  local currentState = optionPanel[id]
  local newState = not currentState
  applyOptionPanelChange(id, newState)
  UI.setAttribute(id, "image", newState and "option_on" or "option_off")
end

-- color selection for playArea
function onClick_playAreaConnectionColor(player, _, id)
  player.showColorDialog(optionPanel[id], function(color)
    applyOptionPanelChange(id, color)
  end)
end

-- called by selecting something in a dropdown
function onDropdownChange(player, selectedIndex, id)
  local indexNumber = tonumber(selectedIndex) + 1
  local oldValue    = optionPanel[id]
  local valueToStore

  -- specific value getting
  if id == "removePlayermat" then
    if selectedIndex == 0 then return end
  elseif id == "uiLanguage" then
    valueToStore = LANGUAGES[indexNumber].code
  else
    valueToStore = DROPDOWN_DATA[id][indexNumber]
  end

  optionPanel[id] = valueToStore

  if id == "removePlayermat" then
    -- set selected value back to first option
    UI.setAttribute(id, "value", 0)
  else
    -- update XML so that the settings persists
    UI.setAttribute(id, "value", selectedIndex)
  end

  -- potentially special follow-up
  if id == "removePlayermat" then
    local matColor = MAT_COLORS[tonumber(selectedIndex)]
    confirmPlayermatRemoval(player, matColor)
  elseif id == "uiLanguage" then
    i18n.updateGlobalUiLanguage()
    i18n.updateAllObjectsUiLanguage()
  elseif id == "tableSetup" then
    updateTableSetup(valueToStore, oldValue)
  elseif id == "tokenArrangerOdds" then
    TokenArrangerApi.layout()

    if valueToStore ~= "No Odds" and not tokenArrangerWarningShown then
      broadcastToAll(
        "Odds calculation is unreliable when using tokens that draw other tokens (bless or curse for example).", "Yellow")
      tokenArrangerWarningShown = true
    end
  end
end

function getDropdownOptionIndex(id, name)
  for index, optionName in ipairs(DROPDOWN_DATA[id]) do
    if optionName == name then
      return index
    end
  end
end

-- returns the ID (position in the table) for a provided language code
function returnLanguageId(code)
  for index, tbl in ipairs(LANGUAGES) do
    if tbl.code == code then
      return index
    end
  end
end

-- called by the playermat removal selection dropdown
function confirmPlayermatRemoval(player, matColor)
  local mat = GUIDReferenceApi.getObjectByOwnerAndType(matColor, "Playermat")

  if mat then
    -- confirmation dialog about deletion
    if player.color ~= "Grey" then
      player.pingTable(mat.getPosition())
    end
    player.showConfirmDialog("Do you really want to remove " .. matColor .. "'s playermat and related objects?",
      function() removePlayermat(matColor) end)
  else
    player.showConfirmDialog("Do you want to respawn " .. matColor .. "'s playermat and related objects?",
      function() spawnPlayermat(matColor) end)
  end
end

-- removes a playermat and all related objects from play
---@param matColor string Color of the playermat to remove
function removePlayermat(matColor)
  local matObjects = GUIDReferenceApi.getObjectsByOwner(matColor)
  if not matObjects.Playermat then return end

  -- if there's a seated player, move them to grey
  local handColor = PlayermatApi.getPlayerColor(matColor)
  if Player[handColor].seated then
    Player[handColor].changeColor("Grey")
  end

  -- remove objects on mat
  local objectsToRemove = PlayermatApi.searchAroundPlayermat(matColor, "isInteractable")
  Wait.frames(function()
    local chaosBag = findChaosBag()
    for _, obj in ipairs(objectsToRemove) do
      if obj ~= nil and not obj.hasTag("CleanUpHelper_ignore") then
        -- don't remove chaos tokens
        if TokenChecker.isChaosToken(obj) then
          if chaosBag then
            chaosBag.putObject(obj)
          end
        else
          obj.destruct()
        end
      end
    end
  end, 10)

  -- remove mat owned objects
  for _, obj in pairs(matObjects) do
    obj.destruct()
  end

  -- update index
  GUIDReferenceApi.editIndex(matColor)

  -- update the action tracker
  updateActionTrackerRows()
  updateActionTrackerWidth()
end

function collectPlayermatSpawnData()
  local sourceBag = GUIDReferenceApi.getObjectByOwnerAndType("Mythos", "ObjectSourceBag")

  -- error handling for missing sourceBag
  if not sourceBag then
    broadcastToAll("Option panel source bag could not be found!", "Red")
    return
  end

  local spawnData = {}
  for _, objData in ipairs(sourceBag.getData().ContainedObjects) do
    if objData.Nickname == "Playermat Objects" then
      for _, deepObjData in ipairs(objData.ContainedObjects) do
        local name = deepObjData.Nickname
        if name == nil or name == "" then name = "HandZone" end
        spawnData[name] = deepObjData
      end
    end
  end
  return spawnData
end

function spawnPlayermatObjects(matColor, playermat, transformData, spawnData)
  local tableSetupData = TABLE_SETUP_DATA[optionPanel["tableSetup"]]
  local sharesBags = tableSetupData.sharedBagArea and (matColor == "White" or matColor == "Orange")
  for name, objData in pairs(spawnData) do
    if name ~= "Playermat" then
      if not (sharesBags and SHARED_BAGS_DATA.objects[name]) then
        local indexName = GUID_INDEX_MAP[name] or string.gsub(name, " ", "")

        -- get the local position / rotation for it
        local localPos = Zones.getLocalZoneData(matColor, name)
        if localPos then
          local pos = playermat.positionToWorld(localPos)
          local rot = transformData.rotation:copy()

          -- special handling for certain objects
          if name == "HandZone" then
            rot = rot + Vector(0, 180, 0)
            objData.FogColor = matColor
          elseif name == "Token Draw Dummy" then
            objData.Memo = matColor
          elseif name == "Damage" or name == "Horror" then
            rot = rot + Vector(0, 10, 180)
          elseif name == "Clues" or name == "Clue Counter" or name == "Resources" then
            rot = rot + Vector(0, 10, 0)
          end

          -- maybe lift the clickable clue counters
          if name == "Clues" and optionPanel["useClueClickers"] then
            pos = pos + Vector(0, 0.525, 0)
          end

          -- if the object already exists, move it instead
          local ref = GUIDReferenceApi.getObjectByOwnerAndType(matColor, indexName)
          if ref then
            ref.setPosition(pos)
            ref.setRotation(rot)
          else
            updateTransformData(objData, pos, rot)

            -- spawn object and update index
            local obj = spawnObjectData({ data = objData })
            Wait.frames(function() GUIDReferenceApi.editIndex(matColor, indexName, obj.getGUID()) end, 3)
          end
        end
      end
    end
  end

  -- also spawn any helpers that are already enabled (hardcoded list atm)
  for _, helperName in ipairs({ "Hand Helper", "Search Assistant" }) do
    local cleanName = helperName:gsub("%s+", "")

    -- check if the object already exists
    local helper = GUIDReferenceApi.getObjectByOwnerAndType(matColor, cleanName)
    if helper == nil then
      if optionPanel["show" .. cleanName] then
        local data = PlayermatApi.getHelperSpawnData(matColor, helperName)
        spawnOrRemoveHelper(state, helperName, data.position, data.rotation, matColor)
      end
    end
  end
end

function spawnPlayermat(matColor, transformData)
  local spawnData = collectPlayermatSpawnData()
  if not spawnData then return end

  -- get transforms if not supplied
  if not transformData then
    local setupName = optionPanel["tableSetup"]
    local tableSetupData = TABLE_SETUP_DATA[setupName]
    transformData = tableSetupData.transforms["Playermat" .. matColor]
    if not transformData then
      broadcastToAll("This playermat is not part of the current table layout.", "Orange")
      return
    end
  end

  function spawnPlayermatCoroutine()
    -- handle mat spawning first
    updateTransformData(spawnData.Playermat, transformData.position, transformData.rotation)

    -- update color data of mat
    spawnData.Playermat.Memo = matColor
    local scriptState = JSON.decode(spawnData.Playermat.LuaScriptState)
    scriptState.playerColor = matColor
    spawnData.Playermat.LuaScriptState = JSON.encode(scriptState)

    -- spawn the mat
    local playermat = spawnObjectData({ data = spawnData.Playermat })
    CoroutineLib.yieldFrames(5)
    GUIDReferenceApi.editIndex(matColor, "Playermat", playermat.getGUID())

    -- spawn objects
    spawnPlayermatObjects(matColor, playermat, transformData, spawnData)

    CoroutineLib.yieldFrames(5)

    -- ensure playermat has correct references
    playermat.call("getOwnedObjects")

    -- update the action tracker
    updateActionTrackerRows()
    updateActionTrackerWidth()
  end

  CoroutineLib.start(spawnPlayermatCoroutine)
end

function updateTransformData(data, position, rotation)
  data.Transform.posX = position.x
  data.Transform.posY = position.y
  data.Transform.posZ = position.z
  data.Transform.rotX = rotation.x
  data.Transform.rotY = rotation.y
  data.Transform.rotZ = rotation.z
end

function spawnSharedBagArea()
  spawnData = spawnData or collectPlayermatSpawnData()
  if not spawnData then return end

  for name, objData in pairs(spawnData) do
    if SHARED_BAGS_DATA.objects[name] then
      local indexName = GUID_INDEX_MAP[name] or string.gsub(name, " ", "")

      -- if the object already exists, skip it
      local ref = GUIDReferenceApi.getObjectByOwnerAndType("Mythos", indexName)
      if not ref then
        -- get the local position / rotation for it
        local transformData = SHARED_BAGS_DATA.transforms[indexName]
        if transformData then
          updateTransformData(objData, transformData.position, transformData.rotation)

          -- spawn object and update index
          local obj = spawnObjectData({ data = objData })
          Wait.frames(function() GUIDReferenceApi.editIndex("Mythos", indexName, obj.getGUID()) end, 3)
        end
      end
    end
  end
end

function removeSharedBagArea()
  for name, _ in pairs(SHARED_BAGS_DATA.objects) do
    local indexName = GUID_INDEX_MAP[name] or string.gsub(name, " ", "")
    GUIDReferenceApi.removeObjectByOwnerAndType("Mythos", indexName)
  end
end

function updateTableSetup(newSetupName, oldSetupName)
  spawnData = spawnData or collectPlayermatSpawnData()
  if not spawnData then return end

  if newSetupName == oldSetupName then return end

  local tableSetupData = TABLE_SETUP_DATA[newSetupName]
  if not tableSetupData then return end

  -- update playercount
  PlayAreaApi.setInvestigatorCount(tableSetupData.playerCount)

  function tableSetupCoroutine()
    -- if the current layout does not have a shared bag area, remove it
    if not tableSetupData.sharedBagArea then
      removeSharedBagArea()
    end

    CoroutineLib.yieldFrames(2)

    -- playermat preparation
    for _, matColor in ipairs(MAT_COLORS) do
      if tableSetupData.transforms["Playermat" .. matColor] then
        -- move existing mats upwards temporarily to avoid collisions (SearchLib searches up to 2 units)
        PlayermatApi.moveAndRotate(matColor, nil, nil, Vector(0, 3, 0))
      else
        -- remove unnecessary playermats (do this first to avoid unwanted collisions / interactions)
        removePlayermat(matColor)
      end
      CoroutineLib.yieldFrames(2)
    end

    -- mythos objects preparation
    for objectName, defaultData in pairs(MYTHOS_DEFAULT_TRANSFORMS) do
      local transformData = tableSetupData.transforms[objectName] or defaultData
      if transformData then
        local mainObject = GUIDReferenceApi.getObjectByOwnerAndType("Mythos", objectName)
        if mainObject then
          moveObjectWithObjectsOnTop(mainObject, nil, nil, Vector(0, 3, 0))
          CoroutineLib.yieldFrames(2)
        end
      end
    end

    -- actual movement of playermats
    for _, matColor in ipairs(MAT_COLORS) do
      local transformData = tableSetupData.transforms["Playermat" .. matColor]
      if transformData then
        local playermat = GUIDReferenceApi.getObjectByOwnerAndType(matColor, "Playermat")
        if playermat then
          -- remove unneccessary objects
          local sharesBags = tableSetupData.sharedBagArea and (matColor == "White" or matColor == "Orange")
          for name, objData in pairs(spawnData) do
            if sharesBags and SHARED_BAGS_DATA.objects[name] then
              local indexName = GUID_INDEX_MAP[name] or string.gsub(name, " ", "")
              GUIDReferenceApi.removeObjectByOwnerAndType(matColor, indexName)
            end
          end

          CoroutineLib.yieldFrames(5)

          PlayermatApi.moveAndRotate(matColor, transformData.position, transformData.rotation.y)

          CoroutineLib.yieldFrames(5)

          -- spawn missing objects
          spawnPlayermatObjects(matColor, playermat, transformData, spawnData)
        else
          spawnPlayermat(matColor, transformData)
        end
        CoroutineLib.yieldFrames(5)
      end
    end

    -- actual movement of mythos objects
    for objectName, defaultData in pairs(MYTHOS_DEFAULT_TRANSFORMS) do
      local transformData = tableSetupData.transforms[objectName] or defaultData
      if transformData then
        local mainObject = GUIDReferenceApi.getObjectByOwnerAndType("Mythos", objectName)
        if mainObject then
          moveObjectWithObjectsOnTop(mainObject, transformData.position, transformData.rotation.y)
          CoroutineLib.yieldFrames(2)
          if objectName == "TokenArranger" then
            TokenArrangerApi.deleteCopiedTokens()
          end
        end
      end
    end

    -- if the new layout introduces a shared bag area, spawn it
    if tableSetupData.sharedBagArea and (oldSetupName == nil or not TABLE_SETUP_DATA[oldSetupName].sharedBagArea) then
      spawnSharedBagArea()
    end
  end

  CoroutineLib.start(tableSetupCoroutine)
end

function moveObjectWithObjectsOnTop(mainObject, position, rotationY, positionOffset)
  -- get current transform data
  local currentPos = mainObject.getPosition()
  local currentRotY = mainObject.getRotation().y

  -- use current values if undefined
  position = position or currentPos
  rotationY = rotationY or currentRotY

  if positionOffset then
    position = Vector(position) + Vector(positionOffset)
  end

  local movedObjects = {}
  local function moveAndRotateObject(obj)
    local relativePos = obj.getPosition() - currentPos
    obj.setPosition(position + relativePos:rotateOver("y", rotationY - currentRotY))

    local objRot = obj.getRotation()
    local relativeRotY = objRot.y - currentRotY
    obj.setRotation({ objRot.x, rotationY + relativeRotY, objRot.z })

    movedObjects[obj] = true
  end

  -- get objects on the object
  for _, obj in ipairs(SearchLib.onObject(mainObject, "isInteractable")) do
    if not movedObjects[obj] then
      -- make sure object isn't owned by a mat
      local owner = GUIDReferenceApi.getOwnerOfObject(obj)
      if owner == "Mythos" then
        moveAndRotateObject(obj)
      end
    end
  end

  -- move main object (if it wasn't moved yet)
  if not movedObjects[mainObject] then
    moveAndRotateObject(mainObject)
  end
end

-- sets the option panel to the correct state (corresponding to 'optionPanel')
function updateOptionPanelState()
  for id, optionValue in pairs(optionPanel) do
    if id == "uiLanguage" and type(optionValue) == "string" then
      UI.setAttribute(id, "value", returnLanguageId(optionValue) - 1)
    elseif DROPDOWN_DATA[id] and type(optionValue) == "string" then
      UI.setAttribute(id, "value", getDropdownOptionIndex(id, optionValue) - 1)
    elseif id == "playAreaConnectionColor" then
      UI.setAttribute(id, "color", ColorLib.colorToHex(Color(optionValue)))
    elseif (type(optionValue) == "boolean" and optionValue)
        or (type(optionValue) == "string" and optionValue)
        or (type(optionValue) == "table" and #optionValue ~= 0) then
      UI.setAttribute(id, "image", "option_on")
    else
      UI.setAttribute(id, "image", "option_off")
    end
  end
end

-- handles the applying of option selections and calls the respective functions based on the id
---@param id string ID of the option that was selected or deselected
---@param state boolean|any State of the option (true = enabled)
function applyOptionPanelChange(id, state)
  optionPanel[id] = state

  -- option: Snap tags
  if id == "useSnapTags" then
    PlayermatApi.setLimitSnapsByType(state, "All")

    -- option: Draw 1 button
  elseif id == "showDrawButton" then
    PlayermatApi.showDrawButton(state, "All")

    -- option: Use class texture
  elseif id == "useClassTexture" then
    PlayermatApi.useClassTexture(state, "All")

    -- option: Clickable clue counters
  elseif id == "useClueClickers" then
    -- a bit hacky, but we're using the delay to control whether the counter is spawned / removed before or after
    Wait.frames(function() spawnOrRemoveHelperForPlayermats("Clickable Clue Counter", state) end, state and 0 or 20)
    Wait.frames(function() PlayermatApi.clickableClues(state, "All") end, 10)

    -- option: Enable card helpers
  elseif id == "enableCardHelpers" then
    toggleCardHelpers(state)

    -- option: Make damage / horror clickable // Show '1' on damage / horror
  elseif id == "makeDamageHorrorClickable" or id == "showOneDamageHorror" then
    for _, obj in ipairs(getObjects()) do
      local memo = obj.getMemo()
      if memo == "damage" or memo == "horror" then
        callFunctionIfItExists(obj, "updateLabel")
      end
    end

    -- option: Play area connection drawing
  elseif id == "playAreaConnections" then
    PlayAreaApi.setConnectionDrawState(state)

    -- option: Play area connection color
  elseif id == "playAreaConnectionColor" then
    PlayAreaApi.setConnectionColor(state)
    UI.setAttribute(id, "color", ColorLib.colorToHex(Color(state)))

    -- option: Play area snap tags
  elseif id == "playAreaSnapTags" then
    PlayAreaApi.setLimitSnapsByType(state)

    -- option: Show hand helper for each player
  elseif id == "showHandHelper" then
    spawnOrRemoveHelperForPlayermats("Hand Helper", state)

    -- option: Show search assistant for each player
  elseif id == "showSearchAssistant" then
    spawnOrRemoveHelperForPlayermats("Search Assistant", state)

    -- option: Show attachment helper
  elseif id == "showAttachmentHelper" then
    spawnOrRemoveHelper(state, "Attachment Helper", { -62, 1.4, 0 })

    -- option: Show CYOA campaign guides
  elseif id == "showCYOA" then
    spawnOrRemoveHelper(state, "CYOA Campaign Guides", { 39, 1.3, -20 })

    -- option: Show displacement tool
  elseif id == "showDisplacementTool" then
    spawnOrRemoveHelper(state, "Displacement Tool", { -68, 1.53, 57 })

    -- shortcut: Remove the tour
  elseif id == "skipTour" then
    if state then removeTourStarter() end

    -- this will only be called by the "loadOptionPanelState" function
  elseif id == "tableSetup" then
    updateTableSetup(state, nil)
  end
end

function removeTourStarter()
  local tourStarter = GUIDReferenceApi.getObjectByOwnerAndType("Mythos", "TourStarter")
  if tourStarter then
    tourStarter.destruct()
  end
end

function maybeRemoveTourStarter()
  for _, player in ipairs(Player.getPlayers()) do
    if player.host then
      local steamName = string.gsub(player.steam_name, "%s+", "")
      local options = OPTION_PRESETS[steamName]
      if options and options.skipTour then
        removeTourStarter()
      end
      return
    end
  end
end

-- spawns or removes a helper object for all playermats
---@param helperName string Name of the helper object
---@param state boolean Contains the state of the option: true = spawn it, false = remove it
function spawnOrRemoveHelperForPlayermats(helperName, state)
  for color, data in pairs(PlayermatApi.getHelperSpawnData("All", helperName)) do
    spawnOrRemoveHelper(state, helperName, data.position, data.rotation, color)
  end

  -- also spawn/remove the search assistant for the encounter deck
  if helperName == "Search Assistant" then
    local MythosArea = GUIDReferenceApi.getObjectByOwnerAndType("Mythos", "MythosArea")
    local pos = MythosArea.positionToWorld(Vector(0.880, 0.1, 0.868))
    local rot = MythosArea.getRotation()
    spawnOrRemoveHelper(state, "Encounter Search Assistant", pos, rot, "Mythos")
  end
end

-- handler for spawn / remove functions of helper objects
---@param state boolean Contains the state of the option: true = spawn it, false = remove it
---@param name string Name of the helper object
---@param position tts__Vector Position of the object (where it will spawn)
---@param rotation? tts__Vector Rotation of the object for spawning (default: {0, 270, 0})
---@param owner? string Owner of the object (defaults to "Mythos")
---@return string|nil GUID GUID of the spawnedObj (or nil if object was removed)
function spawnOrRemoveHelper(state, name, position, rotation, owner)
  local spawnedGUID
  if state then
    local pingPlayer = Player.getPlayers()[1]
    if pingPlayer.color ~= "Grey" then
      pingPlayer.pingTable(position)
    end
    spawnedGUID = spawnHelperObject(name, position, rotation).getGUID()
  else
    removeHelperObject(name)
  end

  -- update the index (it's intended that 'spawnedGUID' is nil when removing the object)
  local cleanName = name:gsub("%s+", "")
  GUIDReferenceApi.editIndex(owner or "Mythos", cleanName, spawnedGUID)
end

-- copies the specified tool (by name) from the option panel source bag
---@param name string Name of the object that should be copied
---@param position tts__Vector Desired position of the object
---@param rotation? tts__Vector Desired rotation of the object (defaults to object's rotation)
function spawnHelperObject(name, position, rotation)
  local sourceBag = GUIDReferenceApi.getObjectByOwnerAndType("Mythos", "ObjectSourceBag")

  -- error handling for missing sourceBag
  if not sourceBag then
    broadcastToAll("Option panel source bag could not be found!", "Red")
    return
  end

  local spawnTable = { position = position }

  -- only overrride rotation if there is one provided (object's rotation used instead)
  if rotation then
    spawnTable.rotation = rotation
  end

  for _, objData in ipairs(sourceBag.getData().ContainedObjects) do
    if objData["Nickname"] == name then
      objData["Locked"] = true
      spawnTable.data = objData
      return spawnObjectData(spawnTable)
    end
  end
end

-- removes the specified tool (by name)
---@param name string Object that should be removed
function removeHelperObject(name)
  local cleanName = name:gsub("%s+", "")
  for _, obj in pairs(GUIDReferenceApi.getObjectsByType(cleanName)) do
    obj.destruct()
  end
end

-- loads saved options
---@param newOptions table Contains the new state for the option panel
---@params logOptions? boolean True if options should get logged
function loadOptionPanelState(newOptions, logOptions)
  if logOptions then
    log("Changed the following options:")
  end

  -- separately load Navigation Overlay settings
  if newOptions.NavigationOverlay then
    NavigationOverlayApi.loadData(newOptions.NavigationOverlay)
    newOptions.NavigationOverlay = nil
    if logOptions then
      log("Updated the Navigation Overlay settings")
    end
  end

  for id, state in pairs(newOptions) do
    if optionPanel[id] ~= state then
      applyOptionPanelChange(id, state)

      if logOptions then
        log(id .. ": " .. tostring(state))
      end
    end
  end

  -- update XML UI state
  updateOptionPanelState()
end

-- loads the default options
function onClick_defaultSettings()
  -- clean reset of variables
  optionPanel = {
    uiLanguage                = "en",
    changePlayAreaImage       = false,
    enableCardHelpers         = true,
    makeDamageHorrorClickable = true,
    playAreaConnectionColor   = { a = 1, b = 0.4, g = 0.4, r = 0.4 },
    playAreaConnections       = true,
    playAreaSnapTags          = true,
    showAttachmentHelper      = false,
    showCYOA                  = false,
    showDisplacementTool      = false,
    showDrawButton            = false,
    showHandHelper            = false,
    showOneDamageHorror       = false,
    showSearchAssistant       = false,
    showTitleSplash           = true,
    showTokenSplash           = false,
    tableSetup                = "Classic (4P)",
    tokenArrangerOdds         = "No Odds",
    useClassTexture           = true,
    useClueClickers           = false,
    useResourceCounters       = "disabled",
    useSnapTags               = true
  }

  -- applying changes
  for id, state in pairs(optionPanel) do
    applyOptionPanelChange(id, state)
  end

  -- update UI
  updateOptionPanelState()
end

-- splash scenario title on setup
function titleSplash(scenarioName)
  if optionPanel['showTitleSplash'] then
    -- if there's any ongoing title being displayed, hide it and cancel the waiting function
    if waitIds["hideTitleSplash"] then
      Wait.stop(waitIds["hideTitleSplash"])
      waitIds["hideTitleSplash"] = nil
      UI.setAttribute("title_splash", "active", false)
    end

    -- update the xml
    UI.setAttributes("title_splash_text", {
      font = i18n.getFont(),
      text = scenarioName
    })

    -- display scenario name and set a 4 seconds (2 seconds animation and 2 seconds on screen)
    -- wait timer to hide the scenario name
    UI.show("title_splash")
    waitIds["hideTitleSplash"] = Wait.time(function()
      UI.hide("title_splash")
      waitIds["hideTitleSplash"] = nil
    end, 4)

    SoundCubeApi.playSoundByName("Deep Bell")
  end
end

-- turns off all card helpers, if they are on
function toggleCardHelpers(state)
  for _, obj in ipairs(getObjectsWithTag("CardWithHelper")) do
    local owner = GUIDReferenceApi.getOwnerOfObject(obj)
    if owner == "Mythos" then return end

    local mat               = GUIDReferenceApi.getObjectByOwnerAndType(owner, "Playermat")
    local relPos            = mat.positionToLocal(obj.getPosition())
    local metadata          = JSON.decode(obj.getGMNotes()) or {}
    local cardType          = metadata.type

    local isInAssetArea     = relPos.x > -1.5 and relPos.z > -0.3
    local isInThreatArea    = relPos.x > -1.5 and relPos.z < -0.3

    local hasAssetAreaType  = cardType == "Asset" or cardType == "Investigator" or cardType == "Event"
    local hasThreatAreaType = cardType == "Skill"

    if (isInAssetArea and hasAssetAreaType) or (isInThreatArea and hasThreatAreaType) then
      obj.call("setHelperState", state)
    end
  end
end

-- toggles the hand visibility of a hand for a specific player
function handVisibilityToggle(params)
  local playerColor = params.playerColor
  local handColor = params.handColor

  -- collect data for message
  local state, preposition

  -- modify data table
  if not handVisibility[handColor] then
    handVisibility[handColor] = { playerColor, handColor }
    state, preposition = "Showing", "to"
  elseif removeValueFromTable(handVisibility[handColor], playerColor) then
    -- something was removed, maybe clear the table
    if #handVisibility[handColor] == 1 and handVisibility[handColor][1] == handColor then
      handVisibility[handColor] = nil
    end
    state, preposition = "Hiding", "from"
  else
    -- add the new color as viewer
    table.insert(handVisibility[handColor], playerColor)
    state, preposition = "Showing", "to"
  end

  local sourceName = getColoredName(handColor)
  local targetName = getColoredName(playerColor)
  broadcastToAll(state .. " " .. sourceName .. "'s hand " .. preposition .. " " .. targetName .. ".")
  updateHandVisibility()
end

function updateHandVisibility()
  -- update the global setting
  if not next(handVisibility) then
    Hands.hiding = 1
  else
    Hands.hiding = 3
  end

  -- update visibility of cards already in hands (delay seems to be necessary)
  Wait.frames(function()
    for _, handColor in ipairs(Player.getAvailableColors()) do
      for _, handObj in ipairs(Player[handColor].getHandObjects()) do
        applyHidingToCard(handObj, handColor)
      end
    end
  end, 1)
end

-- maybe hide card from non-allowed players
---@param card tts__Object Card to maybe hide
---@param handColor? string Color of the hand this card is in
function applyHidingToCard(card, handColor)
  if next(handVisibility) then
    local viewers = { handColor }
    if handColor and handVisibility[handColor] then
      viewers = handVisibility[handColor]
    end

    local hiddenFrom = Player.getColors()
    for _, viewer in ipairs(viewers) do
      removeValueFromTable(hiddenFrom, viewer)
    end
    card.setHiddenFrom(hiddenFrom)
  else
    card.setHiddenFrom({})
  end
end

-- loads the visibility of the Bless/Curse Manager XML from the internal variable
function updateBlurseVisibility()
  local count = 1
  for playerColor, state in pairs(blurseVisibility) do
    Wait.frames(function() changeWindowVisibilityForColor(playerColor, "blessCurseManager", state) end, count)
    count = count + 3
  end
end

---------------------------------------------------------
-- Update notification related functionality
---------------------------------------------------------

-- grabs the latest mod version and release notes from GitHub (called onLoad())
function getModVersion()
  WebRequest.get(SOURCE_REPO .. 'modversion.json', compareVersion)
end

-- compares the modversion with GitHub and possibly shows the update notification
function compareVersion(request)
  if request.is_error then
    log(request.error)
    return
  end

  -- global variable to make it accessible for other functions
  modMeta = JSON.decode(request.text)

  -- maybe update SOURCE_REPO to specific version
  if modMeta["setSpecificDownloadVersion"] then
    local versionTable = modMeta["setSpecificDownloadVersion"][1]
    if versionTable[MOD_VERSION] then
      SOURCE_REPO = "https://github.com/Chr1Z93/SCED-downloads/releases/download/" .. versionTable[MOD_VERSION] .. "/"
      log("Using download repo version: " .. versionTable[MOD_VERSION])
    end
  end

  -- stop here if on latest or newer version
  if convertVersionToNumber(MOD_VERSION) >= convertVersionToNumber(modMeta["latestVersion"]) then return end

  -- stop here if "don't show again" was clicked for this version before
  if acknowledgedUpgradeVersions[modMeta["latestVersion"]] then return end

  updateNotificationLoading()

  -- delay to avoid lagging during onLoad()
  Wait.time(function() UI.show("FinnIcon") end, 1)
end

-- converts a version number to a string
---@param version string Version number, separated by dots (e.g. 3.3.1)
function convertVersionToNumber(version)
  local major, minor, patch = string.match(version, "(%d+)%.(%d+)%.(%d+)")
  return major * 100 + minor * 10 + patch
end

-- updates the XML update notification based on the mod metadata
function updateNotificationLoading()
  -- grab data
  local highlights = modMeta["releaseHighlights"]

  -- concatenate the release highlights
  local highlightText = "• " .. highlights[1]
  for i, entry in pairs(highlights) do
    if i ~= 1 then
      highlightText = highlightText .. "\n• " .. entry
    end
  end

  -- update the XML UI
  UI.setValue("notificationHeader", "New version available: " .. modMeta["latestVersion"])
  UI.setValue("releaseHighlightText", highlightText)
  UI.setAttribute("highlightRow", "preferredHeight", 20 * #highlights)
  UI.setAttribute("updateNotification", "height", 20 * #highlights + 125)
end

-- close / don't show again buttons on the update notification
function onClick_notification(_, parameter)
  if parameter == "dontShowAgain" then
    -- this variable tracks if "don't show again" was pressed for a version
    acknowledgedUpgradeVersions[modMeta["latestVersion"]] = true
  end
  UI.hide("FinnIcon")
  UI.hide("updateNotification")
end

---------------------------------------------------------
-- Token Manager
---------------------------------------------------------

function TokenManager.initialize()
  TokenManager.generateOffsets(12)
  TokenManager.initTokenTemplates()
end

-- Generates the offsets for tokens on a card (clues on locations are different and have their own function)
---@param maxTokens number Maximum amount of tokens on a card
function TokenManager.generateOffsets(maxTokens)
  tokenOffsets = {
    [1] = { Vector(0, 0.1, -0.2) },
    [2] = { Vector(0.4, 0.1, -0.2), Vector(-0.4, 0.1, -0.2) },
    [3] = { Vector(0, 0.1, -0.9), Vector(0.4, 0.1, -0.2), Vector(-0.4, 0.1, -0.2) },
    [4] = { Vector(0.4, 0.1, -0.9), Vector(-0.4, 0.1, -0.9), Vector(0.4, 0.1, -0.2), Vector(-0.4, 0.1, -0.2) }
  }

  -- generate offsets for numTokens > 4 dynamically
  for numTokens = 5, maxTokens do
    local offsets = {}
    local rows = math.min(4, math.ceil(numTokens / 3))
    local tokensPlaced = 0
    for row = 1, rows do
      local y = 0.1
      local z = -0.9 + (row - 1) * 0.7
      local tokensInRow = math.min(3, numTokens - tokensPlaced)
      for col = 1, tokensInRow do
        local x = 0
        if tokensInRow == 2 then
          x = col == 1 and -0.4 or 0.4
        elseif tokensInRow == 3 then
          x = (col - 2) * 0.7
        end
        table.insert(offsets, Vector(x, y, z))
        tokensPlaced = tokensPlaced + 1
      end
    end
    tokenOffsets[numTokens] = offsets
  end
  return tokenOffsets
end

-- Spawns tokens for the card. This function is built to just throw a card at it and let it do
-- the work once a card has hit an area where it might spawn tokens. It will check to see if
-- the card has already spawned, find appropriate data from either the uses metadata or the Data
-- Helper, and spawn the tokens.
function TokenManager.spawnForCard(params)
  if TokenSpawnTrackerApi.hasSpawnedTokens(params.card.getGUID()) then return end
  local metadata = JSON.decode(params.card.getGMNotes())
  if metadata ~= nil then
    TokenManager.spawnTokensFromUses(params)
  end
end

-- Spawns a set of tokens on the given card.
function TokenManager.spawnTokenGroup(params)
  if params.tokenType == "damage" or params.tokenType == "horror" then
    TokenManager.spawnCounterToken(params)
  elseif shouldSpawnResourceCounter(params) then
    TokenManager.spawnResourceCounterToken(params)
  else
    TokenManager.spawnMultipleTokens(params)
  end
end

function shouldSpawnResourceCounter(params)
  local matColor   = params.matColor
  local replenish  = params.replenish
  local tokenCount = params.tokenCount
  local tokenType  = params.tokenType

  if tokenType ~= "resource" then return false end

  local matSetting = "Global"
  if matColor and matColor ~= "Mythos" then
    matSetting = PlayermatApi.getResourceCounterOption(matColor)
  end

  if matSetting == "Global" then
    if optionPanel["useResourceCounters"] == "enabled" then
      return true
    elseif optionPanel["useResourceCounters"] == "custom" then
      -- spawn a resource counter for cards with "0 uses" or small amount of replenshing tokens
      if tokenCount == 0 or (replenish and tokenCount < 3) then
        return true
      end
    end
  end

  if matSetting == "Enabled" then
    return true
  elseif matSetting == "Chef's Selection" then
    -- spawn a resource counter for cards with "0 uses" or small amount of replenshing tokens
    if tokenCount == 0 or (replenish and tokenCount < 3) then
      return true
    end
  end
  return false
end

-- Spawns a single counter token and sets the value to tokenValue. Used for damage and horror tokens.
function TokenManager.spawnCounterToken(params)
  TokenManager.spawnToken({
    position    = params.card.positionToWorld(tokenOffsets[1][1] + Vector(0, 0, params.shiftDown)),
    tokenType   = params.tokenType,
    rotation    = params.card.getRotation(),
    scriptstate = params.tokenValue or params.tokenCount
  })
end

-- Spawns a single resource counter token and sets the value to tokenValue.
function TokenManager.spawnResourceCounterToken(params)
  local card = params.card
  local modifier = card.is_face_down and -1 or 1
  TokenManager.spawnToken({
    position    = card.positionToWorld(card.positionToLocal(card.getPosition()) + Vector(0, modifier * 0.2, -0.5)),
    tokenType   = "resourceCounter",
    rotation    = card.getRotation(),
    scriptstate = params.tokenCount or params.tokenValue
  })
end

-- Spawns a number of tokens
function TokenManager.spawnMultipleTokens(params)
  local card       = params.card
  local tokenType  = params.tokenType
  local tokenCount = params.tokenCount
  local shiftDown  = params.shiftDown
  local subType    = params.subType
  local temporary  = params.temporary
  local matColor   = params.matColor

  if tokenCount < 1 then return end

  -- attempt to get matColor dynamically
  matColor = matColor or GUIDReferenceApi.getOwnerOfObject(params.card)
  if not matColor or matColor == "Mythos" then matColor = nil end

  -- make sure tokens spawn correctly on rotated cards respective to the mat below
  local referenceRotationY = card.getRotation().y
  if matColor then
    referenceRotationY = PlayermatApi.returnRotation(matColor).y
  end

  -- get the card's center position in the world
  local cardWorldPosition = card.getPosition()

  local offsets = {}
  if tokenType == "clue" then
    offsets = TokenManager.buildClueOffsets(card, tokenCount)
  else
    if tokenCount > 12 then
      printToAll("Attempting to spawn " .. tokenCount .. " tokens. Spawning clickable counter instead.")
      TokenManager.spawnResourceCounterToken(params)
      return
    end

    for i = 1, tokenCount do
      local localOffset = Vector(tokenOffsets[tokenCount][i])

      -- if spawning action tokens, increase offsets slightly since they are larger
      if tokenType == "universalActionAbility" then
        localOffset = localOffset * Vector(1.2, 1, 1.2)
      end

      local worldOffset = localOffset:rotateOver("y", referenceRotationY)
      offsets[i] = cardWorldPosition + worldOffset

      -- make sure tokens on face down cards spawn on the "up" side
      if card.is_face_down then
        offsets[i] = offsets[i] + Vector(0, 0.3, 0)
      end
    end
  end

  if shiftDown ~= nil then
    -- get a vector for the shifting (downwards local to reference rotation)
    local shiftDownVector = Vector(0, 0, shiftDown):rotateOver("y", referenceRotationY)
    for i, baseOffset in ipairs(offsets) do
      offsets[i] = baseOffset + shiftDownVector
    end
  end

  if offsets == nil then
    error("couldn't find offsets for " .. tokenCount .. ' tokens')
    return
  end

  -- if a special resource exists, spawn it directly
  if RESOURCE_STATES[string.lower(subType or "")] then
    tokenType = string.lower(subType)
  end

  -- special handling for some tokens like action/ability tokens
  local callbackName = nil
  local callbackParams = nil
  if tokenType == "universalActionAbility" then
    matColor = matColor or PlayermatApi.getMatColorByPosition(card.getPosition())
    local activeInvestigatorData = PlayermatApi.getActiveInvestigatorData(matColor)
    callbackName = "updateUniversalActionAbilityToken"
    callbackParams = {
      class  = activeInvestigatorData.class,
      symbol = subType
    }
  end

  for i = 1, tokenCount do
    TokenManager.spawnToken({
      position       = offsets[i],
      tokenType      = tokenType,
      rotation       = Vector(0, referenceRotationY, 0),
      callbackName   = callbackName,
      callbackParams = callbackParams,
      addTag         = temporary and "Temporary" or nil
    })
  end
end

-- Spawns a single token at the given global position by copying it from the template bag.
function TokenManager.spawnToken(params)
  local rotation       = params.rotation
  local tokenType      = params.tokenType
  local callbackName   = params.callbackName
  local callbackParams = params.callbackParams
  local scriptstate    = params.scriptstate
  local addTag         = params.addTag
  local spawnData      = { position = params.position }

  -- maybe set callback function
  if callbackName then
    if type(_G[callbackName]) ~= "function" then
      error("Callback function " .. callbackName .. " does not exist")
      return
    else
      spawnData.callback_function = function(obj) _G[callbackName](obj, callbackParams) end
    end
  end

  -- get data for token type
  local loadTokenType = tokenType
  if tokenType == "clue" or tokenType == "doom" then
    loadTokenType = "clueDoom"
  end

  local tokenTemplate = TableLib.copy(tokenTemplates[loadTokenType])
  if tokenTemplate == nil then
    error("Unknown token type '" .. loadTokenType .. "'")
    return
  end

  -- remove nickname for clue / doom tokens since they are double-sided
  if loadTokenType == "clueDoom" then
    tokenTemplate.Nickname = ""
  end

  spawnData.data = tokenTemplate

  -- maybe directly update the script state of the token
  if scriptstate then
    spawnData.data["LuaScriptState"] = tostring(scriptstate)
  end

  -- maybe update tags
  if addTag then
    spawnData.data["Tags"] = spawnData.data["Tags"] or {}
    table.insert(spawnData.data["Tags"], addTag)
  end

  -- get rotation for the token
  -- Take ONLY the Y-value for rotation, so we don't flip the token coming out of the bag
  local rot = Vector(tokenTemplate.Transform.rotX, 270, tokenTemplate.Transform.rotZ)
  if rotation ~= nil then
    rot.y = rotation.y
  end
  if tokenType == "doom" then
    rot.z = 180
  end

  spawnData.rotation = rot

  if loadTokenType == "clueDoom" then
    VictoryDisplayApi.update()
  end

  return spawnObjectData(spawnData)
end

-- Checks a card for metadata to maybe replenish it
function TokenManager.maybeReplenishCard(params)
  for _, useInfo in ipairs(params.uses) do
    if useInfo.count and useInfo.replenish then
      TokenManager.replenishTokens(params.card, useInfo)
    end
  end
end

function TokenManager.initTokenTemplates()
  tokenTemplates = {}
  local tokenSource = GUIDReferenceApi.getObjectByOwnerAndType("Mythos", "TokenSource")
  for _, tokenTemplate in ipairs(tokenSource.getData().ContainedObjects) do
    tokenTemplates[tokenTemplate.Memo] = tokenTemplate
  end

  if tokenTemplates["resource"] ~= nil then
    -- add templates for the resource token states
    for subType, subTypeStateId in pairs(RESOURCE_STATES) do
      if subTypeStateId ~= 1 then
        tokenTemplates[subType] = TokenManager.getTemplateForState(subTypeStateId)
      end
    end
  end
end

-- Spawn tokens for a card based on the uses metadata. This will consider the face up/down state
-- of the card for both locations and standard cards.
---@param params table Parameters
-----@param card tts__Object Card to maybe spawn tokens for
-----@param extraUses? table A table of <use type>=<count> which will modify the number of tokens
---    spawned for that type. e.g. Akachi's playermat should pass "Charge"=1
-----@param spawnReactionToken? boolean Whether there should spawn an additional reaction token (atm only for Michael)
-----@param matColor? string Color of the triggering playermat - White, Orange, Green or Red
function TokenManager.spawnTokensFromUses(params)
  local card               = params.card
  local extraUses          = params.extraUses
  local spawnReactionToken = params.spawnReactionToken
  local matColor           = params.matColor

  local uses               = TokenManager.getUses(card)
  if uses == nil then return end

  card.resting = true

  -- maybe add additional reaction token
  if spawnReactionToken then
    table.insert(uses, {
      count = 1,
      type  = "Reaction",
      token = "universalActionAbility"
    })
  end

  -- go through tokens to spawn
  local tokenCount
  for i, useInfo in ipairs(uses) do
    tokenCount = (useInfo.count or 0) + (useInfo.countPerInvestigator or 0) * PlayAreaApi.getInvestigatorCount()
    if extraUses ~= nil and extraUses[useInfo.type] ~= nil then
      tokenCount = tokenCount + extraUses[useInfo.type]
    end
    -- Shift each spawned group after the first down so they don't pile on each other
    TokenManager.spawnTokenGroup({
      card       = card,
      tokenType  = useInfo.token,
      tokenCount = tokenCount,
      replenish  = useInfo.replenish,
      shiftDown  = (i - 1) * 0.8,
      subType    = useInfo.type,
      matColor   = matColor
    })
  end

  TokenSpawnTrackerApi.markTokensSpawned(card.getGUID())
end

-- Gets the right uses structure for this card, based on metadata and face up/down state
---@param card tts__Object Card to pull the uses from
function TokenManager.getUses(card)
  local metadata = JSON.decode(card.getGMNotes()) or {}
  if metadata.type == "Location" then
    if card.is_face_down and metadata.locationBack ~= nil then
      return metadata.locationBack.uses
    elseif not card.is_face_down and metadata.locationFront ~= nil then
      return metadata.locationFront.uses
    end
  elseif not card.is_face_down then
    return metadata.uses
  end
  return nil
end

-- Dynamically create positions for clues on a card
---@param card tts__Object Card the clues will be placed on
---@param count number How many clues?
---@return table: Array of global positions to spawn the clues at
function TokenManager.buildClueOffsets(card, count)
  -- make sure clues always spawn from left to right
  local modifier = card.is_face_down and 1 or -1

  local cluePositions = {}
  for i = 1, count do
    -- get the set number (1 for clue 1-16, 2 for 17-32 etc.)
    local set = math.floor((i - 1) / 16) + 1

    -- get the local index (always number from 1-16)
    local localIndex = (i - 1) % 16

    -- get row and column for this clue
    local row = math.floor(localIndex / 4) + 1
    local column = localIndex % 4

    -- calculate local position
    local localPos = Vector((-0.825 + 0.55 * column) * modifier, 0, -1.5 + 0.55 * row)

    -- get the global clue position (higher y-position for each set)
    local cluePos = card.positionToWorld(localPos) + Vector(0, 0.03 + 0.103 * (set - 1), 0)

    -- add position to table
    table.insert(cluePositions, cluePos)
  end
  return cluePositions
end

---@param card tts__Object Card object to be replenished
---@param useInfo table The already decoded subtable of metadata.uses (to avoid decoding again)
function TokenManager.replenishTokens(card, useInfo)
  -- get current amount of matching resource tokens on the card
  local clickableResourceCounter = nil
  local foundTokens = 0

  -- we're only searching 80% of the card's area to avoid matching tokens on other cards
  -- (except for clues, since these are on locations and they should never be this close)
  local maybeDeleteThese = {}
  if useInfo.token == "clue" then
    for _, obj in ipairs(SearchLib.onObject(card, "isClue")) do
      foundTokens = foundTokens + math.abs(obj.getQuantity())
      table.insert(maybeDeleteThese, obj)
    end
  elseif useInfo.token == "doom" then
    for _, obj in ipairs(SearchLib.onObject(card, "isDoom", 0.8)) do
      if not obj.hasTag("DoomCounter_ignore") then
        foundTokens = foundTokens + math.abs(obj.getQuantity())
        table.insert(maybeDeleteThese, obj)
      end
    end
  else
    -- search for the token instead if there's no special resource state for it
    local searchType = string.lower(useInfo.type)
    if RESOURCE_STATES[searchType] == nil then
      searchType = useInfo.token
    end

    for _, obj in ipairs(SearchLib.onObject(card, "isTileOrToken", 0.8)) do
      local memo = obj.getMemo()
      if searchType == memo then
        foundTokens = foundTokens + math.abs(obj.getQuantity())
        table.insert(maybeDeleteThese, obj)
      elseif memo == "resourceCounter" then
        foundTokens = obj.getVar("val")
        clickableResourceCounter = obj
        break
      end
    end
  end

  -- this is the theoretical new amount of uses (to be checked below)
  local newCount = foundTokens + useInfo.replenish

  -- if there are already more uses than the replenish amount, keep them
  if foundTokens > useInfo.count then
    newCount = foundTokens
    -- only replenish up until the replenish amount
  elseif newCount > useInfo.count then
    newCount = useInfo.count
  end

  -- update the clickable counter or spawn a group of tokens
  if clickableResourceCounter then
    clickableResourceCounter.call("updateVal", newCount)
  else
    -- delete existing tokens
    for _, obj in ipairs(maybeDeleteThese) do
      obj.destruct()
    end

    -- spawn new token group
    TokenManager.spawnTokenGroup({
      card       = card,
      tokenType  = useInfo.token,
      tokenCount = newCount,
      subType    = useInfo.type,
      matColor   = GUIDReferenceApi.getOwnerOfObject(card)
    })
  end
end

-- adds a use to a card
function TokenManager.addUseToCard(params)
  local card = params.card
  local useType = params.useType
  local additionalCount = params.additionalCount or 1

  -- only allow 1 trigger per 5 frames for the same card
  if lastCard == card then return false end
  lastCard = card
  Wait.frames(function() lastCard = nil end, 5)

  local metadata = JSON.decode(card.getGMNotes()) or {}

  -- get correct data for location
  if metadata.type == "Location" then
    if not card.is_face_down and metadata.locationFront ~= nil then
      metadata = metadata.locationFront
    elseif metadata.locationBack ~= nil then
      metadata = metadata.locationBack
    end

    -- if there are no uses at all, add "empty" uses for fake replenishing (only for clues)
    if metadata.uses == nil then
      metadata.uses = { { token = "clue" } }
    end
  end

  -- if there are no uses at all, add "empty" uses for fake replenishing on other cards for doom only
  if params.useType == "doom" and metadata.uses == nil then
    metadata.uses = { { token = "doom" } }
  end

  local match = false
  for _, useInfo in ipairs(metadata.uses or {}) do
    if useInfo.token == useType then
      -- artificially create replenish data to re-use that existing functionality
      useInfo.count = 999
      useInfo.replenish = additionalCount
      match = true
    else
      -- artificially disable other uses from replenishing
      useInfo.replenish = nil
    end
  end

  -- if matching uses were found, perform the "fake" replenish
  if match then
    TokenManager.maybeReplenishCard({ card = card, uses = metadata.uses })
    return true
  else
    return false
  end
end

-- generates the data to spawn an infinite bag of a specific type of resources
function TokenManager.getDataForInfiniteBag(params)
  local tokenTemplate = tokenTemplates[params.tokenType]
  if tokenTemplate == nil then
    error("Unknown token type '" .. params.tokenType .. "'")
    return
  end

  -- generate and return data for the infinite bag
  local properTypeName = params.tokenType:gsub("^%l", string.upper)
  return {
    Name = "Infinite_Bag",
    Nickname = properTypeName .. " Bag",
    ContainedObjects = { tokenTemplate },
    Transform = {
      posX = params.position.x,
      posY = params.position.y,
      posZ = params.position.z,
      rotX = params.rotation.x,
      rotY = params.rotation.y,
      rotZ = params.rotation.z,
      scaleX = 1,
      scaleY = 1,
      scaleZ = 1
    }
  }
end

-- gets the data for a specific resource token state
function TokenManager.getTemplateForState(subTypeStateId)
  -- create a copy of the resource token (to not modify the source)
  local template = TableLib.copy(tokenTemplates["resource"])
  local subTypeData = template["States"][subTypeStateId]

  -- add states to data
  subTypeData["States"] = template["States"]

  -- add "1" state and remove the current state
  subTypeData["States"][1] = template
  subTypeData["States"][1]["States"] = nil
  subTypeData["States"][subTypeStateId] = nil

  -- update rotation of the main state
  subTypeData["Transform"].rotX = 0
  subTypeData["Transform"].rotY = 0
  subTypeData["Transform"].rotZ = 0

  return subTypeData
end

---------------------------------------------------------
-- Callback functions for token spawning
---------------------------------------------------------

function updateUniversalActionAbilityToken(obj, params)
  obj.call("updateClassAndSymbol", params)
end

---------------------------------------------------------
-- Utility functions
---------------------------------------------------------

-- handles discarding for a list of objects
---@param params table Parameters:
--- objectList table|tts__Object List of objects to discard (or a single object)
--- owner string Owner of the objects (determines trash can)
function discardObjects(params)
  local objectList = params.objectList

  if objectList == nil then return end
  if type(objectList) ~= "table" then
    objectList = { objectList }
  end

  local owner = params.owner or "Mythos"

  local trash = GUIDReferenceApi.getObjectByOwnerAndType(owner, "Trash")
  if trash == nil then return end

  for _, obj in ipairs(objectList) do
    if obj.hasTag("TrashMe") then
      trash.putObject(obj)
      -- don't touch locked objects (like the table etc.) or specific objects (like key tokens)
    elseif not obj.getLock() and not obj.hasTag("DontDiscard") and obj.interactable == true then
      if obj.type == "Card" or obj.type == "Deck" then
        -- reset cards that seal tokens
        if obj.hasTag("CardThatSeals") then
          local func = obj.getVar("resetSealedTokens")
          if func ~= nil then obj.call("resetSealedTokens") end
        end

        -- discard cards to respective discard pile
        local discardPos, discardRot
        if owner ~= "Mythos" and obj.hasTag("PlayerCard") then
          discardPos = PlayermatApi.getDiscardPosition(owner)
          discardRot = PlayermatApi.returnRotation(owner)
        else
          discardPos = MythosAreaApi.getEncounterDiscardPosition()
          discardRot = MythosAreaApi.getEncounterDiscardRotation()
        end

        DeckLib.placeOrMergeIntoDeck(obj, discardPos, discardRot)
      elseif TokenChecker.isChaosToken(obj) then
        -- put chaos tokens back into bag (e.g. Unrelenting)
        returnChaosTokenToBag({ token = obj, fromBag = false })
      else
        if obj.getMemo() == "clueDoom" then
          VictoryDisplayApi.update()
        end
        trash.putObject(obj)
      end
    end
  end
end

-- converts a string to boolean (because TTS is very inconsistent with these in XML)
function convertStringToBoolean(str)
  return str == "True" or str == "true" or str == true
end

-- allows calling a function inside of a table (like the TokenManager)
function callTable(params)
  local keys = params[1] or {}
  local arg = params[2] or nil
  local var = _G
  for _, key in ipairs(keys) do
    var = var[key]
    if type(var) ~= "table" then break end
  end
  if type(var) ~= "function" then
    log("resulting var was not a function " .. table.concat(keys, "->"))
    return
  end
  return var(arg)
end

-- removes a value from a table
---@return boolean: True if something was removed
function removeValueFromTable(t, val)
  for i, v in ipairs(t) do
    if v == val then
      table.remove(t, i)
      return true
    end
  end
  return false
end

-- calls a function on an object if it exists
function callFunctionIfItExists(object, functionName, params)
  if object ~= nil and object.getVar(functionName) then
    return object.call(functionName, params)
  end
end

-- returns the colored steam name, investigator name or color
---@param playerColor string Color of the player
function getColoredName(playerColor)
  local displayName = playerColor
  if playerColor ~= "Grey" and Player[playerColor].steam_name then
    displayName = Player[playerColor].steam_name
  else
    local matColor = PlayermatApi.getMatColor(playerColor)
    local investigatorName = PlayermatApi.getInvestigatorName(matColor)
    if investigatorName ~= "" then
      displayName = investigatorName
    end
  end

  -- add bb-code
  return "[" .. Color.fromString(playerColor):toHex() .. "]" .. displayName .. "[-]"
end

-- constructs the mini id for a given investigator id
function getMiniId(baseId)
  if #baseId < 16 then
    -- use the first 5 characters to exclude suffixes
    return string.match(baseId, ".....") .. "-m"
  else
    -- use the full ID (long -> assume it's from Zoop)
    return baseId .. "-m"
  end
end

function handleTokenAttaching(params)
  local card = params.card
  if card == nil then return end

  local player         = params.player
  local searchResult   = SearchLib.onObject(card, "isTileOrToken", 0.9)
  local cardPos        = card.getPosition()
  local eligibleTokens = {}
  for _, token in ipairs(searchResult) do
    if not token.locked and token.getPosition().y > (cardPos.y + 0.001) then
      table.insert(eligibleTokens, token)
    end
  end
  if #eligibleTokens == 0 then return end

  -- maybe change settings (and save them to restore later)
  if card.is_face_down then
    cardSettings[card]       = {
      hideFacedown = card.hide_when_face_down,
      tooltip      = card.tooltip
    }
    card.hide_when_face_down = false
    card.tooltip             = false
  end

  for _, token in ipairs(eligibleTokens) do
    card.addAttachment(token)
  end

  Wait.condition(
    function() handleTokenDetaching({ card = card }) end,
    function()
      if card ~= nil and player ~= nil and player.seated then
        return card.resting and card.held_by_color ~= player.color
      else
        return true
      end
    end
  )
end

function handleTokenDetaching(params)
  local card = params.card
  if card == nil or next(card.getAttachments()) == nil then return end

  -- restore card settings
  if cardSettings[card] ~= nil then
    card.hide_when_face_down = cardSettings[card]["hideFacedown"]
    card.tooltip             = cardSettings[card]["tooltip"]
    cardSettings[card]       = nil
  end

  local cardPosition = card.getPosition()

  -- remove attachments (move tokens below the card on top)
  local removedTokens = card.removeAttachments()
  for _, token in ipairs(removedTokens) do
    if token.getPosition().y < cardPosition.y then
      local posY = cardPosition.y + 0.05
      token.setPosition(token.getPosition():setAt("y", posY))
    end
  end

  -- trigger playarea connections
  local locked = card.getLock()
  card.setLock(not locked)
  Wait.frames(function() card.setLock(locked) end, 1)

  -- redraw token xml for cards with sealing
  if card.hasTag("CardThatSeals") then
    callFunctionIfItExists(card, "updateStackSize")
  end

  return removedTokens
end

function moveCardWithTokens(params)
  local card     = params.card
  local position = params.position
  local rotation = params.rotation

  stopTokenTransformUpdating(card)
  storeTokenTransform(card)

  if rotation then
    card.setRotation(rotation)
  end

  if position then
    card.use_hands = false
    card.setPositionSmooth(position)
  end

  if #cardTokens[card] == 0 then return end

  -- wait for the card to finish moving, update token position/rotation regularly
  Wait.condition(
    function() stopTokenTransformUpdating(card) end,
    function()
      if card ~= nil and cardTokens[card] ~= nil and #cardTokens[card] ~= 0 then
        updateTokenTransform(card)
        return card.resting and not card.isSmoothMoving()
      end
      return true
    end
  )
end

function storeTokenTransform(card)
  cardTokens[card] = {}
  local cardRot = card.getRotation()
  for _, token in ipairs(SearchLib.onObject(card, "isTileOrToken", 0.95)) do
    if not token.locked then
      -- offset to stop the token from colliding with the card
      local tokenPos = token.getPosition() + Vector(0, 0.05, 0)
      token.setPosition(tokenPos)

      -- store local transform data
      table.insert(cardTokens[card], {
        token = token,
        localPos = card.positionToLocal(tokenPos),
        localRot = token.getRotation() - cardRot
      })
    end
  end
end

function updateTokenTransform(card)
  for _, tokenData in ipairs(cardTokens[card] or {}) do
    if tokenData.token ~= nil then
      tokenData.token.setPosition(card.positionToWorld(tokenData.localPos))
      tokenData.token.setRotation(card.getRotation() + tokenData.localRot)
      tokenData.token.locked = true
    end
  end
end

function stopTokenTransformUpdating(card)
  if cardTokens[card] == nil then return end
  for _, tokenData in ipairs(cardTokens[card] or {}) do
    if tokenData.token ~= nil then
      tokenData.token.locked = false
    end
  end
  cardTokens[card] = nil
  if card ~= nil then
    card.use_hands = true
  end
end

-- readies a card respective to its owner
---@param params table Parameters for the function:
--- card tts__Object Card to ready
--- ownerRotation? tts__Vector Rotation of the owner
--- smooth? boolean Should the card be rotated smoothly?
--- forceReady? boolean True if this card should be readied regardless of "DoNoReady" tag
function maybeReadyCard(params)
  local card          = params.card
  local ownerRotation = params.ownerRotation
  local smooth        = params.smooth
  local forceReady    = params.forceReady

  if not forceReady and (card.getVar("do_not_ready") or card.hasTag("DoNotReady")) then return end

  -- if not provided, get the rotation of the owner
  if not ownerRotation then
    local owner = GUIDReferenceApi.getOwnerOfObject(card)
    if owner == "Mythos" then
      ownerRotation = PlayAreaApi.returnRotation()
    else
      ownerRotation = PlayermatApi.returnRotation(owner)
    end
  end

  local cardRotation = card.getRotation()
  local roundedRotY  = MathLib.round(cardRotation.y)
  local yRotDiff     = roundedRotY - ownerRotation.y

  if yRotDiff < 0 then
    yRotDiff = yRotDiff + 360
  end

  -- rotate cards to the next multiple of 90° towards 0°
  local cardRotY = ownerRotation.y
  if yRotDiff > 90 and yRotDiff <= 180 then
    cardRotY = ownerRotation.y + 90
  elseif yRotDiff > 180 and yRotDiff < 270 then
    cardRotY = ownerRotation.y + 270
  end

  -- optionally use a smooth rotation
  if smooth then
    card.setRotationSmooth(cardRotation:setAt("y", cardRotY))
  else
    card.setRotation(cardRotation:setAt("y", cardRotY))
  end

  -- returns whether the card is now fully readied (and wasn't ready before)
  return (cardRotY == ownerRotation.y) and (roundedRotY ~= ownerRotation.y)
end

-- removes tokens from the provided card/deck
function removeTokensFromObject(params)
  local object = params.object
  if object == nil then return end

  local trash = GUIDReferenceApi.getObjectByOwnerAndType(params.owner, "Trash")

  if object.hasTag("CardThatSeals") then
    callFunctionIfItExists(object, "resetSealedTokens")
  end

  if cardTokens[object] then
    -- check if this card was moved with tokens on it
    for _, tokenData in ipairs(cardTokens[object]) do
      if tokenData.token ~= nil then
        tokenData.token.locked = false
        if TokenChecker.isChaosToken(tokenData.token) then
          returnChaosTokenToBag({ token = tokenData.token, fromBag = false })
        else
          trash.putObject(tokenData.token)
        end
      end
    end
    cardTokens[object] = nil
  else
    -- search area for tokens
    for _, obj in ipairs(SearchLib.onObject(object, "isTileOrToken")) do
      if TokenChecker.isChaosToken(obj) then
        returnChaosTokenToBag({ token = obj, fromBag = false })
      elseif obj.memo ~= nil and
          obj.getLock() == false and
          obj.interactable == true then
        trash.putObject(obj)
      end
    end
  end
end

-- Simple method to check if the given point is in a specified area
---@param point tts__Vector Point to check, only x and z values are relevant
---@param bounds table Defined area to see if the point is within
---@return boolean: True if the point is in the area defined by bounds
function inArea(point, bounds)
  return (point.x < bounds.upperLeft.x
    and point.x > bounds.lowerRight.x
    and point.z < bounds.upperLeft.z
    and point.z > bounds.lowerRight.z)
end
