BAG_OFFSET = Vector(-1, 0.1, 0)
CARD_OFFSET = Vector(-3.5, 0.1, 0)
READING = {
  "Temperance",
  "Justice",
  "Hermit",
  "Hanged Man",
  "Hierophant",
  "Lovers",
  "Chariot",
  "Wheel of Fortune"
}
doubleSize = false

function onLoad()
  self.addContextMenuItem("Chaos", chaos)
  self.addContextMenuItem("Balance", balance)
  self.addContextMenuItem("Choice", choice)
  self.addContextMenuItem("Destiny (Campaign)", destiny)
  self.addContextMenuItem("Accept Your Fate", fate)
  self.addContextMenuItem("Observed", observed)
  self.addContextMenuItem("Damned", damned)
  self.addContextMenuItem("Toggle Large Tarot", enlargeSize)
end

function chaos(color)
  self.shuffle()
  self.takeObject({
    position = self.positionToWorld(BAG_OFFSET + CARD_OFFSET),
    smooth = true,
    callback_function = function(card)
      card.setRotation(self.getRotation())
      if math.random(2) == 2 then
        card.call("rotateSelfAndPreview", color)
      end
    end
  })
end

function balance()
  self.shuffle()
  for i = 1, 2 do
    self.takeObject({
      position = self.positionToWorld(BAG_OFFSET + i * CARD_OFFSET),
      rotation = self.getRotation(),
      smooth = true
    })
  end
end

function choice(color)
  self.shuffle()
  for i = 1, 3 do
    self.takeObject({
      position = self.positionToWorld(BAG_OFFSET + i * CARD_OFFSET),
      rotation = self.getRotation(),
      smooth = true
    })
  end
  broadcastToColor("Choose and reverse two of the cards.", color)
end

function destiny(color)
  self.shuffle()
  for i = 1, 8 do
    self.takeObject({
      position = self.positionToWorld(BAG_OFFSET + i * CARD_OFFSET),
      rotation = self.getRotation(),
      smooth = true
    })
  end
  broadcastToColor("Each card corresponds to one scenario, leftmost is first. Choose and reverse half of the cards (rounded up).", color)
end

function fate(color)
  local i = 0
  for _, tarotName in ipairs(READING) do
    for _, card in ipairs(self.getObjects()) do
      if string.match(card.name, tarotName) ~= nil then
        i = i + 1
        self.takeObject({
          guid = card.guid,
          position = self.positionToWorld(BAG_OFFSET + i * CARD_OFFSET),
          rotation = self.getRotation(),
          smooth = true
        })
        break
      end
    end
  end
  broadcastToColor("Each card corresponds to one scenario, leftmost is first. Choose and reverse half of the cards (rounded up).", color)
end

function observed(color)
  self.shuffle()
  for i = 1, 3 do
    self.takeObject({
      position = self.positionToWorld(BAG_OFFSET + i * CARD_OFFSET),
      rotation = self.getRotation(),
      smooth = true
    })
  end
  broadcastToColor("Choose one of cards to be in upright position; shuffle the rest back into the bag.", color)
end

function damned(color)
  self.shuffle()
  self.takeObject({
    position = self.positionToWorld(BAG_OFFSET + CARD_OFFSET),
    smooth = true,
    callback_function = function(card) card.call("rotateSelfAndPreview", color) end
  })
end

function tryObjectEnter(object)
  local angle = object.alt_view_angle
  angle.y = 0
  object.alt_view_angle = angle
  object.setRotation(self.getRotation())
  object.setScale({1, 1, 1})
  return true
end

function enlargeSize()
  if doubleSize == false then
    doubleSize = true
    CARD_OFFSET.x = CARD_OFFSET.x * 2
  else
    doubleSize = false
    CARD_OFFSET.x = CARD_OFFSET.x / 2
  end
end

function onObjectLeaveContainer(container, object)
  if container == self and doubleSize == true then object.setScale({2, 1, 2}) end
end
