require("core/Constants")
local AllCardsBagApi              = require("playercards/AllCardsBagApi")
local ChaosBagApi                 = require("chaosbag/ChaosBagApi")
local ColorLib                    = require("util/ColorLib")
local CoroutineLib                = require("util/CoroutineLib")
local DeckLib                     = require("util/DeckLib")
local GlobalApi                   = require("Global/GlobalApi")
local GUIDReferenceApi            = require("core/GUIDReferenceApi")
local i18nApi                     = require("Global/i18nApi")
local MathLib                     = require("util/MathLib")
local MythosAreaApi               = require("mythos/MythosAreaApi")
local NavigationOverlayApi        = require("core/NavigationOverlayApi")
local SearchLib                   = require("util/SearchLib")
local TableLib                    = require("util/TableLib")
local TokenManagerApi             = require("tokens/TokenManagerApi")
local TokenSpawnTrackerApi        = require("tokens/TokenSpawnTrackerApi")
local zones                       = require("playermat/Zones")

-- option panel data
local AVAILABLE_OPTIONS           = {
  ["PERSONAL SETTINGS"] = {
    {
      id    = "slotEditing",
      title = "Enable Slot Edit Mode",
      type  = "toggle"
    },
    {
      id    = "handColorSelect",
      title = "Select Hand Color",
      type  = "button"
    },
    {
      id    = "textureSelect",
      title = "Select Playermat Texture",
      type  = "button"
    },
    {
      id    = "visibilitySelect",
      title = "Show/Hide this Hand to me",
      type  = "button"
    },
    {
      id    = "visibilityAll",
      title = "Show/Hide this Hand to all",
      type  = "toggle"
    },
    {
      id      = "showTokenSplash",
      title   = "Show Token Splash Screen",
      type    = "dropdown",
      options = { "Global", "Enabled", "Own Tokens", "Others' Tokens", "Disabled " }
    },
    {
      id    = "exhaustRotation",
      title = "Specify Exhaust Rotation",
      type  = "input"
    },
    {
      id      = "useCustomResourceImages",
      title   = "Use Custom Resource Images",
      type    = "dropdown",
      options = { "Global", "Enabled", "Disabled" }
    },
    {
      id      = "useResourceCounters",
      title   = "Use Resource Counters",
      type    = "dropdown",
      options = { "Global", "Enabled", "Chef's Selection", "Disabled " }
    }
  }
}

-- stores the value for each id
local optionPanelData             = {}
optionPanelData.slotEditing       = false

-- we use this to turn off collision handling until onLoad() is complete
local collisionEnabled            = false
local currentlyEditingSlots       = false

-- for stopping multiple collisions of the same object
local collisionTable              = {}

-- x-Values for discard buttons
local DISCARD_BUTTON_X_START      = -1.365
local DISCARD_BUTTON_X_OFFSET     = 0.455

local SEARCH_AROUND_SELF_X_BUFFER = 8
local SEARCH_AROUND_SELF_Z_BUFFER = 1.75

-- defined areas for object searching
local MAIN_PLAY_AREA              = {
  upperLeft  = { x = 1.98, z = 0.736 },
  lowerRight = { x = -0.79, z = -0.39 }
}
local INVESTIGATOR_AREA           = {
  upperLeft  = { x = -1.084, z = 0.06517 },
  lowerRight = { x = -1.258, z = -0.0805 }
}
local THREAT_AREA                 = {
  upperLeft  = { x = 1.53, z = -0.34 },
  lowerRight = { x = -1.13, z = -0.92 }
}
local DECK_DISCARD_AREA           = {
  upperLeft  = { x = -1.62, z = 0.855 },
  lowerRight = { x = -2.02, z = -0.245 },
  center     = { x = -1.82, y = 0.5, z = 0.305 },
  size       = Vector(0.4, 3, 1.1)
}

-- local positions
local DRAW_DECK_POSITION          = { x = -1.82, y = 0.1, z = 0 }
local DISCARD_PILE_POSITION       = { x = -1.82, y = 0.1, z = 0.61 }
local DRAWN_ENCOUNTER_POSITION    = { x = 1.365, y = 0.5, z = -0.625 }
local tokenSpawnPos               = {
  action = {
    Vector(-0.86, 0, -0.28), -- left of the regular three actions
    Vector(-1.54, 0, -0.28), -- right of the regular three actions
  },
  ability = {
    Vector(-1, 0, 0.118),  -- bottom left corner of the investigator card
    Vector(-1, 0, -0.118), -- top left corner of the investigator card
  }
}

-- used for the buttons on the right side of the playermat
-- starts off with the data for the "Upkeep" button and will then be changed
local buttonParameters            = {
  label          = "Upkeep",
  click_function = "doUpkeep",
  tooltip        = "Right-click to skip resource gain and card draw",
  function_owner = self,
  position       = { x = 1.82, y = 0.15, z = -0.45 },
  scale          = { 0.12, 0.12, 0.12 },
  width          = 1000,
  height         = 280,
  font_size      = 180
}

-- table of texture URLs
local NAME_TO_TEXTURE_URL         = {
  Guardian = "https://steamusercontent-a.akamaihd.net/ugc/2501268517241599869/179119CA88170D9F5C87CD00D267E6F9F397D2F7/",
  Mystic   = "https://steamusercontent-a.akamaihd.net/ugc/2501268517241600113/F6473F92B3435C32A685BB4DC2A88C2504DDAC4F/",
  Neutral  = "https://steamusercontent-a.akamaihd.net/ugc/2462982115659543571/5D778EA4BC682DAE97E8F59A991BCF8CB3979B04/",
  Rogue    = "https://steamusercontent-a.akamaihd.net/ugc/2501268517241600395/00CFAFC13D7B6EACC147D22A40AF9FBBFFAF3136/",
  Seeker   = "https://steamusercontent-a.akamaihd.net/ugc/2501268517241600579/92DEB412D8D3A9C26D1795CEA0335480409C3E4B/",
  Survivor = "https://steamusercontent-a.akamaihd.net/ugc/2501268517241600848/CEB685E9C8A4A3C18A4B677A519B49423B54E886/"
}

-- translation table for slot names to characters for special font
local SLOT_NAME_TO_CHAR           = {
  ["any"]          = "",
  ["Accessory"]    = "C",
  ["Ally"]         = "E",
  ["Arcane"]       = "G",
  ["Blursed"]      = "zy",
  ["Body"]         = "K",
  ["Hand (right)"] = "M",
  ["Hand (left)"]  = "M",
  ["Hand x2"]      = "N",
  ["Head"]         = "_",
  ["Tarot"]        = "A"
}

-- slot symbol for the respective slot (from top left to bottom right) - intentionally global!
slotData                          = {}
local DEFAULT_SLOT_DATA           = {
  -- 1st row
  "any", "any", "any", "Head", "Hand (left)", "Hand (right)", "Ally",

  -- 2nd row
  "any", "any", "Tarot", "Accessory", "Arcane", "Arcane", "Body"
}

local activeInvestigatorData      = {}
luckyPennyEnabled                 = false
local isClassTextureEnabled       = true
local isDrawButtonVisible         = false
local optionPanelVisibility       = ""

-- table of type-object reference pairs of all owned objects
local ownedObjects                = {}
local matColor                    = self.getMemo()

-- continuously updated
local clueCount                   = 0
local doomCount                   = 0

function updateSave()
  optionPanelVisibility = self.UI.getAttribute("optionPanelMain", "visibility") or ""
  self.script_state = JSON.encode({
    activeInvestigatorData = activeInvestigatorData,
    isClassTextureEnabled  = isClassTextureEnabled,
    isDrawButtonVisible    = isDrawButtonVisible,
    isHandShownToAll       = isHandShownToAll,
    optionPanelData        = optionPanelData,
    optionPanelVisibility  = optionPanelVisibility,
    playerColor            = playerColor,
    slotData               = slotData
  })
end

function onLoad(savedData)
  if savedData and savedData ~= "" then
    local loadedData            = JSON.decode(savedData)
    activeInvestigatorData      = loadedData.activeInvestigatorData
    isClassTextureEnabled       = loadedData.isClassTextureEnabled
    isDrawButtonVisible         = loadedData.isDrawButtonVisible
    isHandShownToAll            = loadedData.isHandShownToAll
    optionPanelData             = loadedData.optionPanelData
    optionPanelVisibility       = loadedData.optionPanelVisibility
    playerColor                 = loadedData.playerColor
    slotData                    = loadedData.slotData

    -- make sure that edit mode starts disabled
    optionPanelData.slotEditing = false
  end

  updateMessageColor(playerColor)

  getOwnedObjects()

  -- discard button creation
  makeDrawAreaButton()
  for i = 2, 6 do
    makeDiscardButton(i)
  end

  self.createButton({
    click_function = "drawEncounterCard",
    function_owner = self,
    position = { -1.84, 0, -0.65 },
    rotation = { 0, 80, 0 },
    width = 265,
    height = 190
  })

  self.createButton({
    click_function = "drawChaosTokenButton",
    function_owner = self,
    position = { 1.85, 0, -0.74 },
    rotation = { 0, -45, 0 },
    width = 135,
    height = 135
  })

  -- Upkeep button: can use the default parameters for this
  self.createButton(buttonParameters)

  -- Discard 1 button: modified default data
  buttonParameters.label = "Discard 1"
  buttonParameters.click_function = "doDiscardOne"
  buttonParameters.tooltip = "Discard one random card from hand (hidden cards are excluded)."
  buttonParameters.position.z = 0.92
  self.createButton(buttonParameters)

  showDrawButton()
  createXML()
  Wait.time(function() collisionEnabled = true end, 0.1)

  -- make sure the casts (for each playermat) are not in the same frame
  local startDelay = 0
  if matColor == "Orange" then
    startDelay = 0.5
  elseif matColor == "Green" then
    startDelay = 1
  elseif matColor == "Red" then
    startDelay = 1.5
  end
  Wait.time(function()
    Wait.time(searchForClueDoom, 2, -1)
  end, startDelay)
end

-- get object references to owned objects
function getOwnedObjects()
  ownedObjects = GUIDReferenceApi.getObjectsByOwner(matColor)
end

---------------------------------------------------------
-- utility functions
---------------------------------------------------------

-- finds all objects on the playermat and associated set aside zone.
function searchAroundSelf(filter)
  local scale             = self.getScale()
  local bounds            = self.getBoundsNormalized()

  -- Increase the width to cover the set aside zone (height needs to account for cards "below" the playermat)
  local size              = Vector(bounds.size.x + SEARCH_AROUND_SELF_X_BUFFER, 3,
    bounds.size.z + SEARCH_AROUND_SELF_Z_BUFFER)

  -- 'setAsideDirection' accounts for the set aside zone being on the left or right,
  -- depending on the table position of the playermat
  local setAsideDirection = bounds.center.z > 0 and 1 or -1

  -- Since the cast is centered on the position, shift left or right to keep
  -- the non-set aside edge of the cast at the edge of the playermat
  local localCenter       = self.positionToLocal(bounds.center)
  localCenter.x           = localCenter.x + setAsideDirection * SEARCH_AROUND_SELF_X_BUFFER / 2 / scale.x
  localCenter.z           = localCenter.z - SEARCH_AROUND_SELF_Z_BUFFER / 2 / scale.z

  -- Perform the search
  local pos               = self.positionToWorld(localCenter) + Vector(0, 1, 0)
  local rot               = self.getRotation()
  local objectList        = SearchLib.inArea(pos, rot, size, filter)

  -- also search on playermat extensions
  local extensions        = getObjectsWithAllTags({ "PlayermatExtension", matColor })

  if #extensions ~= 0 then
    -- make a map to quickly check if an object is already part of the search
    local objectListMap = TableLib.makeMap(objectList)
    for _, extension in ipairs(extensions) do
      for _, obj in ipairs(SearchLib.onObject(extension, filter)) do
        if not objectListMap[obj] then
          table.insert(objectList, obj)

          -- Temporary tag for scripts to detect whether an object in this list is on an extension
          obj.addTag("onExtension")
          Wait.frames(function() if obj ~= nil then obj.removeTag("onExtension") end end, 5)
        end
      end
    end
  end
  return objectList
end

-- updates the internal "messageColor" which is used for print/broadcast statements if no player is seated
---@param clickedByColor? string Colorstring of player who clicked a button
function updateMessageColor(clickedByColor)
  if Player[playerColor].seated then
    messageColor = playerColor
  elseif clickedByColor and Player[clickedByColor].seated then
    messageColor = clickedByColor
  else
    messageColor = Player.getPlayers()[1].color
  end
end

function getMessageColor()
  return messageColor
end

function moveAndRotateSelf(params)
  local position = params.position
  local rotationY = params.rotationY
  local positionOffset = params.positionOffset

  -- get current transform data
  local currentMatPos = self.getPosition()
  local currentMatRotY = self.getRotation().y

  -- use current values if undefined
  position = Vector(position or currentMatPos)
  rotationY = rotationY or currentMatRotY

  if positionOffset then
    position = Vector(position) + Vector(positionOffset)
  end

  local movedObjects = {}
  local function moveAndRotateObject(obj)
    local relativePos = obj.getPosition() - currentMatPos
    obj.setPosition(position + relativePos:rotateOver("y", rotationY - currentMatRotY))

    if obj.type == "Hand" then
      obj.setRotation({ 0, rotationY + 180, 0 })
    else
      local objRot = obj.getRotation()
      local relativeRotY = objRot.y - currentMatRotY
      obj.setRotation({ objRot.x, rotationY + relativeRotY, objRot.z })
    end

    movedObjects[obj.getGUID()] = true
  end

  -- get objects on the mat
  for _, obj in ipairs(SearchLib.onObject(self, "isInteractable")) do
    if not movedObjects[obj.getGUID()] then
      -- make sure object isn't owned by another mat
      local owner = GUIDReferenceApi.getOwnerOfObject(obj)
      if owner == "Mythos" or owner == matColor then
        moveAndRotateObject(obj)
      end
    end
  end

  -- move owned objects (including the mat)
  for _, obj in pairs(GUIDReferenceApi.getObjectsByOwner(matColor)) do
    if not movedObjects[obj.getGUID()] then
      moveAndRotateObject(obj)
    end
  end

  -- make sure the Token Remover Zone is updated
  local TokenRemover = GUIDReferenceApi.getObjectByOwnerAndType(matColor, "TokenRemover")
  if TokenRemover ~= nil then
    TokenRemover.call("updateZone")
  end
end

-- Returns a table with spawn data (position and rotation) for a helper object
---@param helperName string Name of the helper object
function getHelperSpawnData(helperName)
  local localPositionTable = {
    ["Clickable Clue Counter"] = Vector(-1.013, 0.09, 0.692),
    ["Hand Helper"]            = Vector(-0.055, 0.03, -1.132),
    ["Search Assistant"]       = Vector(-0.340, 0.03, -1.132)
  }
  local localRotationTable = {
    ["Clickable Clue Counter"] = Vector(0, 10, 0),
    ["Hand Helper"]            = Vector(0, 0, 0),
    ["Search Assistant"]       = Vector(0, 0, 0)
  }

  local pos = self.positionToWorld(localPositionTable[helperName])
  local rot = self.getRotation() + localRotationTable[helperName]
  return { position = pos, rotation = rot }
end

---------------------------------------------------------
-- Discard buttons (threat area)
---------------------------------------------------------

-- build a discard button to discard from searchPosition
---@param id number Index of the discard button (from left to right, must be unique)
function makeDiscardButton(id)
  local xValue         = DISCARD_BUTTON_X_START + (id - 1) * DISCARD_BUTTON_X_OFFSET
  local position       = Vector(xValue, 0.1, -0.94)
  local searchPosition = Vector(-position[1], 1, position[3] + 0.32)
  local handlerName    = 'handler' .. id
  self.setVar(handlerName, function()
    local cardSizeSearch = Vector(2, 2, 3.2)
    local globalSearchPosition = self.positionToWorld(searchPosition)
    local searchResult = SearchLib.inArea(globalSearchPosition, self.getRotation(), cardSizeSearch)
    return GlobalApi.discardObjects(searchResult, matColor)
  end)
  self.createButton({
    label          = "Discard",
    click_function = handlerName,
    function_owner = self,
    position       = position,
    scale          = { 0.12, 0.12, 0.12 },
    width          = 900,
    height         = 350,
    font_size      = 210
  })
end

-- build a hybrid button to discard from searchPosition or move a card/deck to empty threat area on right click
function makeDrawAreaButton()
  self.createButton({
    label          = "Discard / ➜",
    click_function = "discardOrMove",
    tooltip        = "Right-click to move to threat area",
    function_owner = self,
    position       = { -1.365, 0.1, -0.94 },
    scale          = { 0.12, 0.12, 0.12 },
    width          = 1190,
    height         = 350,
    font_size      = 207
  })
end

function discardOrMove(_, playerColor, isRightClick)
  local searchPosition = self.positionToWorld(Vector(1.365, 1, -0.62))
  local searchRotation = self.getRotation()
  local searchSize     = Vector(2, 2, 3.2) -- roughly size of a card
  local searchResult   = SearchLib.inArea(searchPosition, searchRotation, searchSize)

  if isRightClick then
    local threatAreaPos = getEncounterCardDrawPosition(false)
    if threatAreaPos == getEncounterCardDrawPosition(true) then
      broadcastToColor("Threat area is full.", playerColor, "Yellow")
      return
    end

    for _, obj in ipairs(searchResult) do
      if obj.type == "Card" or obj.type == "Deck" then
        GlobalApi.moveCardWithTokens(obj, threatAreaPos)
      end
    end
  else
    return GlobalApi.discardObjects(searchResult, matColor)
  end
end

---------------------------------------------------------
-- Upkeep button
---------------------------------------------------------

-- calls the Upkeep function with correct parameter
function doUpkeepFromHotkey(clickedByColor)
  doUpkeep(_, clickedByColor)
end

function doUpkeep(_, clickedByColor, isRightClick)
  updateMessageColor(clickedByColor)

  -- print a message to keep track (only visible to the triggering player)
  local coloredName = GlobalApi.getColoredName(playerColor)
  printToColor("Upkeep for " .. coloredName .. " (card draw and then resource gain).", messageColor)

  -- unexhaust cards in play zone, flip action tokens and find Forced Learning / cards that skip resource gains
  local forcedLearning     = false
  local skipUpkeepResource = false
  local rot                = self.getRotation()

  for _, obj in ipairs(searchAroundSelf()) do
    if obj.hasTag("Temporary") then
      GlobalApi.discardObjects(obj, matColor)
    elseif obj.hasTag("UniversalToken") and obj.is_face_down then
      obj.flip()
    end

    -- call the 'doInUpkeep' function for face-up objects with the respective tag
    if obj.hasTag("DoInUpkeep") and not obj.is_face_down then
      obj.call("doInUpkeep")
    end

    -- look for specific cards in the play area or on extensions (draw / discard excluded)
    if (obj.hasTag("onExtension") or self.positionToLocal(obj.getPosition()).x > -1) then
      if obj.type == "Card" and not obj.hasTag("Investigator") then
        GlobalApi.maybeReadyCard(obj, rot, false)

        local cardMetadata = JSON.decode(obj.getGMNotes()) or {}

        -- detect Forced Learning to handle card drawing accordingly
        if cardMetadata.id == "08031" then
          forcedLearning = true
        end

        -- detect Dark Horse
        if obj.hasTag("DisableResourceGain") and not obj.is_face_down then
          skipUpkeepResource = true
        end

        -- maybe replenish uses on certain cards
        if cardMetadata.uses and not obj.is_face_down then
          TokenManagerApi.maybeReplenishCard(obj, cardMetadata.uses, matColor)
        end
      elseif obj.type == "Deck" and not obj.is_face_down and not forcedLearning then -- check face up decks for forced learning
        for _, deepObj in ipairs(obj.getObjects()) do
          local cardMetadata = JSON.decode(deepObj.gm_notes) or {}
          if cardMetadata.id == "08031" then
            forcedLearning = true
          end
        end
      end
    end
  end

  -- flip investigator mini-card and summoned servitor mini-card
  for _, obj in ipairs(getObjectsWithTag("Minicard")) do
    if obj.type == "Card" and obj.is_face_down then
      local md = JSON.decode(obj.getGMNotes()) or {}
      if md.type == "Minicard" and (md.id == activeInvestigatorData.miniId or md.id == "09080-m") then
        obj.flip()
      end
    end
  end

  -- reset action tracker
  GlobalApi.updateActionTrackerTokens(matColor)
  GlobalApi.updateActionTrackerName(matColor)

  if isRightClick then
    printToColor("Skipping card draw and resource gain", messageColor)
    return
  end

  -- draw a card (with handling for Patrice and Forced Learning)
  if activeInvestigatorData.id == "06005" then
    if forcedLearning then
      printToColor("Wow, did you really take 'Versatile' to play Patrice with 'Forced Learning'?"
        .. " Choose which draw replacement effect takes priority and draw cards accordingly.", messageColor)
    else
      -- discards all non-weakness and non-hidden cards from hand first
      local handCards = Player[playerColor].getHandObjects()
      local cardsToDiscard = {}

      for _, card in ipairs(handCards) do
        local md = JSON.decode(card.getGMNotes())
        if card.type == "Card" and md ~= nil and (not md.weakness and not md.hidden and md.id ~= "52020") then
          table.insert(cardsToDiscard, card)
        end
      end

      -- perform discarding 1 by 1
      local pos = returnGlobalDiscardPosition()
      DeckLib.placeOrMergeIntoDeck(cardsToDiscard, pos, self.getRotation())

      -- draw up to 5 cards
      local cardsToDraw = 5 - #handCards + #cardsToDiscard
      if cardsToDraw > 0 then
        printToColor("Discarding " .. #cardsToDiscard .. " and drawing " .. cardsToDraw .. " card(s) instead (Patrice)",
          messageColor)

        -- add some time if there are any cards to discard
        local k = 0
        if #cardsToDiscard > 0 then
          k = 0.8 + (#cardsToDiscard * 0.2)
        end
        Wait.time(function() drawCardsWithReshuffle(cardsToDraw) end, k)
      end
    end
  elseif forcedLearning then
    printToColor("Drawing 2 cards instead, discard 1 (Forced Learning)", messageColor)
    drawCardsWithReshuffle(2)
  elseif activeInvestigatorData.id == "89001" then
    printToColor("Drawing 1 additional card — devour a non-weakness player card in your hand (Subject 5U-21)",
      messageColor)
    drawCardsWithReshuffle(2)
  else
    drawCardsWithReshuffle(1)
  end

  -- gain a resource (or two if playing non-parallel Jenny Barnes), with potential resource skipping
  if skipUpkeepResource == true then
    printToColor("Skipping Upkeep resource(s)", messageColor)
  elseif activeInvestigatorData.id == "02003" or activeInvestigatorData.id == "02003-pb" then
    updateCounter({ type = "ResourceCounter", modifier = 2 })
    printToColor("Gaining 1 additional resource (Jenny)", messageColor)
  else
    updateCounter({ type = "ResourceCounter", modifier = 1 })
  end
end

-- click function for "draw 1 button" (that can be added via option panel)
function doDrawOne(_, clickedByColor)
  updateMessageColor(clickedByColor)
  drawCardsWithReshuffle(1)
end

-- draws the specified amount of cards (and shuffles the discard if necessary)
---@param numCards number Number of cards to draw
function drawCardsWithReshuffle(numCards)
  function drawCardsCoroutine()
    local deckAreaObjects = getDeckAreaObjects()

    -- Norman Withers handling
    local harbinger
    if deckAreaObjects.topCard then
      harbinger = isHarbinger(deckAreaObjects.topCard.getGMNotes())
    elseif deckAreaObjects.draw and not deckAreaObjects.draw.is_face_down then
      local cards = deckAreaObjects.draw.getObjects()
      harbinger = isHarbinger(cards[#cards].gm_notes)
    end

    if harbinger then
      printToColor("The Harbinger is on top of your deck, not drawing cards", messageColor)
      return
    end

    -- draw the top card if possible
    local topCardDetected = false
    if deckAreaObjects.topCard ~= nil then
      deckAreaObjects.topCard.deal(1, playerColor)
      topCardDetected = true
      numCards = numCards - 1
      if numCards == 0 then
        flipTopCardFromDeck()
        return
      end
    end

    -- determine deck size
    local deckSize = 1
    if deckAreaObjects.draw == nil then
      deckSize = 0
    elseif deckAreaObjects.draw.type == "Deck" then
      deckSize = #deckAreaObjects.draw.getObjects()
    end

    -- draw additional cards from existing deck
    if deckSize >= numCards then
      drawCards(deckAreaObjects.draw, numCards)
      if topCardDetected then
        flipTopCardFromDeck()
      end
      return
    end

    -- draw the full deck, form a new deck and draw the remaining cards
    drawCards(deckAreaObjects.draw, deckSize)
    if deckAreaObjects.discard ~= nil then
      CoroutineLib.yieldFrames(30 + deckSize)
      shuffleDiscardIntoDeck()
      CoroutineLib.yieldSeconds(1)

      local shuffledObjects = getDeckAreaObjects()
      drawCards(shuffledObjects.draw, numCards - deckSize)
      if topCardDetected then
        flipTopCardFromDeck()
      end
      printToColor("Take 1 horror (drawing card from empty deck)", messageColor)
    end
  end

  CoroutineLib.start(drawCardsCoroutine)
end

function isHarbinger(notes)
  local md = JSON.decode(notes or "") or {}
  return md.id == "08006"
end

-- get the draw deck and discard pile objects and returns the references
---@return table: string-indexed table with references to the found objects
function getDeckAreaObjects()
  local deckAreaObjects = {}

  -- perform the search for cards / decks
  local pos             = self.positionToWorld(DECK_DISCARD_AREA.center)
  local rot             = self.getRotation()
  local size            = DECK_DISCARD_AREA.size * self.getScale()
  local filter          = "isCardOrDeck"
  local searchResult    = SearchLib.inArea(pos, rot, size, filter)

  -- detect deck / discard and topcard
  for _, object in ipairs(searchResult) do
    if self.positionToLocal(object.getPosition()).z > 0.5 then
      deckAreaObjects.discard = object
      -- Norman Withers handling
    elseif object.type == "Card" and not object.is_face_down then
      deckAreaObjects.topCard = object
    else
      deckAreaObjects.draw = object
    end
  end
  return deckAreaObjects
end

-- draws the specified number of cards (reshuffling of discard pile is handled separately)
---@param cardOrDeck tts__Object Card/Deck to draw from
---@param numCards number Number of cards to draw
function drawCards(cardOrDeck, numCards)
  if cardOrDeck ~= nil then
    cardOrDeck.deal(numCards, playerColor)
  end
end

function shuffleDiscardIntoDeck(player, _, elementId)
  -- update the message color if this was called via button
  if player then
    updateMessageColor(player.color)
  end

  -- get object references
  local objects = getDeckAreaObjects()
  if not objects.discard then
    -- display a feedback message if called via button
    if elementId == "shuffleDiscardButton" then
      broadcastToColor("Discard pile is empty.", messageColor, "Orange")
    end
    return
  end

  -- Norman Withers handling
  local harbinger
  if objects.topCard then
    harbinger = isHarbinger(objects.topCard.getGMNotes())
  elseif objects.draw and not objects.draw.is_face_down then
    local cards = objects.draw.getObjects()
    harbinger = isHarbinger(cards[#cards].gm_notes)
  end

  if harbinger then
    printToColor("The Harbinger is on top of your deck, not shuffling cards into your deck.", messageColor)
    return
  end

  -- prepare deck for shuffling
  local faceDownRotation = self.getRotation():setAt("z", 180)
  local delay = 0.01

  if objects.topCard then
    delay = delay + 0.5
    if objects.draw then
      objects.draw = objects.draw.putObject(objects.topCard)
    else
      objects.topCard.setRotation(faceDownRotation)
    end

    flipTopCardFromDeck(1.5) -- this will be executed after the deck merging + shuffling
  end

  Wait.time(function()
    DeckLib.placeOrMergeIntoDeck(objects.discard, returnGlobalDrawPosition(), faceDownRotation, nil, true)
  end, delay)
end

-- utility function for Norman Withers to flip the top card to the revealed side
function flipTopCardFromDeck(additionalDelay)
  Wait.time(function()
    local deckAreaObjects = getDeckAreaObjects()
    if deckAreaObjects.topCard ~= nil then return end

    if deckAreaObjects.draw ~= nil then
      if deckAreaObjects.draw.type == "Card" then
        deckAreaObjects.draw.flip()
      else
        -- get bounds to know the height of the deck
        local bounds = deckAreaObjects.draw.getBounds()
        local pos = bounds.center + Vector(0, bounds.size.y / 2 + 0.2, 0)
        deckAreaObjects.draw.takeObject({ position = pos, flip = true })
      end
    end
  end, 0.1 + (additionalDelay or 0))
end

-- discard a random non-hidden card from hand
function doDiscardOne(_, clickedByColor)
  updateMessageColor(clickedByColor)

  local hand = Player[playerColor].getHandObjects()
  if #hand == 0 then
    broadcastToColor("Cannot discard from empty hand!", messageColor, "Red")
  else
    local choices = {}
    local hiddenCards = {}
    local missingMetadataCards = {}
    for i, handObj in ipairs(hand) do
      if handObj.type == "Card" then
        -- get a name for the card or use the index if unnamed
        local name = handObj.getName()
        if name == "" then
          name = "Card " .. i
        end

        -- check card for metadata
        local md = JSON.decode(handObj.getGMNotes())
        if md == nil then
          table.insert(missingMetadataCards, name)
        elseif md.hidden or md.id == "52020" then
          table.insert(hiddenCards, name)
        else
          table.insert(choices, i)
        end
      end
    end

    -- print message with hidden cards
    if #hiddenCards > 0 then
      local cardList = concatenateListOfStrings(hiddenCards)
      printToColor("Excluded (hidden): " .. cardList, messageColor)
    end

    -- print message with missing metadata cards
    if #missingMetadataCards > 0 then
      local cardList = concatenateListOfStrings(missingMetadataCards)
      printToColor("Excluded (missing data): " .. cardList, messageColor)
    end

    if #choices == 0 then
      broadcastToColor("Didn't find any eligible cards for random discarding.", messageColor, "Orange")
      return
    end

    -- get a random eligible card (from the "choices" table)
    local num = math.random(1, #choices)
    local card = hand[choices[num]]
    local cardName = card.getName()
    local cardId = choices[num] .. "/" .. #hand

    DeckLib.placeOrMergeIntoDeck(card, returnGlobalDiscardPosition(), self.getRotation())
    local playerName = GlobalApi.getColoredName(playerColor)
    broadcastToAll(playerName .. " randomly discarded " .. cardName .. " (" .. cardId .. ").", "White")
  end
end

function concatenateListOfStrings(list)
  local cardList
  for _, cardName in ipairs(list) do
    if not cardList then
      cardList = ""
    else
      cardList = cardList .. ", "
    end
    cardList = cardList .. cardName
  end
  return cardList
end

---------------------------------------------------------
-- XML creation and modifying
---------------------------------------------------------

-- initializes the XML
function createXML()
  local xml = {}

  -- create a panel for each slot symbol
  -- use the snap point positions in the main play area for positions
  local snapId = 0
  for _, snap in ipairs(self.getSnapPoints()) do
    if inArea(snap.position, MAIN_PLAY_AREA) then
      snapId = snapId + 1
      local slotName = slotData[snapId]

      -- conversion from regular coordinates to XML
      local x = snap.position.x * 100
      local y = snap.position.z * 100

      -- XML for a single slot (panel with text in the special font)
      local slotXML = {
        tag = "Panel",
        attributes = {
          id            = "slotPanel" .. snapId,
          raycastTarget = false, -- this disables the click function temporarily
          onClick       = "slotClickFunction",
          scale         = "0.1 0.1 1",
          width         = 350,
          height        = 175,
          position      = x .. " " .. y .. " -11"
        },
        children = {
          {
            tag = "Text",
            attributes = {
              id       = "slot" .. snapId,
              rotation = getSlotRotation(slotName),
              fontSize = 145,
              font     = "font_arkhamicons",
              color    = "#414141CB",
              text     = SLOT_NAME_TO_CHAR[slotName]
            }
          }
        }
      }
      table.insert(xml, slotXML)
    end
  end

  -- create a button for shuffling the discard pile back
  local shuffleDiscardXML = {
    tag = "Button",
    attributes = {
      id       = "shuffleDiscardButton",
      onClick  = "shuffleDiscardIntoDeck",
      width    = 7,
      height   = 7,
      position = "-182 30.5 -11",
      rotation = "0 0 180",
      image    = "shuffle"
    }
  }
  table.insert(xml, shuffleDiscardXML)

  -- create the personal option panel
  local defaultsXML = {
    tag = "Defaults",
    children = {
      {
        tag = "Text",
        attributes = { color = "#FFFFFF", alignment = "MiddleLeft" }
      },
      {
        tag = "Dropdown",
        attributes = { rectAlignment = "MiddleCenter" }
      },
      {
        tag = "Cell",
        attributes = { dontUseTableCellBackground = true, outlineSize = "0 1", outline = "grey" }
      }
    }
  }
  table.insert(xml, defaultsXML)

  -- work out the position
  local bounds = self.getBoundsNormalized()
  local setAsideDirection = bounds.center.z > 0 and 1 or -1

  -- create a button to toggle the option panel visibility
  local gearPos
  if setAsideDirection == -1 then
    -- next to upkeep button
    gearPos = "-202 -45 -11"
  else
    -- below encounter card drawing
    gearPos = "203 -21 -11"
  end

  local toggleOptionPanelXML = {
    tag = "Button",
    attributes = {
      onClick  = "onClick_hideOrShowOptions",
      width    = 7,
      height   = 7,
      position = gearPos,
      rotation = "0 0 180",
      image    = "option_gear_white"
    }
  }
  table.insert(xml, toggleOptionPanelXML)

  -- work out the size
  local rowHeight = {
    header      = 200,
    groupHeader = 150,
    option      = 150
  }
  local totalHeight = rowHeight.header
  local scale = 0.11

  -- main window
  local fontName = i18nApi.getFont()
  local optionPanelXML = {
    tag = "TableLayout",
    attributes = {
      id           = "optionPanelMain",
      scale        = scale .. " " .. scale,
      width        = "1200",
      columnWidths = "800 400",
      rotation     = "0 0 180",
      active       = optionPanelVisibility ~= "",
      visibility   = optionPanelVisibility,
      color        = "#000000",
      outlineSize  = "5 5",
      outline      = "grey"
    },
    children = {
      -- header
      {
        tag = "Row",
        attributes = { preferredHeight = rowHeight.header },
        children = {
          {
            tag = "Cell",
            children = {
              {
                tag = "Panel",
                attributes = { padding = "30 0 0 0" },
                children = {
                  {
                    tag = "Text",
                    attributes = {
                      id       = "PM_title_text",
                      fontSize = 110,
                      font     = fontName,
                      text     = "Options"
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }

  -- add options groups
  local groupCount = 0
  for groupName, groupData in pairs(AVAILABLE_OPTIONS) do
    groupCount = groupCount + 1
    totalHeight = totalHeight + rowHeight.groupHeader
    -- group header
    local groupXML = {
      tag = "Row",
      attributes = { preferredHeight = rowHeight.groupHeader },
      children = {
        {
          tag = "Cell",
          attributes = { padding = "20 10 0 0", columnSpan = 2, color = "#222222" },
          children = {
            {
              tag = "Panel",
              attributes = { padding = "40 0 0 0" },
              children = {
                {
                  tag = "Text",
                  attributes = {
                    id       = "PM_group_" .. groupCount .. "_text",
                    fontSize = 75,
                    font     = fontName,
                    text     = groupName
                  }
                }
              }
            }
          }
        }
      }
    }
    table.insert(optionPanelXML.children, groupXML)

    -- options
    for _, optionData in ipairs(groupData) do
      totalHeight = totalHeight + rowHeight.option
      local optionXML = {
        tag = "Row",
        attributes = { preferredHeight = rowHeight.option },
        children = {
          -- option title
          {
            tag = "Cell",
            attributes = { padding = "20 10 5 5", color = "#333333" },
            children = {
              {
                tag = "Panel",
                attributes = { padding = "50 0 0 0" },
                children = {
                  {
                    tag = "Text",
                    attributes = {
                      id       = "PM_optionTitle_" .. optionData.id .. "_text",
                      fontSize = 65,
                      font     = fontName,
                      text     = optionData.title
                    }
                  }
                }
              }
            }
          }
        }
      }

      -- default data, will be changed below
      local typeXML = {
        tag = "Cell",
        attributes = { padding = "10 10 5 5", color = "#333333" },
        children = {
          {
            attributes = {
              id            = optionData.id,
              rectAlignment = "MiddleRight",
              offsetXY      = "-30 0",
              fontSize      = 80,
              height        = 108,
              width         = 195,
              ignoreLayout  = "True"
            },
            children = {}
          }
        }
      }

      local subTable = typeXML.children[1]
      if optionData.type == "toggle" then
        -- create toggle button (on / off
        subTable.tag                = "Button"
        subTable.attributes.image   = optionPanelData[optionData.id] and "option_on" or "option_off"
        subTable.attributes.onClick = "onClick_toggleOption"
        subTable.attributes.colors  = "#FFFFFF|#dfdfdf"
      elseif optionData.type == "button" then
        -- create a regular button
        local baseColor = Color(0.228, 0.249, 0.773)

        -- use the hand color for the selection button
        if optionData.id == "handColorSelect" then
          baseColor = Color[playerColor]
        end

        subTable.tag                = "Button"
        subTable.attributes.image   = "option_button"
        subTable.attributes.onClick = "onClick_" .. optionData.id
        subTable.attributes.colors  = ColorLib.getXmlColorBlock(baseColor, 0.75, 1.33)
      elseif optionData.type == "input" then
        -- create an inputfield
        subTable.tag                            = "InputField"
        subTable.attributes.onEndEdit           = "onEndEdit_" .. optionData.id
        subTable.attributes.text                = optionPanelData[optionData.id] or ""
        subTable.attributes.characterValidation = "Integer"
        subTable.attributes.textAlignment       = "MiddleCenter"
      elseif optionData.type == "slider" then
        -- create a slider (not yet used)
        subTable.tag                       = "Slider"
        subTable.attributes.onValueChanged = "onSliderChange"
        subTable.attributes.width          = subTable.attributes.width * 2
        subTable.attributes.wholeNumbers   = true
        subTable.attributes.minValue       = 1
        subTable.attributes.maxValue       = 12
        subTable.attributes.value          = 6
      elseif optionData.type == "dropdown" then
        -- create a dropdown menu
        subTable.tag                       = "Dropdown"
        subTable.attributes.id             = optionData.id
        subTable.attributes.onValueChanged = "onDropdownChange(selectedIndex)"
        subTable.attributes.value          = getDropdownOptionIndex(optionData.id, optionPanelData[optionData.id]) - 1
        subTable.attributes.raycastTarget  = true
        subTable.attributes.dropdownHeight = 250 * math.min(#optionData.options, 3)
        subTable.attributes.itemHeight     = 70
        subTable.attributes.fontSize       = 60
        subTable.attributes.font           = fontName
        subTable.attributes.width          = subTable.attributes.width * 2
        subTable.attributes.children       = {}

        -- add options
        for dropdownOptionId, option in ipairs(optionData.options) do
          table.insert(subTable.children, {
            tag        = "Option",
            value      = option,
            attributes = { id = "PM_option_" .. optionData.id .. "_dropdown_" .. dropdownOptionId }
          })
        end
      end

      table.insert(optionXML.children, typeXML)
      table.insert(optionPanelXML.children, optionXML)
    end
  end
  table.insert(xml, optionPanelXML)

  -- set correct height
  optionPanelXML.attributes.height   = totalHeight

  -- set correct position to align with playermat
  local horizontalOffset             = (optionPanelXML.attributes.width * scale / 2 + 215) * setAsideDirection
  local verticalOffset               = totalHeight * scale / 2 - 95
  optionPanelXML.attributes.position = horizontalOffset .. " " .. verticalOffset .. " -65"

  self.UI.setXmlTable(xml)
end

function onClick_hideOrShowOptions(player)
  GlobalApi.changeWindowVisibility(player.color, "optionPanelMain", _, self)
  Wait.frames(function() updateSave() end, 3)
end

-- show the triggering player a dialog to select a playermat texture
function onClick_textureSelect(player)
  local textureList = {}
  for texture, _ in pairs(NAME_TO_TEXTURE_URL) do
    table.insert(textureList, texture)
  end
  player.showOptionsDialog("Select a texture:", textureList, nil, updateTexture)
end

-- show the triggering player a dialog to select a new hand color for this mat
function onClick_handColorSelect(player)
  local colorList = Player.getColors()

  -- remove existing colors from the list of choices
  for _, existingColor in ipairs(Player.getAvailableColors()) do
    for i, newColor in ipairs(colorList) do
      if existingColor == newColor or newColor == "Black" or newColor == "Grey" then
        table.remove(colorList, i)
      end
    end
  end

  -- show the option dialog for color selection to the player that triggered this
  player.showOptionsDialog("Select a new color:", colorList, nil, function(newColor)
    -- update the color of the hand zone
    local handZone = ownedObjects.HandZone
    handZone.setValue(newColor)

    -- update visibility for old and new color (delay to allow first call to resolve)
    GlobalApi.changeWindowVisibility(playerColor, "optionPanelMain", false, self)
    Wait.frames(function() GlobalApi.changeWindowVisibility(newColor, "optionPanelMain", true, self) end, 3)
    NavigationOverlayApi.copyVisibility(playerColor, newColor)

    -- if there was a seated player, reseat to the new color
    if Player[playerColor].seated then
      Player[playerColor].changeColor(newColor)
    else
      local colorString = "[" .. Color.fromString(newColor):toHex() .. "]" .. newColor .. "[-]"
      printToColor("Updated handcolor for this playermat to " .. colorString .. ".", player.color)
    end

    -- update the internal variable
    playerColor = newColor

    -- update the color of the option button
    local colorBlock = ColorLib.getXmlColorBlock(Color[playerColor], 0.75, 1.33)
    self.UI.setAttribute("handColorSelect", "colors", colorBlock)
    updateSave()

    -- update the mini card border
    maybeDrawBorderAroundMinicard()
  end)
end

-- instruct Global to update this mat's hand visibility
function onClick_visibilitySelect(player)
  if player.color == playerColor then
    printToColor("This is meant to be clicked by other players to be able to see your hand " ..
      "(primarily for multi-handed gameplay). It won't do anything for you.", playerColor)
    return
  end

  GlobalApi.handVisibilityToggle(player.color, playerColor)
end

function toggleVisibilityAll()
  isHandShownToAll = not isHandShownToAll
  updateSave()

  for _, possibleColor in ipairs(Player.getColors()) do
    if possibleColor ~= playerColor and possibleColor ~= "Black" then
      GlobalApi.handVisibilityToggle(possibleColor, playerColor)
    end
  end
end

-- changes the UI state and the internal variable for the togglebuttons
function onClick_toggleOption(player, clickType, id)
  updateMessageColor(player.color)
  applyOptionPanelChange(id, not optionPanelData[id], clickType)
end

function applyOptionPanelChange(id, state, clickType)
  if clickType == "-1" then -- left-clicked
    optionPanelData[id] = state
    self.UI.setAttribute(id, "image", state and "option_on" or "option_off")
  end

  if id == "slotEditing" then
    if currentlyEditingSlots and clickType == "-2" then     -- right-clicked
      resetSlotSymbols()
    elseif currentlyEditingSlots and clickType == "-3" then -- middle-clicked
      resetSlotSymbols(true)
    elseif clickType == "-1" then                           -- left-clicked
      toggleSlotEditing()
    end
  elseif id == "visibilityAll" then
    toggleVisibilityAll()
  end
end

-- updates the XML for the slot symbols based on the slotData table
function updateSlotSymbols(newSlotData)
  if newSlotData then
    slotData = newSlotData
    updateSave()
  end

  for slotId, slotName in ipairs(slotData) do
    -- update the symbol
    self.UI.setAttributes("slot" .. slotId, {
      rotation = getSlotRotation(slotName),
      text = SLOT_NAME_TO_CHAR[slotName]
    })

    -- update availability of the click function
    self.UI.setAttribute("slotPanel" .. slotId, "raycastTarget", currentlyEditingSlots)
  end
end

-- toggle the "slot editing mode"
function toggleSlotEditing()
  currentlyEditingSlots = not currentlyEditingSlots
  updateSlotSymbols()

  if currentlyEditingSlots then
    broadcastToColor("Check chat for instructions", messageColor, "Orange")
    printToColor("Click on a slot symbol (or an empty slot) to edit it. " ..
      "Right-click the 'Slot-Edit' button to return to the default slots. " ..
      "Middle-click the 'Slot-Edit' button to remove all slot symbols.", messageColor, "White")
  else
    updateSave()
  end
end

-- click function for slot symbols during the "slot editing mode"
function slotClickFunction(player, _, id)
  local slotIndex = id:gsub("slotPanel", "")
  slotIndex = tonumber(slotIndex)

  -- make a list of the table keys as options for the dialog box
  local slotNames = {}
  for slotName, _ in pairs(SLOT_NAME_TO_CHAR) do
    table.insert(slotNames, slotName)
  end

  -- prompt player to choose symbol
  player.showOptionsDialog("Choose Slot Symbol", slotNames, slotData[slotIndex],
    function(chosenSlotName)
      slotData[slotIndex] = chosenSlotName
      updateSlotSymbols()
    end
  )
end

-- helper function to rotate the left hand
function getSlotRotation(slotName)
  if slotName == "Hand (left)" then
    return "0 180 180"
  else
    return "0 0 180"
  end
end

-- reset the slot symbols by making a deep copy of the default data and redrawing
---@param empty? boolean If true, will set the slot symbols to "any" (empty) instead of the defaults
function resetSlotSymbols(empty)
  slotData = {}
  for _, slotName in ipairs(DEFAULT_SLOT_DATA) do
    table.insert(slotData, empty and "any" or slotName)
  end
  updateSave()
  updateSlotSymbols()
end

function modifySlot(newSlot, cardPosition)
  local slotSnaps = {}
  local snaps = self.getSnapPoints()
  for i, snap in ipairs(snaps) do
    if inArea(snap.position, MAIN_PLAY_AREA) then
      table.insert(slotSnaps, snap)
    end
  end
  cardPosition.y = 0
  for snapId, snap in ipairs(slotSnaps) do
    local snapPosition = Vector(snap.position.x, 0, snap.position.z)
    if snapPosition == cardPosition then
      slotData[snapId] = newSlot
      if Player[playerColor].seated then
        printToColor(newSlot .. " slot added to player mat", playerColor, playerColor)
      else
        local hostColor = Player.getPlayers()[1].color
        printToColor(newSlot .. " slot added to player mat", hostColor, hostColor)
      end
    end
  end
  updateSave()
  updateSlotSymbols()
end

function onEndEdit_exhaustRotation(player, text)
  local angle = MathLib.roundAngleToMultiple(tonumber(text), 15)
  self.UI.setAttribute("exhaustRotation", "text", angle)
  optionPanelData["exhaustRotation"] = angle
  updateSave()

  if math.abs(angle) > 90 then
    printToColor("It's recommended to choose a value between 0° and 90°.", player.color, "Yellow")
  end
end

function getOptionPanelSetting(setting)
  return optionPanelData[setting]
end

function getExhaustRotation(convertToGlobal)
  local exhaustRotation = optionPanelData["exhaustRotation"]
  if convertToGlobal then
    return Vector(0, (self.getRotation().y + exhaustRotation) % 360, 0)
  else
    return exhaustRotation
  end
end

function onDropdownChange(_, selectedIndex, id)
  optionPanelData[id] = getDropdownOptionValue(id, tonumber(selectedIndex) + 1)

  -- update XML so that the settings persists
  self.UI.setAttribute(id, "value", selectedIndex)
end

function getDropdownOptionValue(optionId, selectedIndex)
  for _, groupData in pairs(AVAILABLE_OPTIONS) do
    for _, optionData in pairs(groupData) do
      if optionData.id == optionId then
        return optionData.options[selectedIndex]
      end
    end
  end
end

function getDropdownOptionIndex(optionId, selectedValue)
  for _, groupData in pairs(AVAILABLE_OPTIONS) do
    for _, optionData in pairs(groupData) do
      if optionData.id == optionId then
        for index, optionName in ipairs(optionData.options) do
          if optionName == selectedValue then
            return index
          end
        end
      end
    end
  end
end

---------------------------------------------------------
-- playermat token spawning
---------------------------------------------------------

-- Finds all customizable cards in this play area and updates their metadata based on the selections
-- on the matching upgrade sheet.
-- This method is theoretically O(n^2), and should be used sparingly.  In practice it will only be
-- called when a checkbox is added or removed in-game (which should be rare), and is bounded by the
-- number of customizable cards in play.
function syncAllCustomizableCards()
  for _, card in ipairs(searchAroundSelf("isCard")) do
    syncCustomizableMetadata(card, JSON.decode(card.getGMNotes()))
  end
end

function syncCustomizableMetadata(card, cardMetadata)
  if cardMetadata == nil or cardMetadata.customizations == nil then return end

  for _, upgradeSheet in ipairs(searchAroundSelf("isCard")) do
    local upgradeSheetMetadata = JSON.decode(upgradeSheet.getGMNotes()) or {}
    if upgradeSheetMetadata.id == (cardMetadata.id .. "-c") then
      for i, customization in ipairs(cardMetadata.customizations) do
        if customization.replaces ~= nil and customization.replaces.uses ~= nil then
          if upgradeSheet.call("isUpgradeActive", i) then
            cardMetadata.uses = customization.replaces.uses
            card.setGMNotes(JSON.encode(cardMetadata))
          else
            -- restore original 'uses' metadata
            local originalData = AllCardsBagApi.getCardById(cardMetadata.id)
            if originalData and originalData.metadata and originalData.metadata.uses then
              cardMetadata.uses = originalData.metadata.uses
              card.setGMNotes(JSON.encode(cardMetadata))
            end
          end
        end
      end
    end
  end
end

function spawnTokensFor(object)
  local extraUses = {}             -- higher count for an existing type of uses
  local spawnReactionToken = false -- additional action token (atm only for Michael's Firearms)

  -- add one additional charge for Akachi Onyele
  if activeInvestigatorData.id == "03004" then
    extraUses["Charge"] = 1
  end

  -- TODO: If we need this for more cards, should turn it into a metadata field
  -- add one additional secret for Elsie Malone (from aughhh's Night of Vespers)
  if activeInvestigatorData.id == "1030fde5-0c2f-4ced-a29f-5b61dd32c51b" then
    extraUses["Secret"] = 1
  end

  -- Firarm handling
  local md = JSON.decode(object.getGMNotes()) or {}
  if string.find(md.traits or "", "Firearm.") then
    -- add additional ammo for "Locked and Loaded"
    if foundLockedAndLoaded() then
      extraUses["Ammo"] = 1
    end

    -- add reaction token for Michael
    if activeInvestigatorData.id == "11011" then
      spawnReactionToken = true
    end
  end

  TokenManagerApi.spawnForCard(object, extraUses, spawnReactionToken, matColor)
end

-- search for "Locked and Loaded"
function foundLockedAndLoaded()
  for _, obj in ipairs(searchAroundSelf("isCardOrDeck")) do
    if obj.type == "Card" then
      local md = JSON.decode(obj.getGMNotes()) or {}
      if md.id == "11030" then
        return true
      end
    elseif obj.type == "Deck" then
      for _, deepObj in ipairs(obj.getObjects()) do
        local cardMetadata = JSON.decode(deepObj.gm_notes) or {}
        if cardMetadata.id == "11030" then
          return true
        end
      end
    end
  end
  return false
end

function onCollisionEnter(collisionInfo)
  local object = collisionInfo.collision_object

  -- only continue if loading is completed
  if not collisionEnabled then return end

  -- only continue for cards
  if object.type ~= "Card" then return end

  -- only continue if card didn't already collide
  if collisionTable[object] ~= nil then return end
  collisionTable[object] = true
  Wait.frames(function() collisionTable[object] = nil end, 1)

  local md = JSON.decode(object.getGMNotes()) or {}
  syncCustomizableMetadata(object, md)

  local localCardPos = self.positionToLocal(object.getPosition())
  if inArea(localCardPos, INVESTIGATOR_AREA) then
    if md.type == "Investigator" and md.id ~= nil then
      maybeUpdateActiveInvestigator(object, md)

      -- this is mostly for helpers like Stella and Kohaku
      spawnTokensOrShowHelper(object)
    end
  elseif inArea(localCardPos, DECK_DISCARD_AREA) then
    TokenSpawnTrackerApi.resetTokensSpawned(object)
    GlobalApi.removeTokensFromObject(object, matColor)
    if md.id == "07224" then luckyPennyEnabled = false end
  elseif object.is_face_down == false then
    -- main uses spawning
    if (collisionInfo.isOnExtension or inArea(localCardPos, MAIN_PLAY_AREA))
        and (md.type == "Asset" or md.type == "Event") then
      spawnTokensOrShowHelper(object)

      if md.id == "02158" or md.id == "01694" or md.id == "90027" or md.id == "60232" then
        modifySlot("Ally", localCardPos)
      elseif md.id == "02157" or md.id == "01695" then
        modifySlot("Accessory", localCardPos)
      elseif md.id == "10132" then
        modifySlot("Blursed", localCardPos)
      end
    end

    -- encounter types / committed skill cards in the threat area
    if inArea(localCardPos, THREAT_AREA) and (md.type == "Treachery" or md.type == "Enemy" or md.type == "Skill" or md.weakness) then
      spawnTokensOrShowHelper(object)
    end
  end
end

function spawnTokensOrShowHelper(card)
  spawnTokensFor(card)

  if card.hasTag("CardWithHelper") then
    -- get state of the option panel
    local options = GlobalApi.getOptionPanelState()
    if options.enableCardHelpers then
      card.call("setHelperState", true)
    end
  end
end

function onObjectEnterContainer(container, object)
  if object.type ~= "Card" then return end

  local localCardPos = self.positionToLocal(object.getPosition())
  if inArea(localCardPos, DECK_DISCARD_AREA) then
    TokenSpawnTrackerApi.resetTokensSpawned(object)
    GlobalApi.removeTokensFromObject(object, matColor)
    local metadata = JSON.decode(object.getGMNotes()) or {}
    if metadata.id == "07224" then luckyPennyEnabled = false end
  end
end

---------------------------------------------------------
-- investigator ID grabbing and skill tracker
---------------------------------------------------------

-- updates the internal investigator data and performs additional operations if an investigator card is detected
---@param card tts__Object Card that might be an investigator
---@param md table Metadata for the card
function maybeUpdateActiveInvestigator(card, md)
  -- don't continue if this is already the active investigator
  if md.id == activeInvestigatorData.id then return end

  -- extract relevant data from the metadata
  activeInvestigatorData.class = md.class
  activeInvestigatorData.id = md.id
  activeInvestigatorData.miniId = GlobalApi.getMiniId(md.id)
  ownedObjects.InvestigatorSkillTracker.call("updateStats", {
    md.willpowerIcons,
    md.intellectIcons,
    md.combatIcons,
    md.agilityIcons
  })

  maybeDrawBorderAroundMinicard()

  -- small delay to allow other objects to finish colliding
  Wait.time(updateTexture, 0.3)

  newInvestigatorCallback(md.id)

  -- set proper scale for investigators
  local cardData = card.getData()
  if cardData["SidewaysCard"] == true then
    -- 115% for easier readability
    card.setScale({ 1.15, 1, 1.15 })
  else
    -- Zoop-exported investigators are horizontal cards and TTS scales them differently
    card.setScale({ 0.8214, 1, 0.8214 })
  end

  -- remove old action tokens (only the smaller ones if 'dontChangeActionTokens' is true)
  for _, obj in ipairs(searchAroundSelf("isUniversalToken")) do
    if not dontChangeActionTokens or obj.getScale().x < 0.4 then
      obj.destruct()
    end
  end

  if not dontChangeActionTokens then
    -- spawn three regular action tokens
    spawnActionTokens()
  end

  dontChangeActionTokens = false


  -- spawn additional token (maybe specific for investigator)
  if md.extraToken and md.extraToken ~= "None" then
    local tokenType      = "universalActionAbility"
    local rotation       = self.getRotation()
    local callbackName   = "updateUniversalActionAbilityToken"
    local callbackParams = { class = activeInvestigatorData.class, symbol = activeInvestigatorData.class }

    -- spawn tokens (split string by "|")
    local count          = { action = 0, ability = 0 }
    for str in string.gmatch(md.extraToken, "([^|]+)") do
      local type = "action"
      if str == "FreeTrigger" or str == "Reaction" or string.contains(str, "Ability") then
        type = "ability"
      end

      count[type] = count[type] + 1
      if count[type] > 2 then
        printToColor("More than two extra tokens of the same type are not supported.", playerColor)
      else
        local localSpawnPos = tokenSpawnPos[type][count[type]]
        local globalSpawnPos = self.positionToWorld(localSpawnPos):add(Vector(0, 0.2, 0))
        callbackParams.symbol = str
        TokenManagerApi.spawnToken(globalSpawnPos, tokenType, rotation, callbackName, callbackParams)
      end
    end
  end
end

function maybeDrawBorderAroundMinicard()
  if not GlobalApi.getOptionPanelState().highlightMinicards then return end

  for _, minicard in ipairs(getObjectsWithTag("Minicard")) do
    if minicard.type == "Card" then
      local miniMd = JSON.decode(minicard.getGMNotes()) or {}
      if miniMd.type == "Minicard" and miniMd.id == activeInvestigatorData.miniId then
        GlobalApi.drawBorderAroundCard(minicard, playerColor, 0.15)
        break
      end
    end
  end
end

function spawnActionTokens()
  local tokenType      = "universalActionAbility"
  local rotation       = self.getRotation()
  local callbackName   = "updateUniversalActionAbilityToken"
  local callbackParams = { class = activeInvestigatorData.class, symbol = activeInvestigatorData.class }

  for i = 1, 3 do
    local position = self.positionToWorld(Vector(-1.54 + i * 0.17, 0, -0.28)):add(Vector(0, 0.2, 0))
    TokenManagerApi.spawnToken(position, tokenType, rotation, callbackName, callbackParams)
  end
end

-- does something for specific investigators when they are loaded
function newInvestigatorCallback(newId)
  updateMessageColor()
  Wait.frames(function() GlobalApi.updateActionTrackerName(matColor) end, 3)
  Wait.frames(function() GlobalApi.updateActionTrackerTokens(matColor) end, 5)

  -- remove existing object that was placed for a specific investigator
  local obj = GUIDReferenceApi.getObjectByOwnerAndType(matColor, "InvestigatorSpecifics")
  if obj ~= nil then
    obj.destruct()
    GUIDReferenceApi.editIndex(matColor, "InvestigatorSpecifics")
  end

  if newId == "01005-p" or newId == "01005-pf" then -- parallel Wendy Adams
    printToColor("Wendy Adams: There's a Game Key to add sealing options to any card:" ..
      " Top menu bar > Options > Game Keys", messageColor)
  elseif newId == "06003" then -- Tony Morgan
    spawnInfiniteTokenBag("bounty")
    printToColor("Tony Morgan: Spawned bounty tokens near your playermat.", messageColor)
  elseif newId == "08004" then -- Norman Withers
    printToColor("Norman Withers: At the start of the game flip the top card of your deck manually " ..
      "and then the mod should keep it flipped throughout the game.", messageColor)
  elseif newId == "09015" then -- Darrell Simmons
    spawnInfiniteTokenBag("evidence")
    printToColor("Darrell Simmons: Spawned evidence tokens near your playermat.", messageColor)
  elseif string.sub(newId, 1, 5) == "03006" then -- Lola Hayes (including taboo and parallel)
    local pos = zones.getZonePosition(matColor, "AboveSetAside"):setAt("y", 2.2)
    local rot = Vector(90, self.getRotation().y + 180, 0)
    local sourceBag = GUIDReferenceApi.getObjectByOwnerAndType("Mythos", "ObjectSourceBag")
    for _, objData in ipairs(sourceBag.getData().ContainedObjects) do
      if objData["GUID"] == "loladie" then
        local spawnedObj = spawnObjectData({ data = objData, position = pos, rotation = rot })
        GUIDReferenceApi.editIndex(matColor, "InvestigatorSpecifics", spawnedObj.getGUID())
        break
      end
    end
    printToColor("Lola Hayes: Spawned die for role tracking near your playermat.", messageColor)
  elseif newId == "89001" then -- Subject 5U-21
    local pos = zones.getZonePosition(matColor, "BelowSetAside")
    local rot = self.getRotation()
    local sourceBag = GUIDReferenceApi.getObjectByOwnerAndType("Mythos", "ObjectSourceBag")
    for _, objData in ipairs(sourceBag.getData().ContainedObjects) do
      if objData["Nickname"] == "Subject 5U-21 Helper" then
        local spawnedObj = spawnObjectData({ data = objData, position = pos, rotation = rot })
        GUIDReferenceApi.editIndex(matColor, "InvestigatorSpecifics", spawnedObj.getGUID())
        break
      end
    end
    printToColor("Subject 5U-21: Spawned a helper to track the classes of devoured cards near your playermat. " ..
      "Note that this and 'Ravenous' will work with the Attachment Helper from the option panel.", messageColor)
  end
end

-- spawns an infinite token bag of the specified type near the set aside area
function spawnInfiniteTokenBag(tokenType)
  local pos = zones.getZonePosition(matColor, "AboveSetAside")
  local rot = self.getRotation()
  local spawnedObj = spawnObjectData({ data = TokenManagerApi.getDataForInfiniteBag(tokenType, pos, rot) })
  GUIDReferenceApi.editIndex(matColor, "InvestigatorSpecifics", spawnedObj.getGUID())
end

-- updates the texture of the playermat
---@param overrideName? string Force a specific texture
function updateTexture(overrideName)
  updateSave()

  local name = "Neutral"

  -- use class specific texture if enabled
  if isClassTextureEnabled then
    name = activeInvestigatorData.class
  end

  -- get new texture URL
  local newUrl = NAME_TO_TEXTURE_URL[name]

  -- override name if valid
  if NAME_TO_TEXTURE_URL[overrideName] then
    newUrl = NAME_TO_TEXTURE_URL[overrideName]
  end

  -- apply texture
  local customInfo = self.getCustomObject()
  if customInfo.image ~= newUrl then
    -- make sure objects are resting and store position
    local objectsToUnlock = {}
    for _, obj in ipairs(searchAroundSelf()) do
      if not obj.getLock() then
        obj.resting = true
        table.insert(objectsToUnlock, { obj = obj, pos = obj.getPosition() })
      end
    end

    customInfo.image = newUrl
    ---@diagnostic disable-next-line: param-type-mismatch
    self.setCustomObject(customInfo)
    local reloadedMat = self.reload()

    -- restore object positions
    Wait.condition(function()
      Wait.frames(function()
        for _, objTable in ipairs(objectsToUnlock) do
          if objTable.obj ~= nil then
            objTable.obj.resting = true
            objTable.obj.setPosition(objTable.pos)
          end
        end
      end, 5)
    end, function() return reloadedMat.loading_custom == false end)
  end
end

---------------------------------------------------------
-- manipulation of owned objects
---------------------------------------------------------

-- updates the specified owned counter
---@param param table Contains the information to update:
---   type: String Counter to target
---   newValue: Number Value to set the counter to
---   modifier: Number If newValue is not provided, the existing value will be adjusted by this modifier
function updateCounter(param)
  local counter = ownedObjects[param.type]
  if counter ~= nil then
    counter.call("updateVal", param.newValue or (counter.getVar("val") + param.modifier))
  else
    printToAll(param.type .. " for " .. matColor .. " could not be found.", "Yellow")
  end
end

-- get the value the specified owned counter
---@param type string Counter to target
---@return number: Counter value
function getCounterValue(type)
  return ownedObjects[type].getVar("val")
end

function activateTransformEffect()
  dontChangeActionTokens = true
end

---------------------------------------------------------
-- calls to 'Global' / functions for calls from outside
---------------------------------------------------------

function drawChaosTokenButton(_, _, isRightClick)
  ChaosBagApi.drawChaosToken(self, isRightClick)
end

function drawEncounterCard(_, _, isRightClick)
  local drawPos = getEncounterCardDrawPosition(not isRightClick)
  MythosAreaApi.drawEncounterCard(matColor, drawPos)
end

function returnGlobalDiscardPosition()
  return self.positionToWorld(DISCARD_PILE_POSITION)
end

function returnGlobalDrawPosition()
  return self.positionToWorld(DRAW_DECK_POSITION)
end

-- returns the position for encounter card drawing
---@param stack boolean If true, returns the leftmost position instead of the first empty from the right
function getEncounterCardDrawPosition(stack)
  local drawPos = self.positionToWorld(DRAWN_ENCOUNTER_POSITION)

  -- maybe override position with first empty slot in threat area (right to left)
  if not stack then
    local searchPos = Vector(-0.91, 0.5, -0.625)
    for i = 1, 5 do
      local globalSearchPos = self.positionToWorld(searchPos)
      local searchResult = SearchLib.atPosition(globalSearchPos, "isCardOrDeck")
      if #searchResult == 0 then
        drawPos = globalSearchPos
        break
      else
        searchPos.x = searchPos.x + 0.455
      end
    end
  end

  return drawPos
end

-- creates / removes the draw 1 button
---@param visible? boolean Whether the draw 1 button should be visible
function showDrawButton(visible)
  if visible ~= nil then
    isDrawButtonVisible = visible
    updateSave()
  end

  if isDrawButtonVisible then
    -- Draw 1 button: modified default data
    buttonParameters.label = "Draw 1"
    buttonParameters.click_function = "doDrawOne"
    buttonParameters.tooltip = ""
    buttonParameters.position.z = -0.35
    self.createButton(buttonParameters)
  else
    local buttons = self.getButtons()
    for i = 1, #buttons do
      if buttons[i].label == "Draw 1" then
        self.removeButton(buttons[i].index)
      end
    end
  end
end

-- shows / hides a clickable clue counter for this playermat and sets the correct amount of clues
---@param showCounter boolean Whether the clickable clue counter should be visible
function clickableClues(showCounter)
  -- update object references
  getOwnedObjects()

  local currentCount = 0

  if showCounter then
    -- get current clue count
    currentCount = clueCount

    -- remove clues
    removeClues()

    -- set value for clue clickers
    ownedObjects.ClickableClueCounter.call("updateVal", currentCount)
  else
    -- get current clue count
    currentCount = ownedObjects.ClickableClueCounter.getVar("val")

    -- spawn clues
    local pos = self.positionToWorld({ x = -1.12, y = 0.05, z = 0.7 })
    local rot = self.getRotation()
    for i = 1, currentCount do
      pos.y = pos.y + 0.045 * i
      TokenManagerApi.spawnToken(pos, "clue", rot)
    end
  end
end

-- Toggles the use of class textures
---@param state boolean Whether the class texture should be used or not
function useClassTexture(state)
  if state == isClassTextureEnabled then return end
  isClassTextureEnabled = state
  updateTexture()
end

-- removes all clues (moving tokens to the trash and setting counters to 0)
function removeClues()
  searchForClueDoom(true)
  if ownedObjects.ClickableClueCounter then
    ownedObjects.ClickableClueCounter.call("updateVal", 0)
  end
end

-- reports the clue count
function getClueCount()
  if GlobalApi.getOptionPanelState().useClueClickers then
    if ownedObjects.ClickableClueCounter then
      return ownedObjects.ClickableClueCounter.getVar("val")
    else
      return 0
    end
  else
    return clueCount
  end
end

-- reports the doom count
function getDoomCount()
  return doomCount
end

function searchForClueDoom(removeClues)
  local foundTokens = { clue = 0, doom = 0 }

  -- search on playermat and extensions
  local objectList  = SearchLib.onObject(self, "isTileOrToken")
  local extensions  = getObjectsWithAllTags({ "PlayermatExtension", matColor })

  if #extensions ~= 0 then
    -- make a map to quickly check if an object is already part of the search
    local objectListMap = TableLib.makeMap(objectList)
    for _, extension in ipairs(extensions) do
      for _, obj in ipairs(SearchLib.onObject(extension, "isTileOrToken")) do
        if not objectListMap[obj] then
          table.insert(objectList, obj)
        end
      end
    end
  end

  for _, obj in ipairs(objectList) do
    local clueQuantity = getClueQuantityOfObject(obj)
    local doomQuantity = getDoomQuantityOfObject(obj)

    -- maybe remove clues
    if removeClues and clueQuantity > 0 then
      if ownedObjects.Trash then
        ownedObjects.Trash.putObject(obj)
      else
        obj.destruct()
      end
      clueQuantity = 0
    end

    foundTokens.clue = foundTokens.clue + clueQuantity
    foundTokens.doom = foundTokens.doom + doomQuantity
  end

  -- update global variable
  clueCount = foundTokens.clue
  doomCount = foundTokens.doom

  -- update clue counter button
  if ownedObjects.ClueCounter then
    if ownedObjects.ClueCounter.getButtons() == nil then
      ownedObjects.ClueCounter.createButton({
        label          = clueCount,
        click_function = "none",
        function_owner = self,
        position       = { 0, 0.1, 0 },
        height         = 0,
        width          = 0,
        font_color     = { 0, 0, 0 },
        font_size      = 2000
      })
    else
      ownedObjects.ClueCounter.editButton({ index = 0, label = clueCount })
    end
  end
end

function getClueQuantityOfObject(obj)
  -- check memo
  if obj.memo ~= "clueDoom" then return 0 end

  -- check flip (clues are face up)
  if obj.is_face_down then return 0 end

  -- exclude threat area
  local localPos = self.positionToLocal(obj.getPosition())
  if localPos.z < -0.4 then return 0 end

  -- handle stacks
  return math.abs(obj.getQuantity())
end

function getDoomQuantityOfObject(obj)
  -- check for ignore tag
  if obj.hasTag("DoomCounter_ignore") then return 0 end

  -- handle clickable doom counters
  if obj.memo == "DoomCounter" then
    return obj.getVar("val")
  end

  -- check memo
  if obj.memo ~= "clueDoom" then return 0 end

  -- check flip (doom is face down)
  if not obj.is_face_down then return 0 end

  -- handle stacks
  return math.abs(obj.getQuantity())
end

-- Sets this playermat's snap points to limit snapping to matching card types or not. If matchTypes
-- is true, the main card slot snap points will only snap assets, while the investigator area point
-- will only snap Investigators. If matchTypes is false, snap points will be reset to snap all cards.
---@param matchTypes boolean Whether snap points should only snap for the matching card types.
function setLimitSnapsByType(matchTypes)
  local snaps = self.getSnapPoints()
  for i, snap in ipairs(snaps) do
    if inArea(snap.position, MAIN_PLAY_AREA) then
      local snapTags = snaps[i].tags
      if matchTypes then
        if snapTags == nil then
          snaps[i].tags = { "Asset" }
        else
          table.insert(snaps[i].tags, "Asset")
        end
      else
        snaps[i].tags = nil
      end
    end
    if inArea(snap.position, INVESTIGATOR_AREA) then
      local snapTags = snaps[i].tags
      if matchTypes then
        if snapTags == nil then
          snaps[i].tags = { "Investigator" }
        else
          table.insert(snaps[i].tags, "Investigator")
        end
      else
        snaps[i].tags = nil
      end
    end
  end
  self.setSnapPoints(snaps)
end

-- Simple method to check if the given point is in a specified area. Local use only
---@param point tts__Vector Point to check, only x and z values are relevant
---@param bounds table Defined area to see if the point is within. See MAIN_PLAY_AREA for sample bounds definition.
---@return boolean: True if the point is in the area defined by bounds
function inArea(point, bounds)
  return (point.x < bounds.upperLeft.x
    and point.x > bounds.lowerRight.x
    and point.z < bounds.upperLeft.z
    and point.z > bounds.lowerRight.z)
end

function getActiveInvestigatorData() return activeInvestigatorData end

function setActiveInvestigatorData(newData) activeInvestigatorData = newData end
