require("core/Constants")
local chaosBagApi                 = require("chaosbag/ChaosBagApi")
local deckLib                     = require("util/DeckLib")
local GlobalApi                   = require("core/GlobalApi")
local guidReferenceApi            = require("core/GUIDReferenceApi")
local mythosAreaApi               = require("mythos/MythosAreaApi")
local navigationOverlayApi        = require("core/NavigationOverlayApi")
local searchLib                   = require("util/SearchLib")
local tokenChecker                = require("tokens/TokenChecker")
local tokenManagerApi             = require("tokens/TokenManagerApi")
local tokenSpawnTrackerApi        = require("tokens/TokenSpawnTrackerApi")
local zones                       = require("playermat/Zones")

-- option panel data
local availableOptions            = {
  ["PERSONAL SETTINGS"] = {
    {
      id    = "slotEditing",
      title = "Enable Slot Edit Mode",
      type  = "toggle"
    },
    {
      id    = "textureSelect",
      title = "Select Playermat Texture",
      type  = "button"
    },
    {
      id    = "handColorSelect",
      title = "Select Hand Color",
      type  = "button"
    },
    {
      id    = "visibilitySelect",
      title = "Show/Hide this Hand to me",
      type  = "button"
    },
    {
      id    = "visibilityAllSelect",
      title = "Show/Hide this Hand to all",
      type  = "button"
    }
  }
}

-- stores the value for each id
local optionPanelData             = {}
optionPanelData.slotEditing       = false

-- we use this to turn off collision handling until onLoad() is complete
local collisionEnabled            = false
local currentlyEditingSlots       = false

-- for stopping multiple collisions of the same object
local collisionTable              = {}

-- x-Values for discard buttons
local DISCARD_BUTTON_X_START      = -1.365
local DISCARD_BUTTON_X_OFFSET     = 0.455

local SEARCH_AROUND_SELF_X_BUFFER = 8
local SEARCH_AROUND_SELF_Z_BUFFER = 1.75

-- defined areas for object searching
local MAIN_PLAY_AREA              = {
  upperLeft  = { x = 1.98, z = 0.736 },
  lowerRight = { x = -0.79, z = -0.39 }
}
local INVESTIGATOR_AREA           = {
  upperLeft  = { x = -1.084, z = 0.06517 },
  lowerRight = { x = -1.258, z = -0.0805 }
}
local THREAT_AREA                 = {
  upperLeft  = { x = 1.53, z = -0.34 },
  lowerRight = { x = -1.13, z = -0.92 }
}
local DECK_DISCARD_AREA           = {
  upperLeft  = { x = -1.62, z = 0.855 },
  lowerRight = { x = -2.02, z = -0.245 },
  center     = { x = -1.82, y = 0.5, z = 0.305 },
  size       = Vector(0.4, 3, 1.1)
}

-- local positions
local DRAW_DECK_POSITION          = { x = -1.82, y = 0.1, z = 0 }
local DISCARD_PILE_POSITION       = { x = -1.82, y = 0.1, z = 0.61 }
local DRAWN_ENCOUNTER_POSITION    = { x = 1.365, y = 0.5, z = -0.625 }
local tokenSpawnPos               = {
  action = {
    Vector(-0.86, 0, -0.28), -- left of the regular three actions
    Vector(-1.54, 0, -0.28), -- right of the regular three actions
  },
  ability = {
    Vector(-1, 0, 0.118),  -- bottom left corner of the investigator card
    Vector(-1, 0, -0.118), -- top left corner of the investigator card
  }
}

-- used for the buttons on the right side of the playermat
-- starts off with the data for the "Upkeep" button and will then be changed
local buttonParameters            = {
  label = "Upkeep",
  click_function = "doUpkeep",
  tooltip = "Right-click to skip resource gain and card draw",
  function_owner = self,
  position = { x = 1.82, y = 0.15, z = -0.45 },
  scale = { 0.12, 0.12, 0.12 },
  width = 1000,
  height = 280,
  font_size = 180
}

-- table of texture URLs
local nameToTexture               = {
  Guardian = "https://steamusercontent-a.akamaihd.net/ugc/2501268517241599869/179119CA88170D9F5C87CD00D267E6F9F397D2F7/",
  Mystic   = "https://steamusercontent-a.akamaihd.net/ugc/2501268517241600113/F6473F92B3435C32A685BB4DC2A88C2504DDAC4F/",
  Neutral  = "https://steamusercontent-a.akamaihd.net/ugc/2462982115659543571/5D778EA4BC682DAE97E8F59A991BCF8CB3979B04/",
  Rogue    = "https://steamusercontent-a.akamaihd.net/ugc/2501268517241600395/00CFAFC13D7B6EACC147D22A40AF9FBBFFAF3136/",
  Seeker   = "https://steamusercontent-a.akamaihd.net/ugc/2501268517241600579/92DEB412D8D3A9C26D1795CEA0335480409C3E4B/",
  Survivor = "https://steamusercontent-a.akamaihd.net/ugc/2501268517241600848/CEB685E9C8A4A3C18A4B677A519B49423B54E886/"
}

-- translation table for slot names to characters for special font
local slotNameToChar              = {
  ["any"]          = "",
  ["Accessory"]    = "C",
  ["Ally"]         = "E",
  ["Arcane"]       = "G",
  ["Body"]         = "K",
  ["Hand (right)"] = "M",
  ["Hand (left)"]  = "M",
  ["Hand x2"]      = "N",
  ["Tarot"]        = "A",
  ["Blursed"]      = "zy"
}

-- slot symbol for the respective slot (from top left to bottom right) - intentionally global!
slotData                          = {}
local defaultSlotData             = {
  -- 1st row
  "any", "any", "any", "Tarot", "Hand (left)", "Hand (right)", "Ally",

  -- 2nd row
  "any", "any", "any", "Accessory", "Arcane", "Arcane", "Body"
}

local activeInvestigatorData      = {}
luckyPennyEnabled           = false
local isClassTextureEnabled       = true
local isDrawButtonVisible         = false
local optionPanelVisibility       = ""

-- table of type-object reference pairs of all owned objects
local ownedObjects                = {}
local matColor                    = self.getMemo()

function updateSave()
  optionPanelVisibility = self.UI.getAttribute("optionPanelMain", "visibility") or ""
  self.script_state = JSON.encode({
    activeInvestigatorData = activeInvestigatorData,
    isClassTextureEnabled  = isClassTextureEnabled,
    isDrawButtonVisible    = isDrawButtonVisible,
    optionPanelData        = optionPanelData,
    optionPanelVisibility  = optionPanelVisibility,
    playerColor            = playerColor,
    slotData               = slotData
  })
end

function onLoad(savedData)
  if savedData and savedData ~= "" then
    local loadedData            = JSON.decode(savedData)
    activeInvestigatorData      = loadedData.activeInvestigatorData
    isClassTextureEnabled       = loadedData.isClassTextureEnabled
    isDrawButtonVisible         = loadedData.isDrawButtonVisible
    optionPanelData             = loadedData.optionPanelData
    optionPanelVisibility       = loadedData.optionPanelVisibility
    playerColor                 = loadedData.playerColor
    slotData                    = loadedData.slotData

    -- make sure that edit mode starts disabled
    optionPanelData.slotEditing = false
  end

  updateMessageColor(playerColor)

  -- get object references to owned objects
  ownedObjects = guidReferenceApi.getObjectsByOwner(matColor)

  -- discard button creation
  makeDrawAreaButton()
  for i = 2, 6 do
    makeDiscardButton(i)
  end

  self.createButton({
    click_function = "drawEncounterCard",
    function_owner = self,
    position = { -1.84, 0, -0.65 },
    rotation = { 0, 80, 0 },
    width = 265,
    height = 190
  })

  self.createButton({
    click_function = "drawChaosTokenButton",
    function_owner = self,
    position = { 1.85, 0, -0.74 },
    rotation = { 0, -45, 0 },
    width = 135,
    height = 135
  })

  -- Upkeep button: can use the default parameters for this
  self.createButton(buttonParameters)

  -- Discard 1 button: modified default data
  buttonParameters.label = "Discard 1"
  buttonParameters.click_function = "doDiscardOne"
  buttonParameters.tooltip = "Discard one random card from hand (hidden cards are excluded)."
  buttonParameters.position.z = 0.92
  self.createButton(buttonParameters)

  showDrawButton()
  createXML()
  math.randomseed(os.time())
  Wait.time(function() collisionEnabled = true end, 0.1)
end

---------------------------------------------------------
-- utility functions
---------------------------------------------------------

-- searches an area and optionally filters the result
function searchArea(origin, size, filter)
  return searchLib.inArea(origin, self.getRotation(), size, filter)
end

-- finds all objects on the playermat and associated set aside zone.
function searchAroundSelf(filter)
  local scale = self.getScale()
  local bounds = self.getBoundsNormalized()

  -- Increase the width to cover the set aside zone
  bounds.size.x = bounds.size.x + SEARCH_AROUND_SELF_X_BUFFER
  bounds.size.y = 1
  bounds.size.z = bounds.size.z + SEARCH_AROUND_SELF_Z_BUFFER

  -- 'setAsideDirection' accounts for the set aside zone being on the left or right,
  -- depending on the table position of the playermat
  local setAsideDirection = bounds.center.z > 0 and 1 or -1

  -- Since the cast is centered on the position, shift left or right to keep
  -- the non-set aside edge of the cast at the edge of the playermat
  local localCenter = self.positionToLocal(bounds.center)
  localCenter.x = localCenter.x + setAsideDirection * SEARCH_AROUND_SELF_X_BUFFER / 2 / scale.x
  localCenter.z = localCenter.z - SEARCH_AROUND_SELF_Z_BUFFER / 2 / scale.z
  return searchArea(self.positionToWorld(localCenter), bounds.size, filter)
end

-- searches the area around the draw deck and discard pile
function searchDeckAndDiscardArea(filter)
  local pos = self.positionToWorld(DECK_DISCARD_AREA.center)
  return searchArea(pos, DECK_DISCARD_AREA.size * self.getScale(), filter)
end

-- updates the internal "messageColor" which is used for print/broadcast statements if no player is seated
---@param clickedByColor? string Colorstring of player who clicked a button
function updateMessageColor(clickedByColor)
  if Player[playerColor].seated then
    messageColor = playerColor
  elseif clickedByColor and Player[clickedByColor].seated then
    messageColor = clickedByColor
  else
    messageColor = Player.getPlayers()[1].color
  end
end

---------------------------------------------------------
-- Discard buttons (threat area)
---------------------------------------------------------

-- handles discarding for a list of objects
---@param objList table List of objects to discard
function discardListOfObjects(objList)
  for _, obj in ipairs(objList) do
    if obj.type == "Card" or obj.type == "Deck" then
      if obj.hasTag("PlayerCard") then
        deckLib.placeOrMergeIntoDeck(obj, returnGlobalDiscardPosition(), self.getRotation())
      else
        deckLib.placeOrMergeIntoDeck(obj, ENCOUNTER_DISCARD_POSITION, { x = 0, y = -90, z = 0 })
      end
    elseif tokenChecker.isChaosToken(obj) then
      -- put chaos tokens back into bag (e.g. Unrelenting)
      chaosBagApi.returnChaosTokenToBag(obj, false)
    elseif not obj.getLock() and not obj.hasTag("DontDiscard") and obj.interactable == true then
      -- don't touch locked objects (like the table etc.) or specific objects (like key tokens)
      ownedObjects.Trash.putObject(obj)
    end
  end
end

-- build a discard button to discard from searchPosition
---@param id number Index of the discard button (from left to right, must be unique)
function makeDiscardButton(id)
  local xValue = DISCARD_BUTTON_X_START + (id - 1) * DISCARD_BUTTON_X_OFFSET
  local position = Vector(xValue, 0.1, -0.94)
  local searchPosition = Vector(-position[1], 1, position[3] + 0.32)
  local handlerName = 'handler' .. id
  self.setVar(handlerName, function()
    local cardSizeSearch = Vector(2, 2, 3.2)
    local globalSearchPosition = self.positionToWorld(searchPosition)
    local searchResult = searchArea(globalSearchPosition, cardSizeSearch)
    return discardListOfObjects(searchResult)
  end)
  self.createButton({
    label = "Discard",
    click_function = handlerName,
    function_owner = self,
    position = position,
    scale = { 0.12, 0.12, 0.12 },
    width = 900,
    height = 350,
    font_size = 210
  })
end

-- build a hybrid button to discard from searchPosition or move a card/deck to empty threat area on right click
function makeDrawAreaButton()
  self.createButton({
    label = "Discard / âžœ",
    click_function = "discardOrMove",
    tooltip = "Right-click to move to threat area",
    function_owner = self,
    position = { -1.365, 0.1, -0.94 },
    scale = { 0.12, 0.12, 0.12 },
    width = 1190,
    height = 350,
    font_size = 207
  })
end

function discardOrMove(_, playerColor, isRightClick)
  local searchPosition = Vector(1.365, 1, -0.62)
  local cardSizeSearch = Vector(2, 2, 3.2)
  local globalSearchPosition = self.positionToWorld(searchPosition)
  local searchResult = searchArea(globalSearchPosition, cardSizeSearch)

  if isRightClick then
    local threatAreaPos = getEncounterCardDrawPosition(false)
    if threatAreaPos == getEncounterCardDrawPosition(true) then
      broadcastToColor("Threat area is full.", playerColor, "Yellow")
      return
    end

    for _, obj in ipairs(searchResult) do
      if obj.type == "Card" or obj.type == "Deck" then
        GlobalApi.moveCardWithTokens(obj, threatAreaPos)
      end
    end
  else
    return discardListOfObjects(searchResult)
  end
end

---------------------------------------------------------
-- Upkeep button
---------------------------------------------------------

-- calls the Upkeep function with correct parameter
function doUpkeepFromHotkey(clickedByColor)
  doUpkeep(_, clickedByColor)
end

function doUpkeep(_, clickedByColor, isRightClick)
  updateMessageColor(clickedByColor)

  -- unexhaust cards in play zone, flip action tokens and find Forced Learning / Dream-Enhancing Serum
  local forcedLearning = false
  local rot = self.getRotation()
  for _, obj in ipairs(searchAroundSelf()) do
    if obj.hasTag("Temporary") then
      discardListOfObjects({ obj })
    elseif obj.hasTag("UniversalToken") and obj.is_face_down then
      obj.flip()
    end

    -- call the 'doInUpkeep' function for face-up objects with the respective tag
    if obj.hasTag("DoInUpkeep") and not obj.is_face_down then
      obj.call("doInUpkeep")
    end

    if obj.type == "Card" and not obj.hasTag("Investigator") then -- do not continue for investigator cards
      GlobalApi.maybeReadyCard(obj, rot, false)

      local cardMetadata = JSON.decode(obj.getGMNotes()) or {}

      -- detect Forced Learning to handle card drawing accordingly
      if cardMetadata.id == "08031" then
        forcedLearning = true
      end

      -- maybe replenish uses on certain cards (don't continue for cards on the deck (Norman) or in the discard pile)
      if cardMetadata.uses ~= nil and self.positionToLocal(obj.getPosition()).x > -1 and not obj.is_face_down then
        tokenManagerApi.maybeReplenishCard(obj, cardMetadata.uses, self)
      end
    elseif obj.type == "Deck" and not obj.is_face_down and not forcedLearning then -- check face up decks for forced learning
      for _, deepObj in ipairs(obj.getObjects()) do
        local cardMetadata = JSON.decode(deepObj.gm_notes) or {}
        if cardMetadata.id == "08031" then
          forcedLearning = true
        end
      end
    end
  end

  -- flip investigator mini-card and summoned servitor mini-card
  for _, obj in ipairs(getObjects()) do
    if obj.type == "Card" and obj.is_face_down then
      local md = JSON.decode(obj.getGMNotes()) or {}
      if md.type == "Minicard" and (md.id == activeInvestigatorData.miniId or md.id == "09080-m") then
        obj.flip()
      end
    end
  end

  -- reset action tracker
  GlobalApi.updateActionTrackerTokens(matColor)
  GlobalApi.updateActionTrackerName(matColor)

  if isRightClick then
    printToColor("Skipping resource gain and card draw", messageColor)
    return
  end

  -- gain a resource (or two if playing non-parallel Jenny Barnes)
  if activeInvestigatorData.id == "02003" or activeInvestigatorData.id == "02003-pb" then
    updateCounter({ type = "ResourceCounter", modifier = 2 })
    printToColor("Gaining 2 resources (Jenny)", messageColor)
  else
    updateCounter({ type = "ResourceCounter", modifier = 1 })
  end

  -- draw a card (with handling for Patrice and Forced Learning)
  if activeInvestigatorData.id == "06005" then
    if forcedLearning then
      printToColor("Wow, did you really take 'Versatile' to play Patrice with 'Forced Learning'?"
        .. " Choose which draw replacement effect takes priority and draw cards accordingly.", messageColor)
    else
      -- discards all non-weakness and non-hidden cards from hand first
      local handCards = Player[playerColor].getHandObjects()
      local cardsToDiscard = {}

      for _, card in ipairs(handCards) do
        local md = JSON.decode(card.getGMNotes())
        if card.type == "Card" and md ~= nil and (not md.weakness and not md.hidden and md.id ~= "52020") then
          table.insert(cardsToDiscard, card)
        end
      end

      -- perform discarding 1 by 1
      local pos = returnGlobalDiscardPosition()
      deckLib.placeOrMergeIntoDeck(cardsToDiscard, pos, self.getRotation())

      -- draw up to 5 cards
      local cardsToDraw = 5 - #handCards + #cardsToDiscard
      if cardsToDraw > 0 then
        printToColor("Discarding " .. #cardsToDiscard .. " and drawing " .. cardsToDraw .. " card(s). (Patrice)", messageColor)

        -- add some time if there are any cards to discard
        local k = 0
        if #cardsToDiscard > 0 then
          k = 0.8 + (#cardsToDiscard * 0.1)
        end
        Wait.time(function() drawCardsWithReshuffle(cardsToDraw) end, k)
      end
    end
  elseif forcedLearning then
    printToColor("Drawing 2 cards, discard 1 (Forced Learning)", messageColor)
    drawCardsWithReshuffle(2)
  elseif activeInvestigatorData.id == "89001" then
    printToColor("Drawing 2 cards (Subject 5U-21)", messageColor)
    drawCardsWithReshuffle(2)
  else
    drawCardsWithReshuffle(1)
  end
end

-- click function for "draw 1 button" (that can be added via option panel)
function doDrawOne(_, clickedByColor)
  updateMessageColor(clickedByColor)
  drawCardsWithReshuffle(1)
end

-- draws the specified amount of cards (and shuffles the discard if necessary)
---@param numCards number Number of cards to draw
function drawCardsWithReshuffle(numCards)
  function drawCardsCoroutine()
    local deckAreaObjects = getDeckAreaObjects()

    -- Norman Withers handling
    local harbinger
    if deckAreaObjects.topCard then
      harbinger = isHarbinger(deckAreaObjects.topCard.getGMNotes())
    elseif deckAreaObjects.draw and not deckAreaObjects.draw.is_face_down then
      local cards = deckAreaObjects.draw.getObjects()
      harbinger = isHarbinger(cards[#cards].gm_notes)
    end

    if harbinger then
      printToColor("The Harbinger is on top of your deck, not drawing cards", messageColor)
      return 1
    end

    -- draw the top card if possible
    local topCardDetected = false
    if deckAreaObjects.topCard ~= nil then
      deckAreaObjects.topCard.deal(1, playerColor)
      topCardDetected = true
      numCards = numCards - 1
      if numCards == 0 then
        flipTopCardFromDeck()
        return 1
      end
    end

    -- determine deck size
    local deckSize = 1
    if deckAreaObjects.draw == nil then
      deckSize = 0
    elseif deckAreaObjects.draw.type == "Deck" then
      deckSize = #deckAreaObjects.draw.getObjects()
    end

    -- draw additional cards from existing deck
    if deckSize >= numCards then
      drawCards(deckAreaObjects.draw, numCards)
      if topCardDetected then
        flipTopCardFromDeck()
      end
      return 1
    end

    -- draw the full deck, form a new deck and draw the remaining cards
    drawCards(deckAreaObjects.draw, deckSize)
    if deckAreaObjects.discard ~= nil then
      coWaitFrames(30)
      shuffleDiscardIntoDeck()
      coWaitSeconds(1 * 0.35)

      local shuffledObjects = getDeckAreaObjects()
      drawCards(shuffledObjects.draw, numCards - deckSize)
      if topCardDetected then
        flipTopCardFromDeck()
      end
      printToColor("Take 1 horror (drawing card from empty deck)", messageColor)
    end
    return 1
  end

  startLuaCoroutine(self, "drawCardsCoroutine")
end

function isHarbinger(notes)
  local md = JSON.decode(notes or "") or {}
  return md.id == "08006"
end

-- get the draw deck and discard pile objects and returns the references
---@return table: string-indexed table with references to the found objects
function getDeckAreaObjects()
  local deckAreaObjects = {}
  for _, object in ipairs(searchDeckAndDiscardArea("isCardOrDeck")) do
    if self.positionToLocal(object.getPosition()).z > 0.5 then
      deckAreaObjects.discard = object
      -- Norman Withers handling
    elseif object.type == "Card" and not object.is_face_down then
      deckAreaObjects.topCard = object
    else
      deckAreaObjects.draw = object
    end
  end
  return deckAreaObjects
end

-- draws the specified number of cards (reshuffling of discard pile is handled separately)
---@param cardOrDeck tts__Object Card/Deck to draw from
---@param numCards number Number of cards to draw
function drawCards(cardOrDeck, numCards)
  if cardOrDeck ~= nil then
    cardOrDeck.deal(numCards, playerColor)
  end
end

function shuffleDiscardIntoDeck(player, _, elementId)
  -- update the message color if this was called via button
  if player then
    updateMessageColor(player.color)
  end

  -- get object references
  local deckAreaObjects = getDeckAreaObjects()
  if not deckAreaObjects.discard then
    -- display a feedback message if called via button
    if elementId == "shuffleDiscardButton" then
      broadcastToColor("Discard pile is empty.", messageColor, "Orange")
    end
    return
  end

  -- Norman Withers handling
  local harbinger
  if deckAreaObjects.topCard then
    harbinger = isHarbinger(deckAreaObjects.topCard.getGMNotes())
  elseif deckAreaObjects.draw and not deckAreaObjects.draw.is_face_down then
    local cards = deckAreaObjects.draw.getObjects()
    harbinger = isHarbinger(cards[#cards].gm_notes)
  end

  if harbinger then
    printToColor("The Harbinger is on top of your deck, not shuffling cards into your deck.", messageColor)
    return
  end

  -- create a list of objects to shuffle
  local objectsToShuffle = {}
  if deckAreaObjects.topCard then
    table.insert(objectsToShuffle, deckAreaObjects.topCard)

    -- this will be executed after the deck merging + shuffling
    Wait.time(flipTopCardFromDeck, 0.3)
  end

  table.insert(objectsToShuffle, deckAreaObjects.discard)
  local rot = self.getRotation():setAt("z", 180)
  deckLib.placeOrMergeIntoDeck(objectsToShuffle, self.positionToWorld(DRAW_DECK_POSITION), rot, _, true)
end

-- utility function for Norman Withers to flip the top card to the revealed side
function flipTopCardFromDeck()
  Wait.time(function()
    local deckAreaObjects = getDeckAreaObjects()
    if deckAreaObjects.topCard ~= nil then return end

    if deckAreaObjects.draw ~= nil then
      if deckAreaObjects.draw.type == "Card" then
        deckAreaObjects.draw.flip()
      else
        -- get bounds to know the height of the deck
        local bounds = deckAreaObjects.draw.getBounds()
        local pos = bounds.center + Vector(0, bounds.size.y / 2 + 0.2, 0)
        deckAreaObjects.draw.takeObject({ position = pos, flip = true })
      end
    end
  end, 0.1)
end

-- discard a random non-hidden card from hand
function doDiscardOne(_, clickedByColor)
  updateMessageColor(clickedByColor)

  local hand = Player[playerColor].getHandObjects()
  if #hand == 0 then
    broadcastToColor("Cannot discard from empty hand!", messageColor, "Red")
  else
    local choices = {}
    local hiddenCards = {}
    local missingMetadataCards = {}
    for i, handObj in ipairs(hand) do
      if handObj.type == "Card" then
        -- get a name for the card or use the index if unnamed
        local name = handObj.getName()
        if name == "" then
          name = "Card " .. i
        end

        -- check card for metadata
        local md = JSON.decode(handObj.getGMNotes())
        if md == nil then
          table.insert(missingMetadataCards, name)
        elseif md.hidden or md.id == "52020" then
          table.insert(hiddenCards, name)
        else
          table.insert(choices, i)
        end
      end
    end

    -- print message with hidden cards
    if #hiddenCards > 0 then
      local cardList = concatenateListOfStrings(hiddenCards)
      printToColor("Excluded (hidden): " .. cardList, messageColor)
    end

    -- print message with missing metadata cards
    if #missingMetadataCards > 0 then
      local cardList = concatenateListOfStrings(missingMetadataCards)
      printToColor("Excluded (missing data): " .. cardList, messageColor)
    end

    if #choices == 0 then
      broadcastToColor("Didn't find any eligible cards for random discarding.", messageColor, "Orange")
      return
    end

    -- get a random eligible card (from the "choices" table)
    local num = math.random(1, #choices)
    local card = hand[choices[num]]
    local cardName = card.getName()
    local cardId = choices[num] .. "/" .. #hand

    deckLib.placeOrMergeIntoDeck(card, returnGlobalDiscardPosition(), self.getRotation())
    local playerName = GlobalApi.getColoredName(playerColor)
    broadcastToAll(playerName .. " randomly discarded " .. cardName .. " (" .. cardId .. ").", "White")
  end
end

function concatenateListOfStrings(list)
  local cardList
  for _, cardName in ipairs(list) do
    if not cardList then
      cardList = ""
    else
      cardList = cardList .. ", "
    end
    cardList = cardList .. cardName
  end
  return cardList
end

---------------------------------------------------------
-- XML creation and modifying
---------------------------------------------------------

-- initializes the XML
function createXML()
  local xml = {}

  -- create a panel for each slot symbol
  -- use the snap point positions in the main play area for positions
  local snapId = 0
  for _, snap in ipairs(self.getSnapPoints()) do
    if inArea(snap.position, MAIN_PLAY_AREA) then
      snapId = snapId + 1
      local slotName = slotData[snapId]

      -- conversion from regular coordinates to XML
      local x = snap.position.x * 100
      local y = snap.position.z * 100

      -- XML for a single slot (panel with text in the special font)
      local slotXML = {
        tag = "Panel",
        attributes = {
          id = "slotPanel" .. snapId,
          raycastTarget = "false", -- this disables the click function temporarily
          onClick = "slotClickFunction",
          scale = "0.1 0.1 1",
          width = "350",
          height = "175",
          position = x .. " " .. y .. " -11"
        },
        children = {
          {
            tag = "Text",
            attributes = {
              id = "slot" .. snapId,
              rotation = getSlotRotation(slotName),
              fontSize = "145",
              font = "font_arkhamicons",
              color = "#414141CB",
              text = slotNameToChar[slotName]
            }
          }
        }
      }
      table.insert(xml, slotXML)
    end
  end

  -- create a button for shuffling the discard pile back
  local shuffleDiscardXML = {
    tag = "Button",
    attributes = {
      id = "shuffleDiscardButton",
      onClick = "shuffleDiscardIntoDeck",
      width = "7",
      height = "7",
      position = "-182 30.5 -11",
      rotation = "0 0 180",
      image = "shuffle"
    }
  }
  table.insert(xml, shuffleDiscardXML)

  -- create the personal option panel
  local defaultsXML = {
    tag = "Defaults",
    children = {
      {
        tag = "Text",
        attributes = { color = "#FFFFFF", alignment = "MiddleLeft" }
      },
      {
        tag = "Dropdown",
        attributes = { rectAlignment = "MiddleCenter" }
      },
      {
        tag = "Cell",
        attributes = { dontUseTableCellBackground = "true", outlineSize = "0 1", outline = "grey" }
      }
    }
  }
  table.insert(xml, defaultsXML)

  -- work out the position
  local bounds = self.getBoundsNormalized()
  local setAsideDirection = bounds.center.z > 0 and 1 or -1

  -- create a button to toggle the option panel visibility
  local gearPos
  if setAsideDirection == -1 then
    -- next to upkeep button
    gearPos = "-202 -45 -11"
  else
    -- below encounter card drawing
    gearPos = "203 -21 -11"
  end

  local toggleOptionPanelXML = {
    tag = "Button",
    attributes = {
      onClick = "onClick_hideOrShowOptions",
      width = "7",
      height = "7",
      position = gearPos,
      rotation = "0 0 180",
      image = "option_gear_white"
    }
  }
  table.insert(xml, toggleOptionPanelXML)

  -- work out the size
  local rowHeight = {
    header = 200,
    groupHeader = 150,
    option = 150
  }
  local totalHeight = rowHeight.header
  local scale = 0.11

  -- main window
  local optionPanelXML = {
    tag = "TableLayout",
    attributes = {
      id = "optionPanelMain",
      scale = scale .. " " .. scale,
      width = "1000",
      rotation = "0 0 180",
      active = optionPanelVisibility ~= "",
      visibility = optionPanelVisibility,
      color = "#000000",
      outlineSize = "5 5",
      outline = "grey",
      showAnimation = "SlideIn_Right",
      hideAnimation = "SlideOut_Right",
      animationDuration = "0.2"
    },
    children = {
      -- header
      {
        tag = "Row",
        attributes = { preferredHeight = rowHeight.header },
        children = {
          {
            tag = "Cell",
            children = {
              {
                tag = "Panel",
                attributes = { padding = "30 0 0 0" },
                children = {
                  {
                    tag = "Text",
                    attributes = { font = "font_teutonic-arkham", fontSize = "110", text = "Options" }
                  }
                }
              }
            }
          }
        }
      }
    }
  }

  -- add options groups
  for groupName, groupData in pairs(availableOptions) do
    totalHeight = totalHeight + rowHeight.groupHeader
    -- group header
    local groupXML = {
      tag = "Row",
      attributes = { preferredHeight = rowHeight.groupHeader },
      children = {
        {
          tag = "Cell",
          attributes = { padding = "20 10 0 0", columnSpan = "3", color = "#222222" },
          children = {
            {
              tag = "Panel",
              attributes = { padding = "40 0 0 0" },
              children = {
                {
                  tag = "Text",
                  attributes = { fontSize = "75", font = "font_teutonic-arkham", text = groupName }
                }
              }
            }
          }
        }
      }
    }
    table.insert(optionPanelXML.children, groupXML)

    -- options
    for _, optionData in ipairs(groupData) do
      totalHeight = totalHeight + rowHeight.option
      local optionXML = {
        tag = "Row",
        attributes = { preferredHeight = rowHeight.option },
        children = {
          -- option title
          {
            tag = "Cell",
            attributes = { padding = "20 10 5 5", color = "#333333", columnSpan = "2" },
            children = {
              {
                tag = "Panel",
                attributes = { padding = "50 0 0 0" },
                children = {
                  {
                    tag = "Text",
                    attributes = { fontSize = "65", font = "font_teutonic-arkham", text = optionData.title }
                  }
                }
              }
            }
          },
        }
      }

      local typeXML
      if optionData.type == "toggle" then
        typeXML = {
          tag = "Cell",
          attributes = { padding = "10 10 5 5", color = "#333333" },
          children = {
            {
              tag = "Button",
              attributes = {
                id = optionData.id,
                image = optionPanelData[optionData.id] and "option_on" or "option_off",
                onClick = "onClick_toggleOption",
                rectAlignment = "MiddleRight",
                offsetXY = "-30 0",
                colors = "#FFFFFF|#dfdfdf",
                height = "108",
                width = "195",
                ignoreLayout = "True"
              }
            }
          }
        }
      elseif optionData.type == "button" then
        typeXML = {
          tag = "Cell",
          attributes = { padding = "10 10 5 5", color = "#333333" },
          children = {
            {
              tag = "Button",
              attributes = {
                id = optionData.id,
                image = "option_button",
                onClick = "onClick_" .. optionData.id,
                rectAlignment = "MiddleRight",
                offsetXY = "-30 0",
                colors = "#FFFFFF|#dfdfdf",
                height = "108",
                width = "195",
                ignoreLayout = "True"
              }
            }
          }
        }
      end
      table.insert(optionXML.children, typeXML)
      table.insert(optionPanelXML.children, optionXML)
    end
  end
  table.insert(xml, optionPanelXML)

  -- set correct height
  optionPanelXML.attributes.height = totalHeight

  -- set correct position to align with playermat
  optionPanelXML.attributes.position = (setAsideDirection * 270) .. " " .. (-95 + scale * totalHeight / 2) .. " -65"

  self.UI.setXmlTable(xml)
end

function onClick_hideOrShowOptions(player)
  GlobalApi.changeWindowVisibility(player.color, "optionPanelMain", _, self)
  Wait.frames(function() updateSave() end, 3)
end

-- show the triggering player a dialog to select a playermat texture
function onClick_textureSelect(player)
  local textureList = {}
  for texture, _ in pairs(nameToTexture) do
    table.insert(textureList, texture)
  end
  player.showOptionsDialog("Select a texture:", textureList, _, updateTexture)
end

-- show the triggering player a dialog to select a new hand color for this mat
function onClick_handColorSelect(player)
  local colorList = Player.getColors()

  -- remove existing colors from the list of choices
  for _, existingColor in ipairs(Player.getAvailableColors()) do
    for i, newColor in ipairs(colorList) do
      if existingColor == newColor or newColor == "Black" or newColor == "Grey" then
        table.remove(colorList, i)
      end
    end
  end

  -- show the option dialog for color selection to the player that triggered this
  player.showOptionsDialog("Select a new color:", colorList, _, function(newColor)
    -- update the color of the hand zone
    local handZone = ownedObjects.HandZone
    handZone.setValue(newColor)

    -- update visibility for old and new color
    GlobalApi.changeWindowVisibility(playerColor, "optionPanelMain", _, self)
    GlobalApi.changeWindowVisibility(newColor, "optionPanelMain", _, self)
    navigationOverlayApi.copyVisibility(playerColor, newColor)

    -- if there was a seated player, reseat to the new color
    if Player[playerColor].seated then
      Player[playerColor].changeColor(newColor)
    else
      local colorString = "[" .. Color.fromString(newColor):toHex() .. "]" .. newColor .. "[-]"
      printToColor("Updated handcolor for this playermat to " .. colorString .. ".", player.color)
    end

    -- update the internal variable
    playerColor = newColor
    updateSave()
  end)
end

-- instruct Global to update this mat's hand visibility
function onClick_visibilitySelect(player)
  if player.color == playerColor then
    printToColor("This is meant to be clicked by other players to be able to see your hand " ..
      "(primarily for multi-handed gameplay). It won't do anything for you.", playerColor)
    return
  end

  GlobalApi.handVisibilityToggle(player.color, playerColor)
end

function onClick_visibilityAllSelect()
  for _, possibleColor in ipairs(Player.getColors()) do
    if possibleColor ~= playerColor and possibleColor ~= "Black" then
      GlobalApi.handVisibilityToggle(possibleColor, playerColor)
    end
  end
end

-- changes the UI state and the internal variable for the togglebuttons
function onClick_toggleOption(player, clickType, id)
  updateMessageColor(player.color)
  applyOptionPanelChange(id, not optionPanelData[id], clickType)
end

function applyOptionPanelChange(id, state, clickType)
  if clickType == "-1" then -- left-clicked
    optionPanelData[id] = state
    self.UI.setAttribute(id, "image", state and "option_on" or "option_off")
  end

  if id == "slotEditing" then
    if currentlyEditingSlots and clickType == "-2" then -- right-clicked
      resetSlotSymbols()
    elseif currentlyEditingSlots and clickType == "-3" then -- middle-clicked
      resetSlotSymbols(true)
    elseif clickType == "-1" then -- left-clicked
      toggleSlotEditing()
    end
  end
end

-- updates the XML for the slot symbols based on the slotData table
function updateSlotSymbols()
  for slotId, slotName in ipairs(slotData) do
    -- update the symbol
    self.UI.setAttributes("slot" .. slotId, {
      rotation = getSlotRotation(slotName),
      text = slotNameToChar[slotName]
    })

    -- update availability of the click function
    self.UI.setAttribute("slotPanel" .. slotId, "raycastTarget", currentlyEditingSlots)
  end
end

-- toggle the "slot editing mode"
function toggleSlotEditing()
  currentlyEditingSlots = not currentlyEditingSlots
  updateSlotSymbols()

  if currentlyEditingSlots then
    broadcastToColor("Check chat for instructions", messageColor, "Orange")
    printToColor("Click on a slot symbol (or an empty slot) to edit it. " ..
      "Right-click the 'Slot-Edit' button to return to the default slots. " .. 
      "Middle-click the 'Slot-Edit' button to remove all slot symbols.", messageColor, "White")
  else
    updateSave()
  end
end

-- click function for slot symbols during the "slot editing mode"
function slotClickFunction(player, _, id)
  local slotIndex = id:gsub("slotPanel", "")
  slotIndex = tonumber(slotIndex)

  -- make a list of the table keys as options for the dialog box
  local slotNames = {}
  for slotName, _ in pairs(slotNameToChar) do
    table.insert(slotNames, slotName)
  end

  -- prompt player to choose symbol
  player.showOptionsDialog("Choose Slot Symbol", slotNames, slotData[slotIndex],
    function(chosenSlotName)
      slotData[slotIndex] = chosenSlotName
      updateSlotSymbols()
    end
  )
end

-- helper function to rotate the left hand
function getSlotRotation(slotName)
  if slotName == "Hand (left)" then
    return "0 180 180"
  else
    return "0 0 180"
  end
end

-- reset the slot symbols by making a deep copy of the default data and redrawing
---@param empty? boolean If true, will set the slot symbols to "any" (empty) instead of the defaults
function resetSlotSymbols(empty)
  slotData = {}
  for _, slotName in ipairs(defaultSlotData) do
    table.insert(slotData, empty and "any" or slotName)
  end
  updateSave()
  updateSlotSymbols()
end

function modifySlot(newSlot, cardPosition)
  local slotSnaps = {}
  local snaps = self.getSnapPoints()
  for i, snap in ipairs(snaps) do
    if inArea(snap.position, MAIN_PLAY_AREA) then
      table.insert(slotSnaps, snap)
    end
  end
  cardPosition.y = 0
  for snapId, snap in ipairs(slotSnaps) do
    local snapPosition = Vector(snap.position.x, 0, snap.position.z)
    if snapPosition == cardPosition then
      slotData[snapId] = newSlot
      if Player[playerColor].seated then
        printToColor(newSlot .. " slot added to player mat", playerColor, playerColor)
      else
        local hostColor = Player.getPlayers()[1].color
        printToColor(newSlot .. " slot added to player mat", hostColor, hostColor)
      end
    end
  end
  updateSave()
  updateSlotSymbols()
end

---------------------------------------------------------
-- playermat token spawning
---------------------------------------------------------

-- Finds all customizable cards in this play area and updates their metadata based on the selections
-- on the matching upgrade sheet.
-- This method is theoretically O(n^2), and should be used sparingly.  In practice it will only be
-- called when a checkbox is added or removed in-game (which should be rare), and is bounded by the
-- number of customizable cards in play.
function syncAllCustomizableCards()
  for _, card in ipairs(searchAroundSelf("isCard")) do
    syncCustomizableMetadata(card, JSON.decode(card.getGMNotes()))
  end
end

function syncCustomizableMetadata(card, cardMetadata)
  if cardMetadata == nil or cardMetadata.customizations == nil then return end

  for _, upgradeSheet in ipairs(searchAroundSelf("isCard")) do
    local upgradeSheetMetadata = JSON.decode(upgradeSheet.getGMNotes()) or {}
    if upgradeSheetMetadata.id == (cardMetadata.id .. "-c") then
      for i, customization in ipairs(cardMetadata.customizations) do
        if customization.replaces ~= nil and customization.replaces.uses ~= nil then
          if upgradeSheet.call("isUpgradeActive", i) then
            cardMetadata.uses = customization.replaces.uses
            card.setGMNotes(JSON.encode(cardMetadata))
          else
            -- TODO: Get the original metadata to restore it... maybe.  This should only be
            -- necessary in the very unlikely case that a user un-checks a previously-full upgrade
            -- row while the card is in play.  It will be much easier once the AllPlayerCardsApi is
            -- in place, so defer until it is
          end
        end
      end
    end
  end
end

function spawnTokensFor(object)
  local extraUses = {}

  -- add one additional charge for Akachi Onyele
  if activeInvestigatorData.id == "03004" then
    extraUses["Charge"] = 1
  end

  -- add additional ammo for "Locked and Loaded"
  local md = JSON.decode(object.getGMNotes()) or {}
  if string.find(md.traits or "", "Firearm.") and foundLockedAndLoaded() then
    extraUses["Ammo"] = 1
  end

  tokenManagerApi.spawnForCard(object, extraUses)
end

-- search for "Locked and Loaded"
function foundLockedAndLoaded()
  for _, obj in ipairs(searchAroundSelf("isCardOrDeck")) do
    if obj.type == "Card" then
      local md = JSON.decode(obj.getGMNotes()) or {}
      if md.id == "11030" then
        return true
      end
    elseif obj.type == "Deck" then
      for _, deepObj in ipairs(obj.getObjects()) do
        local cardMetadata = JSON.decode(deepObj.gm_notes) or {}
        if cardMetadata.id == "11030" then
          return true
        end
      end
    end
  end
  return false
end

function onCollisionEnter(collisionInfo)
  local object = collisionInfo.collision_object

  -- only continue if loading is completed
  if not collisionEnabled then return end

  -- only continue for cards
  if object.type ~= "Card" then return end

  -- only continue if card didn't already collide
  if collisionTable[object] ~= nil then return end
  collisionTable[object] = true
  Wait.frames(function() collisionTable[object] = nil end, 1)

  local md = JSON.decode(object.getGMNotes()) or {}
  syncCustomizableMetadata(object, md)

  local localCardPos = self.positionToLocal(object.getPosition())
  if inArea(localCardPos, INVESTIGATOR_AREA) then
    if md.type == "Investigator" and md.id ~= nil then
      maybeUpdateActiveInvestigator(object, md)

      -- this is mostly for helpers like Stella and Kohaku
      spawnTokensOrShowHelper(object)
    end
  elseif inArea(localCardPos, DECK_DISCARD_AREA) then
    tokenSpawnTrackerApi.resetTokensSpawned(object)
    GlobalApi.removeTokensFromObject(object, matColor)
    if md.id == "07224" then luckyPennyEnabled = false end
  elseif object.is_face_down == false then
    -- main uses spawning
    if inArea(localCardPos, MAIN_PLAY_AREA) and (md.type == "Asset" or md.type == "Event") then
      spawnTokensOrShowHelper(object)

      if md.id == "02158" or md.id == "01694" or md.id == "90027" or md.id == "60232" then
        modifySlot("Ally", localCardPos)
      elseif md.id == "02157" or md.id == "01695" then
        modifySlot("Accessory", localCardPos)
      elseif md.id == "10132" then
        modifySlot("Blursed", localCardPos)
      end
    end

    -- encounter types / committed skill cards in the threat area
    if inArea(localCardPos, THREAT_AREA) and (md.type == "Treachery" or md.type == "Enemy" or md.type == "Skill" or md.weakness) then
      spawnTokensOrShowHelper(object)
    end
  end
end

function spawnTokensOrShowHelper(card)
  spawnTokensFor(card)

  if card.hasTag("CardWithHelper") then
    -- get state of the option panel
    local options = GlobalApi.getOptionPanelState()
    if options.enableCardHelpers then
      card.call("setHelperState", true)
    end
  end
end

function onObjectEnterContainer(container, object)
  if object.type ~= "Card" then return end

  local localCardPos = self.positionToLocal(object.getPosition())
  if inArea(localCardPos, DECK_DISCARD_AREA) then
    tokenSpawnTrackerApi.resetTokensSpawned(object)
    GlobalApi.removeTokensFromObject(object, matColor)
    local metadata = JSON.decode(object.getGMNotes()) or {}
    if metadata.id == "07224" then luckyPennyEnabled = false end
  end
end

---------------------------------------------------------
-- investigator ID grabbing and skill tracker
---------------------------------------------------------

-- updates the internal investigator data and performs additional operations if an investigator card is detected
---@param card tts__Object Card that might be an investigator
---@param md table Metadata for the card
function maybeUpdateActiveInvestigator(card, md)
  -- don't continue if this is already the active investigator
  if md.id == activeInvestigatorData.id then return end

  -- extract relevant data from the metadata
  activeInvestigatorData.class = md.class
  activeInvestigatorData.id = md.id
  activeInvestigatorData.miniId = getMiniId(md.id)
  ownedObjects.InvestigatorSkillTracker.call("updateStats", {
    md.willpowerIcons,
    md.intellectIcons,
    md.combatIcons,
    md.agilityIcons
  })
  updateTexture()

  newInvestigatorCallback(md.id)

  -- set proper scale for investigators
  local cardData = card.getData()
  if cardData["SidewaysCard"] == true then
    -- 115% for easier readability
    card.setScale({ 1.15, 1, 1.15 })
  else
    -- Zoop-exported investigators are horizontal cards and TTS scales them differently
    card.setScale({ 0.8214, 1, 0.8214 })
  end

  -- remove old action tokens
  for _, obj in ipairs(searchAroundSelf("isUniversalToken")) do
    obj.destruct()
  end

  -- spawn three regular action tokens
  spawnActionTokens()

  -- spawn additional token (maybe specific for investigator)
  if md.extraToken and md.extraToken ~= "None" then
    local tokenType = "universalActionAbility"
    local rotation = self.getRotation()
    local callbackName = "updateUniversalActionAbilityToken"
    local callbackParams = { class = activeInvestigatorData.class, symbol = activeInvestigatorData.class }

    -- spawn tokens (split string by "|")
    local count = { action = 0, ability = 0 }
    for str in string.gmatch(md.extraToken, "([^|]+)") do
      local type = "action"
      if str == "FreeTrigger" or str == "Reaction" or string.contains(str, "Ability") then
        type = "ability"
      end

      count[type] = count[type] + 1
      if count[type] > 2 then
        printToColor("More than two extra tokens of the same type are not supported.", playerColor)
      else
        local localSpawnPos = tokenSpawnPos[type][count[type]]
        local globalSpawnPos = self.positionToWorld(localSpawnPos):add(Vector(0, 0.2, 0))
        callbackParams.symbol = str
        tokenManagerApi.spawnToken(globalSpawnPos, tokenType, rotation, callbackName, callbackParams)
      end
    end
  end
end

function spawnActionTokens()
  local tokenType = "universalActionAbility"
  local rotation = self.getRotation()
  local callbackName = "updateUniversalActionAbilityToken"
  local callbackParams = { class = activeInvestigatorData.class, symbol = activeInvestigatorData.class }

  for i = 1, 3 do
    local position = self.positionToWorld(Vector(-1.54 + i * 0.17, 0, -0.28)):add(Vector(0, 0.2, 0))
    tokenManagerApi.spawnToken(position, tokenType, rotation, callbackName, callbackParams)
  end
end

-- does something for specific investigators when they are loaded
function newInvestigatorCallback(newId)
  updateMessageColor()
  Wait.frames(function() GlobalApi.updateActionTrackerName(matColor) end, 3)
  Wait.frames(function() GlobalApi.updateActionTrackerTokens(matColor) end, 5)

  -- remove existing object that was placed for a specific investigator
  local obj = guidReferenceApi.getObjectByOwnerAndType(matColor, "InvestigatorSpecifics")
  if obj ~= nil then
    obj.destruct()
    guidReferenceApi.editIndex(matColor, "InvestigatorSpecifics")
  end

  if newId == "01005-p" or newId == "01005-pf" then -- parallel Wendy Adams
    printToColor("Wendy Adams: There's a Game Key to add sealing options to any card:" ..
      " Top menu bar > Options > Game Keys", messageColor)
  elseif newId == "06003" then -- Tony Morgan
    spawnInfiniteTokenBag("bounty")
    printToColor("Tony Morgan: Spawned bounty tokens near your playermat.", messageColor)
  elseif newId == "08004" then -- Norman Withers
    printToColor("Norman Withers: At the start of the game flip the top card of your deck manually " ..
      "and then the mod should keep it flipped throughout the game.", messageColor)
  elseif newId == "09015" then -- Darrell Simmons
    spawnInfiniteTokenBag("evidence")
    printToColor("Darrell Simmons: Spawned evidence tokens near your playermat.", messageColor)
  elseif newId == "89001" then -- Subject 5U-21
    local pos = zones.getZonePosition(playerColor, "BelowSetAside")
    local rot = self.getRotation()
    local sourceBag = guidReferenceApi.getObjectByOwnerAndType("Mythos", "ObjectSourceBag")
    for _, objData in ipairs(sourceBag.getData().ContainedObjects) do
      if objData["Nickname"] == "Subject 5U-21 Helper" then
        local spawnedObj = spawnObjectData({ data = objData, position = pos, rotation = rot })
        guidReferenceApi.editIndex(matColor, "InvestigatorSpecifics", spawnedObj.getGUID())
        break
      end
    end
    printToColor("Subject 5U-21: Spawned a helper to track the classes of devoured cards near your playermat. " ..
      "Note that this and 'Ravenous' will work with the Attachment Helper from the option panel.", messageColor)
  end
end

-- spawns an infinite token bag of the specified type near the set aside area
function spawnInfiniteTokenBag(tokenType)
  local pos = zones.getZonePosition(matColor, "AboveSetAside")
  local rot = self.getRotation()
  local spawnedObj = spawnObjectData({ data = tokenManagerApi.getDataForInfiniteBag(tokenType, pos, rot) })
  guidReferenceApi.editIndex(matColor, "InvestigatorSpecifics", spawnedObj.getGUID())
end

-- returns the mini ID for the currently placed investigator
function getMiniId(baseId)
  if #baseId < 16 then
    -- use the first 5 characters to exclude suffixes
    return string.match(baseId, ".....") .. "-m"
  else
    -- use the full ID (long -> assume it's from Zoop)
    return baseId .. "-m"
  end
end

-- updates the texture of the playermat
---@param overrideName? string Force a specific texture
function updateTexture(overrideName)
  updateSave()

  local name = "Neutral"

  -- use class specific texture if enabled
  if isClassTextureEnabled then
    name = activeInvestigatorData.class
  end

  -- get new texture URL
  local newUrl = nameToTexture[name]

  -- override name if valid
  if nameToTexture[overrideName] then
    newUrl = nameToTexture[overrideName]
  end

  -- apply texture
  local customInfo = self.getCustomObject()
  if customInfo.image ~= newUrl then
    -- make sure objects are resting and store position
    local objectsToUnlock = {}
    for _, obj in ipairs(searchAroundSelf()) do
      if not obj.getLock() then
        obj.resting = true
        table.insert(objectsToUnlock, { obj = obj, pos = obj.getPosition() })
      end
    end

    customInfo.image = newUrl
    ---@diagnostic disable-next-line: param-type-mismatch
    self.setCustomObject(customInfo)
    local reloadedMat = self.reload()

    -- restore object positions
    Wait.condition(function()
      Wait.frames(function()
        for _, objTable in ipairs(objectsToUnlock) do
          if objTable.obj ~= nil then
            objTable.obj.resting = true
            objTable.obj.setPosition(objTable.pos)
          end
        end
      end, 5)
    end, function() return reloadedMat.loading_custom == false end)
  end
end

---------------------------------------------------------
-- manipulation of owned objects
---------------------------------------------------------

-- updates the specified owned counter
---@param param table Contains the information to update:
---   type: String Counter to target
---   newValue: Number Value to set the counter to
---   modifier: Number If newValue is not provided, the existing value will be adjusted by this modifier
function updateCounter(param)
  local counter = ownedObjects[param.type]
  if counter ~= nil then
    counter.call("updateVal", param.newValue or (counter.getVar("val") + param.modifier))
  else
    printToAll(param.type .. " for " .. matColor .. " could not be found.", "Yellow")
  end
end

-- get the value the specified owned counter
---@param type string Counter to target
---@return number: Counter value
function getCounterValue(type)
  return ownedObjects[type].getVar("val")
end

-- set investigator skill tracker to "1, 1, 1, 1"
function resetSkillTracker()
  local obj = ownedObjects.InvestigatorSkillTracker
  if obj ~= nil then
    obj.call("updateStats", { 1, 1, 1, 1 })
  else
    printToAll("Skill tracker for " .. matColor .. " playermat could not be found.", "Yellow")
  end
end

---------------------------------------------------------
-- calls to 'Global' / functions for calls from outside
---------------------------------------------------------

function drawChaosTokenButton(_, _, isRightClick)
  chaosBagApi.drawChaosToken(self, isRightClick)
end

function drawEncounterCard(_, _, isRightClick)
  local drawPos = getEncounterCardDrawPosition(not isRightClick)
  mythosAreaApi.drawEncounterCard(matColor, drawPos)
end

function returnGlobalDiscardPosition()
  return self.positionToWorld(DISCARD_PILE_POSITION)
end

function returnGlobalDrawPosition()
  return self.positionToWorld(DRAW_DECK_POSITION)
end

-- returns the position for encounter card drawing
---@param stack boolean If true, returns the leftmost position instead of the first empty from the right
function getEncounterCardDrawPosition(stack)
  local drawPos = self.positionToWorld(DRAWN_ENCOUNTER_POSITION)

  -- maybe override position with first empty slot in threat area (right to left)
  if not stack then
    local searchPos = Vector(-0.91, 0.5, -0.625)
    for i = 1, 5 do
      local globalSearchPos = self.positionToWorld(searchPos)
      local searchResult = searchLib.atPosition(globalSearchPos, "isCardOrDeck")
      if #searchResult == 0 then
        drawPos = globalSearchPos
        break
      else
        searchPos.x = searchPos.x + 0.455
      end
    end
  end

  return drawPos
end

-- creates / removes the draw 1 button
---@param visible? boolean Whether the draw 1 button should be visible
function showDrawButton(visible)
  if visible ~= nil then
    isDrawButtonVisible = visible
    updateSave()
  end

  if isDrawButtonVisible then
    -- Draw 1 button: modified default data
    buttonParameters.label = "Draw 1"
    buttonParameters.click_function = "doDrawOne"
    buttonParameters.tooltip = ""
    buttonParameters.position.z = -0.35
    self.createButton(buttonParameters)
  else
    local buttons = self.getButtons()
    for i = 1, #buttons do
      if buttons[i].label == "Draw 1" then
        self.removeButton(buttons[i].index)
      end
    end
  end
end

-- shows / hides a clickable clue counter for this playermat and sets the correct amount of clues
---@param showCounter boolean Whether the clickable clue counter should be visible
function clickableClues(showCounter)
  local clickerPos = ownedObjects.ClickableClueCounter.getPosition()
  local clueCount = 0

  -- move clue counters
  local modY = showCounter and 0.525 or -0.525
  ownedObjects.ClickableClueCounter.setPosition(clickerPos + Vector(0, modY, 0))

  if showCounter then
    -- get current clue count
    clueCount = ownedObjects.ClueCounter.getVar("exposedValue")

    -- remove clues
    ownedObjects.ClueCounter.call("removeAllClues", ownedObjects.Trash)

    -- set value for clue clickers
    ownedObjects.ClickableClueCounter.call("updateVal", clueCount)
  else
    -- get current clue count
    clueCount = ownedObjects.ClickableClueCounter.getVar("val")

    -- spawn clues
    local pos = self.positionToWorld({ x = -1.12, y = 0.05, z = 0.7 })
    for i = 1, clueCount do
      pos.y = pos.y + 0.045 * i
      tokenManagerApi.spawnToken(pos, "clue", self.getRotation())
    end
  end
end

-- Toggles the use of class textures
---@param state boolean Whether the class texture should be used or not
function useClassTexture(state)
  if state == isClassTextureEnabled then return end
  isClassTextureEnabled = state
  updateTexture()
end

-- removes all clues (moving tokens to the trash and setting counters to 0)
function removeClues()
  ownedObjects.ClueCounter.call("removeAllClues", ownedObjects.Trash)
  ownedObjects.ClickableClueCounter.call("updateVal", 0)
end

-- reports the clue count
---@param useClickableCounters boolean Controls which type of counter is getting checked
function getClueCount(useClickableCounters)
  if useClickableCounters then
    return ownedObjects.ClickableClueCounter.getVar("val")
  else
    return ownedObjects.ClueCounter.getVar("exposedValue")
  end
end

-- Sets this playermat's snap points to limit snapping to matching card types or not. If matchTypes
-- is true, the main card slot snap points will only snap assets, while the investigator area point
-- will only snap Investigators. If matchTypes is false, snap points will be reset to snap all cards.
---@param matchTypes boolean Whether snap points should only snap for the matching card types.
function setLimitSnapsByType(matchTypes)
  local snaps = self.getSnapPoints()
  for i, snap in ipairs(snaps) do
    if inArea(snap.position, MAIN_PLAY_AREA) then
      local snapTags = snaps[i].tags
      if matchTypes then
        if snapTags == nil then
          snaps[i].tags = { "Asset" }
        else
          table.insert(snaps[i].tags, "Asset")
        end
      else
        snaps[i].tags = nil
      end
    end
    if inArea(snap.position, INVESTIGATOR_AREA) then
      local snapTags = snaps[i].tags
      if matchTypes then
        if snapTags == nil then
          snaps[i].tags = { "Investigator" }
        else
          table.insert(snaps[i].tags, "Investigator")
        end
      else
        snaps[i].tags = nil
      end
    end
  end
  self.setSnapPoints(snaps)
end

-- Simple method to check if the given point is in a specified area. Local use only
---@param point tts__Vector Point to check, only x and z values are relevant
---@param bounds table Defined area to see if the point is within. See MAIN_PLAY_AREA for sample bounds definition.
---@return boolean: True if the point is in the area defined by bounds
function inArea(point, bounds)
  return (point.x < bounds.upperLeft.x
    and point.x > bounds.lowerRight.x
    and point.z < bounds.upperLeft.z
    and point.z > bounds.lowerRight.z)
end

-- called by custom data helpers to add player card data
---@param args table Contains only one entry, the GUID of the custom data helper
function updatePlayerCards(args)
  local customDataHelper = getObjectFromGUID(args[1])
  local playerCardData = customDataHelper.getTable("PLAYER_CARD_DATA")
  tokenManagerApi.addPlayerCardData(playerCardData)
end

function getActiveInvestigatorData() return activeInvestigatorData end

function setActiveInvestigatorData(newData) activeInvestigatorData = newData end

-- pauses the current coroutine for 'frameCount' frames
function coWaitFrames(frameCount)
  for k = 1, frameCount do
    coroutine.yield(0)
  end
end

-- pauses the current coroutine for 'seconds' seconds
function coWaitSeconds(seconds)
  local startTime = os.clock()
  while os.clock() - startTime < seconds do
    coroutine.yield(0)
  end
end
