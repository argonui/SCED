do
  local PlayermatApi              = {}
  local GUIDReferenceApi          = require("core/GUIDReferenceApi")
  local SearchLib                 = require("util/SearchLib")
  local localInvestigatorPosition = Vector(-1.17, 1, -0.01)

  -- General notes:
  -------------------------------------------------------------------
  -- "matColor" is a string that describes the internal "color" of each mat
  -- (the starting color when the game is first loaded)
  -- Some functions will support the additional "All" pseudo-color to trigger that code for each mat
  -- If a function does not support "All", there will be a comment
  -------------------------------------------------------------------
  -- "playerColor" (or "handColor") is a string that describes the actual color of the seat
  -------------------------------------------------------------------

  -- Convenience function to look up a mat's object by color, or get all mats
  local function getMatForColor(matColor)
    if matColor == "All" then
      return GUIDReferenceApi.getObjectsByType("Playermat") or {}
    else
      return { matColor = GUIDReferenceApi.getObjectByOwnerAndType(matColor, "Playermat") }
    end
  end

  -- Convenience function to call a function on a single mat
  ---@param matColor string Does not support "All"
  ---@param funcName string Name of the function to call
  ---@param params any Parameter for the call
  local function callForSingleMat(matColor, funcName, params)
    for _, mat in pairs(getMatForColor(matColor)) do
      return mat.call(funcName, params)
    end
  end

  -- Returns the color of the closest playermat
  ---@param startPos table Starting position to get the closest mat from
  function PlayermatApi.getMatColorByPosition(startPos)
    local result, smallestDistance
    for matColor, mat in pairs(getMatForColor("All")) do
      local distance = Vector.between(startPos, mat.getPosition()):magnitude()
      if smallestDistance == nil or distance < smallestDistance then
        smallestDistance = distance
        result = matColor
      end
    end
    return result
  end

  -- Returns the color of the player's hand that is seated next to the playermat
  ---@param matColor string Does not support "All"
  function PlayermatApi.getPlayerColor(matColor)
    for _, mat in pairs(getMatForColor(matColor)) do
      return mat.getVar("playerColor")
    end
    return nil
  end

  -- Returns the color of the playermat that owns the playercolor's hand
  ---@param handColor string Color of the playermat
  function PlayermatApi.getMatColor(handColor)
    for matColor, mat in pairs(getMatForColor("All")) do
      if mat.getVar("playerColor") == handColor then
        return matColor
      end
    end
  end

  -- Gets the slot data for the playermat
  ---@param matColor string Does not support "All"
  function PlayermatApi.getSlotData(matColor)
    for _, mat in pairs(getMatForColor(matColor)) do
      return mat.getTable("slotData")
    end
  end

  -- Sets the slot data for the playermat
  ---@param matColor string Does not support "All"
  ---@param newSlotData table New slot data for the playermat
  function PlayermatApi.loadSlotData(matColor, newSlotData)
    return callForSingleMat(matColor, "updateSlotSymbols", newSlotData)
  end

  -- Performs a search of the deck area of the requested playermat and returns the result as table
  ---@param matColor string Does not support "All"
  function PlayermatApi.getDeckAreaObjects(matColor)
    return callForSingleMat(matColor, "getDeckAreaObjects")
  end

  -- Flips the top card of the deck (useful after deck manipulation for Norman Withers)
  ---@param matColor string Does not support "All"
  ---@param additionalDelay? number Additional delay for this function
  function PlayermatApi.flipTopCardFromDeck(matColor, additionalDelay)
    return callForSingleMat(matColor, "flipTopCardFromDeck", additionalDelay)
  end

  -- Returns the position of the discard pile of the requested playermat
  ---@param matColor string Does not support "All"
  function PlayermatApi.getDiscardPosition(matColor)
    return Vector(callForSingleMat(matColor, "returnGlobalDiscardPosition"))
  end

  -- Returns the position of the draw pile of the requested playermat
  ---@param matColor string Does not support "All"
  function PlayermatApi.getDrawPosition(matColor)
    return Vector(callForSingleMat(matColor, "returnGlobalDrawPosition"))
  end

  -- Transforms a local position into a global position
  ---@param localPos table Local position to be transformed
  ---@param matColor string Does not support "All"
  function PlayermatApi.transformLocalPosition(localPos, matColor)
    for _, mat in pairs(getMatForColor(matColor)) do
      return mat.positionToWorld(localPos)
    end
  end

  -- Returns the rotation of the requested playermat
  ---@param matColor string Does not support "All"
  function PlayermatApi.returnRotation(matColor)
    for _, mat in pairs(getMatForColor(matColor)) do
      return mat.getRotation()
    end
  end

  -- Returns a table with spawn data (position and rotation) for a helper object
  ---@param helperName string Name of the helper object
  function PlayermatApi.getHelperSpawnData(matColor, helperName)
    local resultTable = {}
    for color, mat in pairs(getMatForColor(matColor)) do
      local data = mat.call("getHelperSpawnData", helperName)
      resultTable[color] = { position = Vector(data.position), rotation = Vector(data.rotation) }
    end
    return resultTable
  end

  -- Triggers the Upkeep for the requested playermat
  ---@param playerColor string Color of the calling player (for messages)
  function PlayermatApi.doUpkeepFromHotkey(matColor, playerColor)
    for _, mat in pairs(getMatForColor(matColor)) do
      mat.call("doUpkeepFromHotkey", playerColor)
    end
  end

  -- Triggers the Discard One function for the requested playermat
  ---@param playerColor string Color of the calling player (for messages)
  function PlayermatApi.doDiscardOneFromHotkey(matColor, playerColor)
    for _, mat in pairs(getMatForColor(matColor)) do
      mat.call("doDiscardOneFromHotkey", playerColor)
    end
  end

  -- Gets data about the active investigator
  ---@param matColor string Does not support "All"
  function PlayermatApi.getActiveInvestigatorData(matColor)
    return callForSingleMat(matColor, "getActiveInvestigatorData")
  end

  -- Sets data about the active investigator
  ---@param newData table New active investigator data (class and id)
  function PlayermatApi.setActiveInvestigatorData(matColor, newData)
    for _, mat in pairs(getMatForColor(matColor)) do
      mat.call("setActiveInvestigatorData", newData)
    end
  end

  -- Returns the position for encounter card drawing
  ---@param matColor string Does not support "All"
  ---@param stack boolean If true, returns the leftmost position instead of the first empty from the right
  function PlayermatApi.getEncounterCardDrawPosition(matColor, stack)
    return Vector(callForSingleMat(matColor, "getEncounterCardDrawPosition", stack))
  end

  -- Sets the requested playermat's snap points to limit snapping to matching card types or not
  ---@param matchCardTypes boolean Whether snap points should only snap for the matching card types
  function PlayermatApi.setLimitSnapsByType(matchCardTypes, matColor)
    return callForSingleMat(matColor, "setLimitSnapsByType", matchCardTypes)
  end

  -- Sets the requested playermat's draw 1 button to visible
  ---@param isDrawButtonVisible boolean Whether the draw 1 button should be visible or not
  function PlayermatApi.showDrawButton(isDrawButtonVisible, matColor)
    for _, mat in pairs(getMatForColor(matColor)) do
      mat.call("showDrawButton", isDrawButtonVisible)
    end
  end

  -- Updates clue counts to account for clickable clue counters
  ---@param showCounter boolean Whether the clickable counter should be present or not
  function PlayermatApi.clickableClues(showCounter, matColor)
    for _, mat in pairs(getMatForColor(matColor)) do
      mat.call("clickableClues", showCounter)
    end
  end

  -- Toggles the use of class textures for the requested playermat
  ---@param state boolean Whether the class texture should be used or not
  function PlayermatApi.useClassTexture(state, matColor)
    for _, mat in pairs(getMatForColor(matColor)) do
      mat.call("useClassTexture", state)
    end
  end

  -- updates the texture of the playermat
  ---@param overrideName? string Force a specific texture
  function PlayermatApi.updateTexture(matColor, overrideName)
    for _, mat in pairs(getMatForColor(matColor)) do
      mat.call("updateTexture", overrideName)
    end
  end

  -- Removes clues (to the trash for tokens and counters set to 0) for the requested playermat
  ---@param number? number Number of clues to remove (defaults to all)
  function PlayermatApi.removeClues(matColor, number)
    for _, mat in pairs(getMatForColor(matColor)) do
      mat.call("removeClues", number)
    end
  end

  -- Reports the clue count for the requested playermat
  function PlayermatApi.getClueCount(matColor)
    local total       = 0
    local playerClues = {}
    for matColor2, mat in pairs(getMatForColor(matColor)) do
      local count            = (mat.call("getClueCount") or 0)
      total                  = total + count
      playerClues[matColor2] = count
    end
    return total, playerClues
  end

  -- Reports the doom count for the requested playermat
  function PlayermatApi.getDoomCount(matColor)
    local count = 0
    for _, mat in pairs(getMatForColor(matColor)) do
      count = count + (mat.call("getDoomCount") or 0)
    end
    return count
  end

  -- Updates the specified owned counter
  ---@param type string Counter to target
  ---@param newValue number Value to set the counter to
  ---@param modifier number If newValue is not provided, the existing value will be adjusted by this modifier
  function PlayermatApi.updateCounter(matColor, type, newValue, modifier)
    for _, mat in pairs(getMatForColor(matColor)) do
      mat.call("updateCounter", { type = type, newValue = newValue, modifier = modifier })
    end
  end

  -- Triggers the draw function for the specified playermat
  ---@param number number Amount of cards to draw
  function PlayermatApi.drawCardsWithReshuffle(matColor, number, alt)
    for _, mat in pairs(getMatForColor(matColor)) do
      mat.call("drawCardsWithReshuffleWrapper", { numCards = number, fromBottom = alt })
    end
  end

  -- Updates the internal "messageColor" which is used for print/broadcast statements if no player is seated
  ---@param newMessageColor? string Colorstring of player who clicked a button
  function PlayermatApi.updateMessageColor(matColor, newMessageColor)
    for _, mat in pairs(getMatForColor(matColor)) do
      mat.call("updateMessageColor", newMessageColor)
    end
  end

  -- Returns the current message color
  ---@param matColor string Does not support "All"
  function PlayermatApi.getMessageColor(matColor)
    for _, mat in pairs(getMatForColor(matColor)) do
      return mat.call("getMessageColor")
    end
  end

  -- Returns the value of an owned counter (e.g. ResourceCounter, DamageCounter, HorrorCounter)
  ---@param matColor string Does not support "All"
  ---@param type string Counter to target
  function PlayermatApi.getCounterValue(matColor, type)
    return callForSingleMat(matColor, "getCounterValue", type)
  end

  -- Returns a list of mat colors that have an investigator placed
  function PlayermatApi.getUsedMatColors()
    local usedColors = {}
    for matColor, card in pairs(PlayermatApi.getUsedInvestigatorCards()) do
      table.insert(usedColors, matColor)
    end
    return usedColors
  end

  -- Returns a list of investigator card objects
  function PlayermatApi.getUsedInvestigatorCards()
    local usedCards = {}
    for matColor, mat in pairs(getMatForColor("All")) do
      local searchPos = mat.positionToWorld(localInvestigatorPosition)
      local searchResult = SearchLib.atPosition(searchPos, "isCardOrDeck")
      if #searchResult > 0 then
        usedCards[matColor] = searchResult[1]
      end
    end
    return usedCards
  end

  -- Returns investigator name
  ---@param matColor string Does not support "All"
  function PlayermatApi.getInvestigatorName(matColor)
    for _, mat in pairs(getMatForColor(matColor)) do
      local searchPos = mat.positionToWorld(localInvestigatorPosition)
      local searchResult = SearchLib.atPosition(searchPos, "isCardOrDeck")
      if #searchResult == 1 then
        return searchResult[1].getName()
      end
    end
    return ""
  end

  -- Trigger the onCollisionEnter event remotely
  ---@param matColor string Does not support "All"
  function PlayermatApi.onCollisionEnter(matColor, collisionInfo)
    return callForSingleMat(matColor, "onCollisionEnter", collisionInfo)
  end

  -- Finds all objects on the playermat and associated set aside zone and returns a table
  ---@param filter? string Name of the filte function (see util/SearchLib)
  function PlayermatApi.searchAroundPlayermat(matColor, filter)
    local objList = {}
    for _, mat in pairs(getMatForColor(matColor)) do
      for _, obj in ipairs(mat.call("searchAroundSelf", filter)) do
        table.insert(objList, obj)
      end
    end
    return objList
  end

  -- Spawns the regular action tokens
  function PlayermatApi.spawnActionTokens(matColor)
    for _, mat in pairs(getMatForColor(matColor)) do
      mat.call("spawnActionTokens")
    end
  end

  -- Triggers the metadata sync for all playermats
  function PlayermatApi.syncAllCustomizableCards()
    for _, mat in pairs(getMatForColor("All")) do
      mat.call("syncAllCustomizableCards")
    end
  end

  -- Gets the value of an option set in the mat's option panel
  ---@param matColor string Does not support "All"
  ---@param setting string Name of the setting to retrieve
  function PlayermatApi.getOptionPanelSetting(matColor, setting)
    return callForSingleMat(matColor, "getOptionPanelSetting", setting)
  end

  -- Gets the exhaust rotation that's set in the mat's option panel
  ---@param matColor string Does not support "All"
  ---@param convertToGlobal? boolean True if the global (Vector) rotation is requested (otherwise just local Y-rotation)
  function PlayermatApi.getExhaustRotation(matColor, convertToGlobal)
    return callForSingleMat(matColor, "getExhaustRotation", convertToGlobal)
  end

  -- moves + rotates a playermat (and related objects)
  ---@param position? table New position for the playermat
  ---@param rotationY? number New y-rotation for the playermat (X and Z will be 0)
  ---@param positionOffset? table Positional offset for the playermat
  function PlayermatApi.moveAndRotate(matColor, position, rotationY, positionOffset)
    local params = { position = position, rotationY = rotationY, positionOffset = positionOffset }
    return callForSingleMat(matColor, "moveAndRotateSelf", params)
  end

  -- Instructs the playermat to not touch the regular action tokens for the next investigator change
  function PlayermatApi.activateTransformEffect(matColor)
    return callForSingleMat(matColor, "activateTransformEffect")
  end

  return PlayermatApi
end
