require("arkhamdb/DeckImporterUi")
require("playercards/PlayerCardSpawner")

local playAreaApi = require("core/PlayAreaApi")
local arkhamDb = require("arkhamdb/ArkhamDb")
local zones = require("playermat/Zones")

local DEBUG = false

local ALL_CARDS_GUID = "15bb07"

local customizationRowsWithFields = { }
-- inputMap maps from (our 1-indexes) customization row index to inputValue table index
-- The Raven Quill
customizationRowsWithFields["09042"] = {}
customizationRowsWithFields["09042"].inputCount = 2
customizationRowsWithFields["09042"].inputMap = {}
customizationRowsWithFields["09042"].inputMap[1] = 1
customizationRowsWithFields["09042"].inputMap[5] = 2
-- Friends in Low Places
customizationRowsWithFields["09060"] = {}
customizationRowsWithFields["09060"].inputCount = 2
customizationRowsWithFields["09060"].inputMap = {}
customizationRowsWithFields["09060"].inputMap[1] = 1
customizationRowsWithFields["09060"].inputMap[3] = 2
-- Living Ink
customizationRowsWithFields["09079"] = {}
customizationRowsWithFields["09079"].inputCount = 3
customizationRowsWithFields["09079"].inputMap = {}
customizationRowsWithFields["09079"].inputMap[1] = 1
customizationRowsWithFields["09079"].inputMap[5] = 2
customizationRowsWithFields["09079"].inputMap[6] = 3
-- Grizzled
customizationRowsWithFields["09101"] = {}
customizationRowsWithFields["09101"].inputCount = 3
customizationRowsWithFields["09101"].inputMap = {}
customizationRowsWithFields["09101"].inputMap[1] = 1
customizationRowsWithFields["09101"].inputMap[2] = 2
customizationRowsWithFields["09101"].inputMap[3] = 3

local function fixUtf16String(str)
  return str:gsub("\\u(%w%w%w%w)", function(match)
    return string.char(tonumber(match, 16))
  end)
end

function onLoad(script_state)
  local state = JSON.decode(script_state)
  initializeUi(state)
  math.randomseed(os.time())
  arkhamDb.initialize()
end

function onSave() return JSON.encode(getUiState()) end

-- Returns the zone name where the specified card should be placed, based on its metadata.
---@param cardMetadata Table of card metadata.
---@return Zone name such as "Deck", "SetAside1", etc. See Zones object documentation for a list of
---    valid zones.
function getDefaultCardZone(cardMetadata, bondedList)
  if (cardMetadata.id == "09080-m") then -- Have to check the Servitor before other minicards
    return "SetAside6"
  elseif (cardMetadata.id == "09006") then -- On The Mend is set aside
    return "SetAside2"
  elseif cardMetadata.type == "Investigator" then
    return "Investigator"
  elseif cardMetadata.type == "Minicard" then
    return "Minicard"
  elseif cardMetadata.type == "UpgradeSheet" then
    return "SetAside4"
  elseif cardMetadata.startsInPlay then
    return "BlankTop"
  elseif cardMetadata.permanent then
    return "SetAside1"
  elseif bondedList[cardMetadata.id] then
    return "SetAside2"
    -- SetAside3 is used for Ancestral Knowledge / Underworld Market
  else
    return "Deck"
  end
end

function buildDeck(playerColor, deckId)
  local uiState = getUiState()
  arkhamDb.getDecklist(
      playerColor,
      deckId,
      uiState.private,
      uiState.loadNewest,
      uiState.investigators,
      loadCards)
end

-- Process the slot list, which defines the card Ids and counts of cards to load. Spawn those cards
-- at the appropriate zones and report an error to the user if any could not be loaded.
-- This is a callback function which handles the results of ArkhamDb.getDecklist()
-- This method uses an encapsulated coroutine with yields to make the card spawning cleaner.
--
---@param slots Key-Value table of cardId:count. cardId is the ArkhamDB ID of the card to spawn,
---    and count is the number which should be spawned
---@param investigatorId String ArkhamDB ID (code) for this deck's investigator.
--     Investigator cards should already be added to the slots list if they
--     should be spawned, but this value is separate to check for special
--     handling for certain investigators
---@param bondedList A table of cardID keys to meaningless values.  Card IDs in this list were added
---    from a parent bonded card.
---@param customizations ArkhamDB data for customizations on customizable cards
---@param playerColor String Color name of the player mat to place this deck on (e.g. "Red")
function loadCards(slots, investigatorId, bondedList, customizations, playerColor)
  function coinside()
    local allCardsBag = getObjectFromGUID(ALL_CARDS_GUID)
    local yPos = {}
    local cardsToSpawn = {}
    for cardId, cardCount in pairs(slots) do
      local card = allCardsBag.call("getCardById", { id = cardId })
      if card ~= nil then
        local cardZone = getDefaultCardZone(card.metadata, bondedList)
        for i = 1, cardCount do
          table.insert(cardsToSpawn, { data = card.data, metadata = card.metadata, zone = cardZone })
        end

        slots[cardId] = 0
      end
    end

    handleAncestralKnowledge(cardsToSpawn)
    handleUnderworldMarket(cardsToSpawn, playerColor)
    handleHunchDeck(investigatorId, cardsToSpawn, playerColor)
    handleCustomizableUpgrades(cardsToSpawn, customizations)

    -- Split the card list into separate lists for each zone
    local zoneDecks = buildZoneLists(cardsToSpawn)
    -- Spawn the list for each zone
    for zone, zoneCards in pairs(zoneDecks) do
      local deckPos = zones.getZonePosition(playerColor, zone)
      deckPos.y = 3

      local callback = nil
      -- If cards are spread too close together TTS groups them weirdly, selecting multiples
      -- when hovering over a single card.  This distance is the minimum to avoid that
      local spreadDistance = 1.15
      if (zone == "SetAside4") then
        -- SetAside4 is reserved for customization cards, and we want them spread on the table
        -- so their checkboxes are visible
        if (playerColor == "White") then
          deckPos.z = deckPos.z + (#zoneCards - 1) * spreadDistance
        elseif (playerColor == "Green") then
          deckPos.x = deckPos.x + (#zoneCards - 1) * spreadDistance
        end
        callback = function(deck) deck.spread(spreadDistance) end
      elseif zone == "Deck" then
        callback = function(deck) deckSpawned(deck, playerColor) end
      end
      Spawner.spawnCards(
          zoneCards,
          deckPos,
          zones.getDefaultCardRotation(playerColor, zone),
          true, -- Sort deck
          callback)

      coroutine.yield(0)
    end

    -- Look for any cards which haven't been loaded
    local hadError = false
    for cardId, remainingCount in pairs(slots) do
      if remainingCount > 0 then
        hadError = true
        arkhamDb.logCardNotFound(cardId, playerColor)
      end
    end
    if (not hadError) then
      printToAll("Deck loaded successfully!", playerColor)
    end
    return 1
  end

  startLuaCoroutine(self, "coinside")
end

-- Callback handler for the main deck spawning.  Looks for cards which should start in hand, and
-- draws them for the appropriate player.
-- @param deck Callback-provided spawned deck object
-- @param playerColor Color of the player to draw the cards to
function deckSpawned(deck, playerColor)
  local handPos = Player[playerColor].getHandTransform(1).position -- Only one hand zone per player
  local deckCards = deck.getData().ContainedObjects
  -- Process in reverse order so taking cards out doesn't upset the indexing
  for i = #deckCards, 1, -1 do
    local cardMetadata = JSON.decode(deckCards[i].GMNotes) or { }
    if cardMetadata.startsInHand then
      deck.takeObject({ index = i - 1, position = handPos, flip = true, smooth = true})
    end
  end
end

-- Conver the Raven Quill's selections from card IDs to card names.  This could be more elegant
-- but the inputs are very static so we're using some brute force.
-- @param An ArkhamDB string indicating the customization selections for The Raven's Quill.  Should
--        be either a single card ID or two separated by a ^ (e.g. XXXXX^YYYYY)
function convertRavenQuillSelections(selectionString)
  if (string.len(selectionString) == 5) then
    return getCardName(selectionString)
  elseif (string.len(selectionString) == 11) then
    return getCardName(string.sub(selectionString, 1, 5)) .. ", " .. getCardName(string.sub(selectionString, 7))
  end
end

-- Returns the simple name of a card given its ID.  This will find the card and strip any trailing
-- SCED-specific suffixes such as (Taboo) or (Level)
function getCardName(cardId)
  local configuration = getConfiguration()
  local allCardsBag = getObjectFromGUID(configuration.card_bag_guid)
  local card = allCardsBag.call("getCardById", { id = cardId })
  if (card ~= nil) then
    local name = card.data.Nickname
    if (string.find(name, " %(")) then
      return string.sub(name, 1, string.find(name, " %(") - 1)
    else
      return name
    end
  end
end

-- Split a single list of cards into a separate table of lists, keyed by the zone
---@param cards: Table of {cardData, cardMetadata, zone}
---@return: Table of {zoneName=card list}
function buildZoneLists(cards)
  local zoneList = {}
  for _, card in ipairs(cards) do
    if zoneList[card.zone] == nil then
      zoneList[card.zone] = {}
    end
    table.insert(zoneList[card.zone], card)
  end

  return zoneList
end

-- Check to see if the deck list has Ancestral Knowledge. If it does, move 5 random skills to SetAside3
---@param cardList Deck list being created
function handleAncestralKnowledge(cardList)
  local hasAncestralKnowledge = false
  local skillList = {}
  -- Have to process the entire list to check for Ancestral Knowledge and get all possible skills, so do both in one pass
  for i, card in ipairs(cardList) do
    if card.metadata.id == "07303" then
      hasAncestralKnowledge = true
      card.zone = "SetAside3"
    elseif (card.metadata.type == "Skill"
        and card.metadata.bonded_to == nil
        and not card.metadata.weakness) then
      table.insert(skillList, i)
    end
  end
  if hasAncestralKnowledge then
    for i = 1, 5 do
      -- Move 5 random skills to SetAside3
      local skillListIndex = math.random(#skillList)
      cardList[skillList[skillListIndex]].zone = "UnderSetAside3"
      table.remove(skillList, skillListIndex)
    end
  end
end

-- Check for and handle Underworld Market by moving all Illicit cards to UnderSetAside3
---@param cardList Deck list being created
---@param playerColor Color this deck is being loaded for
function handleUnderworldMarket(cardList, playerColor)
  local hasMarket = false
  local illicitList = {}
  -- Process the entire list to check for Underworld Market and get all possible skills, doing both in one pass
  for i, card in ipairs(cardList) do
    if card.metadata.id == "09077" then
      -- Underworld Market found
      hasMarket = true
      card.zone = "SetAside3"
    elseif (card.metadata.traits ~= nil and string.find(card.metadata.traits, "Illicit", 1, true)
        and card.metadata.bonded_to == nil
        and not card.metadata.weakness) then
      table.insert(illicitList, i)
    end
  end

  if hasMarket then
    if #illicitList < 10 then
      printToAll("Only " .. #illicitList ..
          " Illicit cards in your deck, you can't trigger Underworld Market's ability.",
          playerColor)
    else
      -- Process cards to move them to the market deck. This is done in reverse
      -- order because the sorting needs to be reversed (deck sorts for face down)
      -- Performance here may be an issue, as table.remove() is an O(n) operation
      -- which makes the full shift O(n^2). But keep it simple unless it becomes
      -- a problem
      for i = #illicitList, 1, -1 do
        local moving = cardList[illicitList[i]]
        moving.zone = "UnderSetAside3"
        table.remove(cardList, illicitList[i])
        table.insert(cardList, moving)
      end

      if #illicitList > 10 then
        printToAll("Moved all " .. #illicitList ..
            " Illicit cards to the Market deck, reduce it to 10",
            playerColor)
      else
        printToAll("Built the Market deck", playerColor)
      end
    end
  end
end

-- If the investigator is Joe Diamond, extract all Insight events to SetAside5 to build the Hunch
--     Deck.
---@param investigatorId ID for the deck's investigator card. Passed separately because the
---    investigator may not be included in the cardList
---@param cardList Deck list being created
---@param playerColor Color this deck is being loaded for
function handleHunchDeck(investigatorId, cardList, playerColor)
  if investigatorId == "05002" then -- Joe Diamond
    local insightList = {}
    for i, card in ipairs(cardList) do
      if (card.metadata.type == "Event"
          and card.metadata.traits ~= nil
          and string.match(card.metadata.traits, "Insight")
          and card.metadata.bonded_to == nil) then
        table.insert(insightList, i)
      end
    end
    -- Process insights to move them to the hunch deck. This is done in reverse
    -- order because the sorting needs to be reversed (deck sorts for face down)
    -- Performance here may be an issue, as table.remove() is an O(n) operation
    -- which makes the full shift O(n^2). But keep it simple unless it becomes
    -- a problem
    for i = #insightList, 1, -1 do
      local moving = cardList[insightList[i]]
      moving.zone = "SetAside5"
      table.remove(cardList, insightList[i])
      table.insert(cardList, moving)
    end
    if #insightList < 11 then
      printToAll("Joe's hunch deck must have 11 cards but the deck only has " .. #insightList ..
          " Insight events.", playerColor)
    elseif #insightList > 11 then
      printToAll("Moved all " .. #insightList ..
          " Insight events to the hunch deck, reduce it to 11.", playerColor)
    else
      printToAll("Built Joe's hunch deck", playerColor)
    end
  end
end

-- For any customization upgrade cards in the card list, process the metadata from the deck to
-- set the save state to show the correct checkboxes/text field values
---@param cardList Deck list being created
---@param customizations Deck's meta table, extracted from ArkhamDB's deck structure
function handleCustomizableUpgrades(cardList, customizations)
  for _, card in ipairs(cardList) do
    if card.metadata.type == "UpgradeSheet" then
      local baseId = string.sub(card.metadata.id, 1, 5)
      local upgrades = customizations["cus_" .. baseId]
      log(upgrades)
      log(baseId)

      if upgrades ~= nil then
        -- initialize tables
        -- markedBoxes: contains the amount of markedBoxes (left to right) per row (starting at row 1)
        -- inputValues: contains the amount of inputValues per row (starting at row 0)
        local markedBoxes = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }
        local inputValues = {}
        local index_xp    = {}

        -- get the index and xp values (looks like this: X|X,X|X, ..)
        for str in string.gmatch(customizations["cus_" .. baseId], "([^,]+)") do
          table.insert(index_xp, str)
        end

        -- split each pair and assign it to the proper position in markedBoxes
        if (customizationRowsWithFields[baseId] ~= nil) then
          for i = 1, customizationRowsWithFields[baseId].inputCount do
            table.insert(inputValues, "")
          end
        end
        local inputCount = 0
        for _, entry in ipairs(index_xp) do
          local counter = 0
          local index   = 0

          -- if found number is 0, then only get inputvalue
          for str in string.gmatch(entry, "([^|]+)") do
            counter = counter + 1
            if counter == 1 then
              index = tonumber(str) + 1
            elseif counter == 2 then
              markedBoxes[index] = tonumber(str)
            elseif counter == 3 and str ~= "" then
              if (baseId == "09042") then
                inputValues[customizationRowsWithFields[baseId].inputMap[index]] = convertRavenQuillSelections(str)
              elseif customizationRowsWithFields[baseId] ~= nil then
                inputValues[customizationRowsWithFields[baseId].inputMap[index]] = str
              end
            end
          end
        end

        -- remove first entry in markedBoxes if row 0 has textbox
        if customizationRowsWithFields[baseId] ~= nil
            and customizationRowsWithFields[baseId].inputCount > 0 then
          table.remove(markedBoxes, 1)
        end

        -- write the loaded values to the save_data of the sheets
        card.data["LuaScriptState"] = JSON.encode({ markedBoxes, inputValues })
      end
    end
  end
end

function log(message)
  if DEBUG then print(message) end
end
