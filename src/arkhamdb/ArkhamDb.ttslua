do
  local allCardsBagApi = require("playercards/AllCardsBagApi")
  local playAreaApi = require("core/PlayAreaApi")

  local ArkhamDb = {}
  local internal = {}
  
  local tabooList = {}
  local configuration

  local RANDOM_WEAKNESS_ID = "01000"

  ---@class Request
  local Request = {}

  -- Sets up the ArkhamDb interface.  Should be called from the parent object on load.
  ArkhamDb.initialize = function()
    configuration = internal.getConfiguration()
    Request.start({ configuration.api_uri, configuration.taboo }, function(status)
      local json = JSON.decode(internal.fixUtf16String(status.text))
      for _, taboo in pairs(json) do
        local cards = {}

        for _, card in pairs(JSON.decode(taboo.cards)) do
          cards[card.code] = true
        end

        tabooList[taboo.id] = {
          date = taboo.date_start,
          cards = cards
        }
      end
      return true, nil
    end)
  end

  -- Start the deck build process for the given player color and deck ID.  This
  -- will retrieve the deck from ArkhamDB, and pass to a callback for processing.
  ---@param playerColor string Color name of the player mat to place this deck on (e.g. "Red").
  ---@param deckId string ArkhamDB deck id to be loaded
  ---@param isPrivate boolean Whether this deck is published or private on ArkhamDB
  ---@param loadNewest boolean Whether the newest version of this deck should be loaded
  ---@param loadInvestigators boolean Whether investigator cards should be loaded as part of this deck
  ---@param callback function Callback which will be sent the results of this load
  ---    Parameters to the callback will be:
  ---        slots table A map of card ID to count in the deck
  ---        investigatorCode String.  ID of the investigator in this deck
  ---        customizations table The decoded table of customization upgrades in this deck
  ---        playerColor String.  Color this deck is being loaded for
  ---@return boolean
  ---@return string
  ArkhamDb.getDecklist = function(
      playerColor,
      deckId,
      isPrivate,
      loadNewest,
      loadInvestigators,
      callback)
    -- Get a simple card to see if the bag indexes are complete. If not, abort
    -- the deck load. The called method will handle player notification.
    local checkCard = allCardsBagApi.getCardById("01001")
    if (checkCard ~= nil and checkCard.data == nil) then
      return false, "Indexing not complete"
    end

    local deckUri = {
      configuration.api_uri,
      isPrivate and configuration.private_deck or configuration.public_deck,
      deckId
    }

    local deck = Request.start(deckUri, function(status)
      if string.find(status.text, "<!DOCTYPE html>") then
        internal.maybePrint("Private deck ID " .. deckId .. " is not shared", playerColor)
        return false, "Private deck " .. deckId .. " is not shared"
      end
      local json = JSON.decode(status.text)

      if not json then
        internal.maybePrint("Deck ID " .. deckId .. " not found", playerColor)
        return false, "Deck not found!"
      end

      return true, json
    end)

    deck:with(internal.onDeckResult, playerColor, loadNewest, loadInvestigators, callback)
  end

  -- Logs that a card could not be loaded in the mod by printing it to the console in the given
  -- color of the player owning the deck.  Attempts to look up the name on ArkhamDB for clarity,
  -- but prints the card ID if the name cannot be retrieved.
  ---@param cardId string ArkhamDB ID of the card that could not be found
  ---@param playerColor string Color of the player's deck that had the problem
  ArkhamDb.logCardNotFound = function(cardId, playerColor)
    local request = Request.start({
      configuration.api_uri,
      configuration.cards,
      cardId
    },
      function(result)
        local adbCardInfo = JSON.decode(internal.fixUtf16String(result.text))
        local cardName = adbCardInfo.real_name
        if (cardName ~= nil) then
          if (adbCardInfo.xp ~= nil and adbCardInfo.xp > 0) then
            cardName = cardName .. " (" .. adbCardInfo.xp .. ")"
          end
          internal.maybePrint("Card not found: " .. cardName .. ", ArkhamDB ID " .. cardId, playerColor)
        else
          internal.maybePrint("Card not found in ArkhamDB, ID " .. cardId, playerColor)
        end
      end)
  end

  -- Callback when the deck information is received from ArkhamDB.  Parses the
  -- response then applies standard transformations to the deck such as adding
  -- random weaknesses and checking for taboos.  Once the deck is processed,
  -- passes to loadCards to actually spawn the defined deck.
  ---@param deck table ArkhamImportDeck
  ---@param playerColor string Color name of the player mat to place this deck on (e.g. "Red")
  ---@param loadNewest boolean Whether the newest version of this deck should be loaded
  ---@param loadInvestigators boolean Whether investigator cards should be loaded as part of this deck
  ---@param callback function Callback which will be sent the results of this load.
  ---    Parameters to the callback will be:
  ---        slots table A map of card ID to count in the deck
  ---        investigatorCode String.  ID of the investigator in this deck
  ---        bondedList A table of cardID keys to meaningless values.  Card IDs in this list were
  ---        added from a parent bonded card.
  ---        customizations table The decoded table of customization upgrades in this deck
  ---        playerColor String.  Color this deck is being loaded for
  internal.onDeckResult = function(deck, playerColor, loadNewest, loadInvestigators, callback)
    -- Load the next deck in the upgrade path if the option is enabled
    if (loadNewest and deck.next_deck ~= nil and deck.next_deck ~= "") then
      buildDeck(playerColor, deck.next_deck)
      return
    end

    internal.maybePrint(table.concat({ "Found decklist: ", deck.name }), playerColor)
    local slots = deck.slots
    local loadAltInvestigator = "normal"
    if loadInvestigators then
      loadAltInvestigator = internal.addInvestigatorCards(deck, slots)
    end

    internal.maybeModifyDeckFromDescription(slots, deck.description_md)

    local customizations = {}
    if deck.meta then
      customizations = JSON.decode(deck.meta)
    end

    local deckData = {
      slots = slots,
      taboo_id = deck.taboo_id,
      investigatorId = deck.investigator_code,
      customizations = customizations,
      playerColor = playerColor,
      loadAltInvestigator = loadAltInvestigator
    }

    ArkhamDb.adjustDeck(deckData, callback)
  end

  ArkhamDb.adjustDeck = function(deckData, callback)
    -- Initialize deck slot table and perform common transformations.  The order of these should not
    -- be changed, as later steps may act on cards added in each.  For example, a random weakness or
    -- investigator may have bonded cards or taboo entries, and should be present
    local slots = deckData.slots
    internal.maybeDrawRandomWeakness(slots, playerColor)
    internal.maybeAddSummonedServitor(slots)
    internal.maybeAddOnTheMend(slots, playerColor)
    internal.maybeAddRealityAcidReference(slots)
    local bondList = internal.extractBondedCards(slots)
    internal.checkTaboos(deckData.taboo_id, slots, playerColor)
    internal.maybeAddUpgradeSheets(slots)

    -- get upgrades for customizable cards
    

    callback(slots, deckData.investigatorId, bondList, deckData.customizations, deckData.playerColor, deckData.loadAltInvestigator)
  end

  -- Checks to see if the slot list includes the random weakness ID. If it does,
  -- removes it from the deck and replaces it with the ID of a random basic weakness provided by the
  -- all cards bag
  ---@param slots table The slot list for cards in this deck. Table key is the cardId, value is the number
  ---    of those cards which will be spawned
  ---@param playerColor string Color of the player this deck is being loaded for. Used for broadcast
  ---    if a weakness is added.
  internal.maybeDrawRandomWeakness = function(slots, playerColor)
    local randomWeaknessAmount = slots[RANDOM_WEAKNESS_ID] or 0
    slots[RANDOM_WEAKNESS_ID] = nil

    if randomWeaknessAmount ~= 0 then
      for i=1, randomWeaknessAmount do
        local weaknessId = allCardsBagApi.getRandomWeaknessId()
        slots[weaknessId] = (slots[weaknessId] or 0) + 1
      end
      internal.maybePrint("Added " .. randomWeaknessAmount .. " random basic weakness(es) to deck", playerColor)
    end
  end

  -- Adds both the investigator (XXXXX) and minicard (XXXXX-m) slots with one copy each
  ---@param deck table The processed ArkhamDB deck response
  ---@param slots table The slot list for cards in this deck.  Table key is the cardId, value is the
  ---    number of those cards which will be spawned
  ---@return string: Contains the name of the art that should be loaded ("normal", "promo" or "revised")
  internal.addInvestigatorCards = function(deck, slots)
    local investigatorId = deck.investigator_code
    slots[investigatorId .. "-m"] = 1
    local deckMeta = JSON.decode(deck.meta)
    -- handling alternative investigator art and parallel investigators
    local loadAltInvestigator = "normal"
    if deckMeta ~= nil then
      local altFrontId = tonumber(deckMeta.alternate_front) or 0
      local altBackId  = tonumber(deckMeta.alternate_back) or 0
      local altArt     = { front = "normal", back = "normal" }

      -- translating front ID
      if altFrontId > 90000 and altFrontId < 90100 then
        altArt.front = "parallel"
      elseif altFrontId > 01500 and altFrontId < 01506 then
        altArt.front = "revised"
      elseif altFrontId > 98000 then
        altArt.front = "promo"
      end

      -- translating back ID
      if altBackId > 90000 and altBackId < 90100 then
        altArt.back = "parallel"
      elseif altBackId > 01500 and altBackId < 01506 then
        altArt.back = "revised"
      elseif altBackId > 98000 then
        altArt.back = "promo"
      end

      -- updating investigatorID based on alt investigator selection
      -- precedence: parallel > promo > revised
      if altArt.front == "parallel" then
        if altArt.back == "parallel" then
          investigatorId = investigatorId .. "-p"
        else
          investigatorId = investigatorId .. "-pf"
        end
      elseif altArt.back == "parallel" then
        investigatorId = investigatorId .. "-pb"
      elseif altArt.front == "promo" or altArt.back == "promo" then
        loadAltInvestigator = "promo"
      elseif altArt.front == "revised" or altArt.back == "revised" then
        loadAltInvestigator = "revised"
      end
    end
    slots[investigatorId] = 1
    deck.investigator_code = investigatorId
    return loadAltInvestigator
  end

  -- Process the card list looking for the customizable cards, and add their upgrade sheets if needed
  ---@param slots table The slot list for cards in this deck. Table key is the cardId, value is the number
  --     of those cards which will be spawned
  internal.maybeAddUpgradeSheets = function(slots)
    for cardId, _ in pairs(slots) do
      -- upgrade sheets for customizable cards
      local upgradesheet = allCardsBagApi.getCardById(cardId .. "-c")
      if upgradesheet ~= nil then
        slots[cardId .. "-c"] = 1
      end
    end
  end

  -- Process the card list looking for the Summoned Servitor, and add its minicard to the list if
  -- needed
  ---@param slots table The slot list for cards in this deck. Table key is the cardId, value is the number
  --     of those cards which will be spawned
  internal.maybeAddSummonedServitor = function(slots)
    if slots["09080"] ~= nil then
      slots["09080-m"] = 1
    end
  end

  -- On the Mend should have 1-per-investigator copies set aside, but ArkhamDB always sends 1.  Update
  -- the count based on the investigator count
  ---@param slots table The slot list for cards in this deck. Table key is the cardId, value is the number
  --     of those cards which will be spawned
  ---@param playerColor string Color of the player this deck is being loaded for. Used for broadcast if an error occurs
  internal.maybeAddOnTheMend = function(slots, playerColor)
    if slots["09006"] ~= nil then
      local investigatorCount = playAreaApi.getInvestigatorCount()
      if investigatorCount ~= nil then
        slots["09006"] = investigatorCount
      else
        internal.maybePrint("Something went wrong with the load, adding 4 copies of On the Mend", playerColor)
        slots["09006"] = 4
      end
    end
  end

  -- Process the card list looking for Reality Acid and adds the reference sheet when needed
  ---@param slots table The slot list for cards in this deck. Table key is the cardId, value is the number
  --     of those cards which will be spawned
  internal.maybeAddRealityAcidReference = function(slots)
    if slots["89004"] ~= nil then
      slots["89005"] = 1
    end
  end

  -- Processes the deck description from ArkhamDB and modifies the slot list accordingly
  ---@param slots table The slot list for cards in this deck. Table key is the cardId, value is the number
  ---@param description string The deck desription from ArkhamDB
  internal.maybeModifyDeckFromDescription = function(slots, description)
    -- check for import instructions
    local pos = string.find(description, "++SCED import instructions++")
    if not pos then return end

    -- remove everything before instructions (including newline)
    local tempStr = string.sub(description, pos + 30)
    
    -- parse each line in instructions
    for line in tempStr:gmatch("([^\n]+)") do
      -- remove dashes at the start
      line = line:gsub("%- ", "")

      -- remove spaces
      line = line:gsub("%s", "")

      -- get instructor
      local instructor = ""
      for word in line:gmatch("%a+:") do
        instructor = word
        break
      end

      if instructor == "" or (instructor ~= "add:" and instructor ~= "remove:") then break end

      -- remove instructor from line
      line = line:gsub(instructor, "")

      -- evaluate instructions
      for str in line:gmatch("([^,]+)") do
        if instructor == "add:" then
          slots[str] = (slots[str] or 0) + 1
        elseif instructor == "remove:" then
          if slots[str] == nil then break end
          slots[str] = math.max(slots[str] - 1, 0)

          if slots[str] == 0 then
            slots[str] = nil
          end
        end
      end
    end
  end

  -- Process the slot list and looks for any cards which are bonded to those in the deck. Adds those cards to the slot list.
  ---@param slots table The slot list for cards in this deck. Table key is the cardId, value is the number of those cards which will be spawned
  internal.extractBondedCards = function(slots)
    -- Create a list of bonded cards first so we don't modify slots while iterating
    local bondedCards = { }
    local bondedList = { }
    for cardId, cardCount in pairs(slots) do
      local card = allCardsBagApi.getCardById(cardId)
      if (card ~= nil and card.metadata.bonded ~= nil) then
        for _, bond in ipairs(card.metadata.bonded) do
          -- add a bonded card for each copy of the parent card (except for Pendant of the Queen)
          if bond.id == "06022" then
            bondedCards[bond.id] = bond.count
          else
            bondedCards[bond.id] = bond.count * cardCount
          end
          -- We need to know which cards are bonded to determine their position, remember them
          bondedList[bond.id] = true
          -- Also adding taboo versions of bonded cards to the list
          bondedList[bond.id .. "-t"] = true
        end
      end
    end
    -- Add any bonded cards to the main slots list
    for bondedId, bondedCount in pairs(bondedCards) do
      slots[bondedId] = bondedCount
    end

    return bondedList
  end

  -- Check the deck for cards on its taboo list. If they're found, replace the entry in the slot with the Taboo id (i.e. "XXXX" becomes "XXXX-t")
  ---@param tabooId string The deck's taboo ID, taken from the deck response taboo_id field. May be nil, indicating that no taboo list should be used
  ---@param slots table The slot list for cards in this deck. Table key is the cardId, value is the number of those cards which will be spawned
  internal.checkTaboos = function(tabooId, slots, playerColor)
    if tabooId then
      for cardId, _ in pairs(tabooList[tabooId].cards) do
        if slots[cardId] ~= nil then
          -- Make sure there's a taboo version of the card before we replace it
          -- SCED only maintains the most recent taboo cards. If a deck is using
          -- an older taboo list it's possible the card isn't a taboo any more
          local tabooCard = allCardsBagApi.getCardById(cardId .. "-t")
          if tabooCard == nil then
            local basicCard = allCardsBagApi.getCardById(cardId)
            internal.maybePrint("Taboo version for " .. basicCard.data.Nickname .. " is not available. Using standard version", playerColor)
          else
            slots[cardId .. "-t"] = slots[cardId]
            slots[cardId] = nil
          end
        end
      end
    end
  end

  internal.maybePrint = function(message, playerColor)
    if playerColor ~= "None" then
      printToAll(message, playerColor)
    end
  end

  -- Gets the ArkhamDB config info from the configuration object.
  ---@return table: configuration data
  internal.getConfiguration = function()
    local configuration = getObjectsWithTag("import_configuration_provider")[1].getTable("configuration")
    printPriority = configuration.priority
    return configuration
  end

  internal.fixUtf16String = function(str)
    return str:gsub("\\u(%w%w%w%w)", function(match)
      return string.char(tonumber(match, 16))
    end)
  end

  Request = {
    is_done = false,
    is_successful = false
  }

  -- Creates a new instance of a Request. Should not be directly called. Instead use Request.start() and Request.deferred().
  ---@param uri table
  ---@param configure fun(request, status)
  ---@return Request
  function Request:new(uri, configure)
    local this = {}

    setmetatable(this, self)
    self.__index = self

    if type(uri) == "table" then
      uri = table.concat(uri, "/")
    end

    this.uri = uri
    WebRequest.get(uri, function(status) configure(this, status) end)

    return this
  end

  -- Creates a new request. on_success should set the request's is_done, is_successful, and content variables.
  -- Deferred should be used when you don't want to set is_done immediately (such as if you want to wait for another request to finish)
  ---@param uri table
  ---@param on_success fun(request, status, vararg)
  ---@param on_error fun(status)|nil
  ---@return Request
  function Request.deferred(uri, on_success, on_error, ...)
    local parameters = table.pack(...)
    return Request:new(uri, function(request, status)
      if (status.is_done) then
        if (status.is_error) then
          request.error_message = on_error and on_error(status, table.unpack(parameters)) or status.error
          request.is_successful = false
          request.is_done = true
        else
          on_success(request, status)
        end
      end
    end)
  end

  -- Creates a new request. on_success should return whether the resultant data is as expected, and the processed content of the request.
  ---@param uri table
  ---@param on_success fun(status, vararg): boolean, any
  ---@param on_error nil|fun(status, vararg): string
  ---@vararg any
  ---@return Request
  function Request.start(uri, on_success, on_error, ...)
    local parameters = table.pack(...)
    return Request.deferred(uri, function(request, status)
      local result, message = on_success(status, table.unpack(parameters))
      if not result then request.error_message = message else request.content = message end
      request.is_successful = result
      request.is_done = true
    end, on_error, table.unpack(parameters))
  end

  ---@param requests Request[]
  ---@param on_success fun(content: any, vararg: any)
  ---@param on_error fun(requests: Request, vararg: any)|nil
  ---@vararg any
  function Request.with_all(requests, on_success, on_error, ...)
    local parameters = table.pack(...)

    Wait.condition(function()
      local results = {}
      local errors = {}

      for _, request in ipairs(requests) do
        if request.is_successful then
          table.insert(results, request.content)
        else
          table.insert(errors, request)
        end
      end

      if (#errors <= 0) then
        on_success(results, table.unpack(parameters))
      elseif on_error == nil then
        for _, request in ipairs(errors) do
          internal.maybePrint(table.concat({ "[ERROR]", request.uri, ":", request.error_message }))
        end
      else
        on_error(requests, table.unpack(parameters))
      end
    end, function()
      for _, request in ipairs(requests) do
        if not request.is_done then return false end
      end
      return true
    end)
  end

  function Request:with(callback, ...)
    local arguments = table.pack(...)
    Wait.condition(function()
      if self.is_successful then
        callback(self.content, table.unpack(arguments))
      end
    end, function() return self.is_done
    end)
  end

  return ArkhamDb
end
